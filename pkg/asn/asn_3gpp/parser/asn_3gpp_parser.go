// Code generated from ASN_3gpp.g4 by ANTLR 4.7.1. DO NOT EDIT.

package parser // ASN_3gpp

import (
	"fmt"
	"reflect"
	"strconv"

	"github.com/antlr/antlr4/runtime/Go/antlr"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = reflect.Copy
var _ = strconv.Itoa

var parserATN = []uint16{
	3, 24715, 42794, 33075, 47597, 16764, 15335, 30598, 22884, 3, 109, 1296,
	4, 2, 9, 2, 4, 3, 9, 3, 4, 4, 9, 4, 4, 5, 9, 5, 4, 6, 9, 6, 4, 7, 9, 7,
	4, 8, 9, 8, 4, 9, 9, 9, 4, 10, 9, 10, 4, 11, 9, 11, 4, 12, 9, 12, 4, 13,
	9, 13, 4, 14, 9, 14, 4, 15, 9, 15, 4, 16, 9, 16, 4, 17, 9, 17, 4, 18, 9,
	18, 4, 19, 9, 19, 4, 20, 9, 20, 4, 21, 9, 21, 4, 22, 9, 22, 4, 23, 9, 23,
	4, 24, 9, 24, 4, 25, 9, 25, 4, 26, 9, 26, 4, 27, 9, 27, 4, 28, 9, 28, 4,
	29, 9, 29, 4, 30, 9, 30, 4, 31, 9, 31, 4, 32, 9, 32, 4, 33, 9, 33, 4, 34,
	9, 34, 4, 35, 9, 35, 4, 36, 9, 36, 4, 37, 9, 37, 4, 38, 9, 38, 4, 39, 9,
	39, 4, 40, 9, 40, 4, 41, 9, 41, 4, 42, 9, 42, 4, 43, 9, 43, 4, 44, 9, 44,
	4, 45, 9, 45, 4, 46, 9, 46, 4, 47, 9, 47, 4, 48, 9, 48, 4, 49, 9, 49, 4,
	50, 9, 50, 4, 51, 9, 51, 4, 52, 9, 52, 4, 53, 9, 53, 4, 54, 9, 54, 4, 55,
	9, 55, 4, 56, 9, 56, 4, 57, 9, 57, 4, 58, 9, 58, 4, 59, 9, 59, 4, 60, 9,
	60, 4, 61, 9, 61, 4, 62, 9, 62, 4, 63, 9, 63, 4, 64, 9, 64, 4, 65, 9, 65,
	4, 66, 9, 66, 4, 67, 9, 67, 4, 68, 9, 68, 4, 69, 9, 69, 4, 70, 9, 70, 4,
	71, 9, 71, 4, 72, 9, 72, 4, 73, 9, 73, 4, 74, 9, 74, 4, 75, 9, 75, 4, 76,
	9, 76, 4, 77, 9, 77, 4, 78, 9, 78, 4, 79, 9, 79, 4, 80, 9, 80, 4, 81, 9,
	81, 4, 82, 9, 82, 4, 83, 9, 83, 4, 84, 9, 84, 4, 85, 9, 85, 4, 86, 9, 86,
	4, 87, 9, 87, 4, 88, 9, 88, 4, 89, 9, 89, 4, 90, 9, 90, 4, 91, 9, 91, 4,
	92, 9, 92, 4, 93, 9, 93, 4, 94, 9, 94, 4, 95, 9, 95, 4, 96, 9, 96, 4, 97,
	9, 97, 4, 98, 9, 98, 4, 99, 9, 99, 4, 100, 9, 100, 4, 101, 9, 101, 4, 102,
	9, 102, 4, 103, 9, 103, 4, 104, 9, 104, 4, 105, 9, 105, 4, 106, 9, 106,
	4, 107, 9, 107, 4, 108, 9, 108, 4, 109, 9, 109, 4, 110, 9, 110, 4, 111,
	9, 111, 4, 112, 9, 112, 4, 113, 9, 113, 4, 114, 9, 114, 4, 115, 9, 115,
	4, 116, 9, 116, 4, 117, 9, 117, 4, 118, 9, 118, 4, 119, 9, 119, 4, 120,
	9, 120, 4, 121, 9, 121, 4, 122, 9, 122, 4, 123, 9, 123, 4, 124, 9, 124,
	4, 125, 9, 125, 4, 126, 9, 126, 4, 127, 9, 127, 4, 128, 9, 128, 4, 129,
	9, 129, 4, 130, 9, 130, 4, 131, 9, 131, 4, 132, 9, 132, 4, 133, 9, 133,
	4, 134, 9, 134, 4, 135, 9, 135, 4, 136, 9, 136, 4, 137, 9, 137, 4, 138,
	9, 138, 4, 139, 9, 139, 4, 140, 9, 140, 4, 141, 9, 141, 4, 142, 9, 142,
	4, 143, 9, 143, 4, 144, 9, 144, 4, 145, 9, 145, 4, 146, 9, 146, 4, 147,
	9, 147, 4, 148, 9, 148, 4, 149, 9, 149, 4, 150, 9, 150, 4, 151, 9, 151,
	3, 2, 6, 2, 304, 10, 2, 13, 2, 14, 2, 305, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	3, 3, 7, 3, 314, 10, 3, 12, 3, 14, 3, 317, 11, 3, 3, 3, 5, 3, 320, 10,
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 4, 5, 4, 332,
	10, 4, 3, 5, 3, 5, 5, 5, 336, 10, 5, 3, 6, 3, 6, 3, 6, 3, 6, 5, 6, 342,
	10, 6, 3, 7, 3, 7, 3, 7, 3, 7, 3, 7, 3, 7, 3, 7, 5, 7, 351, 10, 7, 3, 8,
	5, 8, 354, 10, 8, 3, 9, 3, 9, 3, 9, 3, 9, 5, 9, 360, 10, 9, 3, 10, 5, 10,
	363, 10, 10, 3, 11, 3, 11, 7, 11, 367, 10, 11, 12, 11, 14, 11, 370, 11,
	11, 3, 12, 3, 12, 3, 12, 3, 12, 3, 13, 3, 13, 3, 13, 3, 14, 3, 14, 3, 15,
	3, 15, 3, 15, 7, 15, 384, 10, 15, 12, 15, 14, 15, 387, 11, 15, 3, 16, 3,
	16, 3, 16, 5, 16, 392, 10, 16, 3, 17, 3, 17, 7, 17, 396, 10, 17, 12, 17,
	14, 17, 399, 11, 17, 3, 18, 3, 18, 3, 18, 3, 18, 3, 18, 5, 18, 406, 10,
	18, 3, 19, 3, 19, 3, 19, 3, 19, 3, 19, 3, 19, 5, 19, 414, 10, 19, 3, 19,
	3, 19, 3, 20, 3, 20, 5, 20, 420, 10, 20, 3, 21, 3, 21, 5, 21, 424, 10,
	21, 3, 22, 3, 22, 3, 22, 3, 22, 5, 22, 430, 10, 22, 3, 22, 3, 22, 3, 22,
	3, 22, 3, 22, 3, 22, 3, 22, 5, 22, 439, 10, 22, 5, 22, 441, 10, 22, 5,
	22, 443, 10, 22, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22, 5, 22,
	452, 10, 22, 5, 22, 454, 10, 22, 5, 22, 456, 10, 22, 3, 23, 3, 23, 3, 24,
	3, 24, 3, 24, 5, 24, 463, 10, 24, 3, 24, 7, 24, 466, 10, 24, 12, 24, 14,
	24, 469, 11, 24, 3, 25, 3, 25, 3, 25, 3, 25, 5, 25, 475, 10, 25, 3, 25,
	3, 25, 3, 25, 5, 25, 480, 10, 25, 3, 26, 3, 26, 3, 26, 5, 26, 485, 10,
	26, 3, 27, 3, 27, 3, 27, 3, 28, 3, 28, 3, 28, 3, 29, 3, 29, 5, 29, 495,
	10, 29, 3, 30, 3, 30, 3, 30, 7, 30, 500, 10, 30, 12, 30, 14, 30, 503, 11,
	30, 3, 31, 3, 31, 5, 31, 507, 10, 31, 3, 32, 3, 32, 3, 32, 3, 32, 5, 32,
	513, 10, 32, 3, 32, 3, 32, 3, 33, 3, 33, 5, 33, 519, 10, 33, 3, 34, 3,
	34, 3, 34, 3, 34, 5, 34, 525, 10, 34, 3, 34, 3, 34, 5, 34, 529, 10, 34,
	3, 34, 3, 34, 3, 34, 5, 34, 534, 10, 34, 3, 35, 3, 35, 3, 35, 3, 36, 3,
	36, 3, 36, 3, 36, 3, 36, 5, 36, 544, 10, 36, 3, 36, 3, 36, 3, 36, 3, 36,
	3, 36, 5, 36, 551, 10, 36, 5, 36, 553, 10, 36, 3, 37, 3, 37, 3, 37, 3,
	37, 7, 37, 559, 10, 37, 12, 37, 14, 37, 562, 11, 37, 3, 37, 3, 37, 3, 38,
	3, 38, 3, 38, 5, 38, 569, 10, 38, 3, 38, 3, 38, 3, 39, 3, 39, 5, 39, 575,
	10, 39, 3, 40, 3, 40, 5, 40, 579, 10, 40, 3, 41, 3, 41, 3, 41, 3, 42, 3,
	42, 5, 42, 586, 10, 42, 3, 43, 3, 43, 5, 43, 590, 10, 43, 3, 43, 3, 43,
	3, 43, 5, 43, 595, 10, 43, 3, 44, 3, 44, 3, 45, 3, 45, 3, 45, 3, 45, 3,
	46, 3, 46, 3, 46, 3, 46, 3, 46, 7, 46, 608, 10, 46, 12, 46, 14, 46, 611,
	11, 46, 3, 46, 3, 46, 5, 46, 615, 10, 46, 3, 47, 3, 47, 3, 47, 3, 47, 3,
	48, 3, 48, 6, 48, 623, 10, 48, 13, 48, 14, 48, 624, 3, 48, 3, 48, 3, 49,
	3, 49, 5, 49, 631, 10, 49, 3, 50, 3, 50, 6, 50, 635, 10, 50, 13, 50, 14,
	50, 636, 3, 50, 3, 50, 3, 51, 3, 51, 5, 51, 643, 10, 51, 3, 52, 3, 52,
	3, 53, 3, 53, 3, 53, 3, 54, 3, 54, 3, 54, 5, 54, 653, 10, 54, 3, 54, 3,
	54, 5, 54, 657, 10, 54, 3, 54, 5, 54, 660, 10, 54, 3, 54, 5, 54, 663, 10,
	54, 5, 54, 665, 10, 54, 3, 54, 3, 54, 3, 54, 3, 54, 3, 54, 5, 54, 672,
	10, 54, 5, 54, 674, 10, 54, 3, 54, 3, 54, 3, 54, 3, 54, 3, 54, 5, 54, 681,
	10, 54, 5, 54, 683, 10, 54, 5, 54, 685, 10, 54, 3, 55, 3, 55, 3, 55, 5,
	55, 690, 10, 55, 3, 56, 3, 56, 3, 56, 5, 56, 695, 10, 56, 3, 57, 3, 57,
	3, 57, 3, 57, 5, 57, 701, 10, 57, 3, 57, 5, 57, 704, 10, 57, 3, 58, 3,
	58, 3, 58, 5, 58, 709, 10, 58, 3, 59, 3, 59, 3, 59, 3, 59, 5, 59, 715,
	10, 59, 3, 60, 3, 60, 3, 60, 3, 60, 5, 60, 721, 10, 60, 3, 61, 3, 61, 3,
	61, 5, 61, 726, 10, 61, 3, 62, 3, 62, 5, 62, 730, 10, 62, 3, 63, 3, 63,
	3, 63, 3, 64, 3, 64, 5, 64, 737, 10, 64, 3, 65, 3, 65, 3, 65, 3, 65, 3,
	66, 3, 66, 3, 66, 3, 66, 3, 66, 5, 66, 748, 10, 66, 5, 66, 750, 10, 66,
	3, 66, 3, 66, 3, 66, 5, 66, 755, 10, 66, 5, 66, 757, 10, 66, 3, 67, 3,
	67, 3, 67, 3, 67, 3, 67, 3, 67, 7, 67, 765, 10, 67, 12, 67, 14, 67, 768,
	11, 67, 3, 68, 3, 68, 3, 68, 3, 68, 3, 69, 3, 69, 3, 69, 3, 69, 3, 69,
	5, 69, 779, 10, 69, 5, 69, 781, 10, 69, 3, 70, 3, 70, 3, 71, 3, 71, 3,
	72, 3, 72, 3, 72, 5, 72, 790, 10, 72, 3, 73, 3, 73, 3, 73, 3, 73, 7, 73,
	796, 10, 73, 12, 73, 14, 73, 799, 11, 73, 3, 74, 3, 74, 3, 74, 3, 75, 3,
	75, 3, 75, 3, 75, 7, 75, 808, 10, 75, 12, 75, 14, 75, 811, 11, 75, 3, 76,
	3, 76, 3, 77, 3, 77, 3, 78, 3, 78, 3, 79, 3, 79, 5, 79, 821, 10, 79, 3,
	80, 3, 80, 5, 80, 825, 10, 80, 3, 81, 3, 81, 5, 81, 829, 10, 81, 3, 81,
	5, 81, 832, 10, 81, 3, 81, 3, 81, 5, 81, 836, 10, 81, 3, 81, 3, 81, 5,
	81, 840, 10, 81, 3, 81, 3, 81, 3, 81, 3, 81, 5, 81, 846, 10, 81, 3, 82,
	3, 82, 3, 82, 3, 82, 5, 82, 852, 10, 82, 3, 83, 3, 83, 3, 83, 3, 83, 5,
	83, 858, 10, 83, 3, 84, 3, 84, 3, 84, 5, 84, 863, 10, 84, 3, 85, 3, 85,
	3, 85, 3, 85, 5, 85, 869, 10, 85, 3, 86, 3, 86, 3, 86, 5, 86, 874, 10,
	86, 3, 87, 3, 87, 3, 87, 3, 88, 3, 88, 3, 88, 3, 88, 3, 89, 3, 89, 5, 89,
	885, 10, 89, 3, 89, 7, 89, 888, 10, 89, 12, 89, 14, 89, 891, 11, 89, 3,
	90, 3, 90, 3, 90, 3, 90, 3, 90, 3, 90, 3, 90, 3, 90, 3, 90, 3, 90, 3, 90,
	3, 90, 3, 90, 5, 90, 906, 10, 90, 3, 91, 3, 91, 3, 91, 3, 91, 3, 92, 3,
	92, 3, 92, 3, 92, 3, 92, 3, 92, 5, 92, 918, 10, 92, 3, 92, 3, 92, 3, 93,
	3, 93, 3, 93, 5, 93, 925, 10, 93, 3, 93, 3, 93, 3, 93, 5, 93, 930, 10,
	93, 3, 94, 3, 94, 3, 95, 3, 95, 3, 95, 5, 95, 937, 10, 95, 3, 95, 5, 95,
	940, 10, 95, 3, 96, 3, 96, 3, 96, 5, 96, 945, 10, 96, 3, 96, 3, 96, 3,
	97, 3, 97, 5, 97, 951, 10, 97, 3, 98, 3, 98, 3, 98, 3, 98, 3, 98, 3, 98,
	7, 98, 959, 10, 98, 12, 98, 14, 98, 962, 11, 98, 3, 98, 3, 98, 3, 99, 3,
	99, 3, 99, 5, 99, 969, 10, 99, 3, 100, 3, 100, 3, 100, 3, 100, 3, 100,
	3, 100, 5, 100, 977, 10, 100, 3, 101, 3, 101, 3, 102, 3, 102, 3, 103, 3,
	103, 3, 103, 3, 103, 3, 103, 3, 103, 3, 103, 3, 103, 3, 103, 3, 103, 3,
	103, 3, 103, 3, 103, 3, 103, 3, 103, 3, 103, 3, 103, 5, 103, 1000, 10,
	103, 3, 104, 5, 104, 1003, 10, 104, 3, 104, 3, 104, 3, 104, 3, 104, 5,
	104, 1009, 10, 104, 5, 104, 1011, 10, 104, 3, 104, 3, 104, 3, 104, 5, 104,
	1016, 10, 104, 5, 104, 1018, 10, 104, 3, 105, 3, 105, 3, 105, 7, 105, 1023,
	10, 105, 12, 105, 14, 105, 1026, 11, 105, 3, 106, 3, 106, 3, 106, 3, 107,
	3, 107, 3, 108, 3, 108, 3, 109, 3, 109, 3, 109, 3, 109, 3, 109, 3, 109,
	3, 109, 5, 109, 1042, 10, 109, 3, 110, 3, 110, 3, 110, 3, 110, 3, 111,
	3, 111, 7, 111, 1050, 10, 111, 12, 111, 14, 111, 1053, 11, 111, 3, 112,
	3, 112, 3, 112, 3, 112, 3, 112, 5, 112, 1060, 10, 112, 3, 112, 5, 112,
	1063, 10, 112, 3, 112, 5, 112, 1066, 10, 112, 3, 113, 3, 113, 5, 113, 1070,
	10, 113, 3, 114, 3, 114, 3, 114, 3, 114, 3, 115, 3, 115, 3, 116, 5, 116,
	1079, 10, 116, 3, 116, 3, 116, 3, 117, 3, 117, 3, 117, 3, 117, 3, 117,
	3, 118, 3, 118, 3, 118, 3, 118, 3, 118, 3, 118, 5, 118, 1094, 10, 118,
	3, 119, 3, 119, 5, 119, 1098, 10, 119, 3, 120, 3, 120, 3, 120, 7, 120,
	1103, 10, 120, 12, 120, 14, 120, 1106, 11, 120, 3, 121, 3, 121, 5, 121,
	1110, 10, 121, 3, 122, 3, 122, 3, 122, 3, 122, 3, 122, 3, 123, 3, 123,
	3, 124, 3, 124, 3, 124, 7, 124, 1122, 10, 124, 12, 124, 14, 124, 1125,
	11, 124, 3, 125, 3, 125, 3, 125, 3, 126, 3, 126, 3, 126, 3, 126, 3, 126,
	3, 127, 3, 127, 3, 127, 3, 127, 5, 127, 1139, 10, 127, 3, 127, 3, 127,
	5, 127, 1143, 10, 127, 5, 127, 1145, 10, 127, 3, 128, 3, 128, 3, 129, 3,
	129, 3, 129, 7, 129, 1152, 10, 129, 12, 129, 14, 129, 1155, 11, 129, 3,
	130, 3, 130, 3, 130, 5, 130, 1160, 10, 130, 3, 131, 3, 131, 3, 131, 3,
	131, 5, 131, 1166, 10, 131, 3, 131, 3, 131, 3, 132, 3, 132, 3, 133, 3,
	133, 5, 133, 1174, 10, 133, 3, 134, 3, 134, 3, 134, 5, 134, 1179, 10, 134,
	3, 135, 3, 135, 3, 135, 3, 135, 7, 135, 1185, 10, 135, 12, 135, 14, 135,
	1188, 11, 135, 3, 135, 3, 135, 3, 136, 3, 136, 5, 136, 1194, 10, 136, 3,
	137, 3, 137, 3, 137, 3, 138, 3, 138, 3, 138, 3, 138, 3, 138, 3, 138, 5,
	138, 1205, 10, 138, 3, 139, 3, 139, 3, 140, 3, 140, 3, 140, 3, 140, 3,
	140, 5, 140, 1214, 10, 140, 3, 141, 3, 141, 3, 141, 7, 141, 1219, 10, 141,
	12, 141, 14, 141, 1222, 11, 141, 3, 142, 3, 142, 3, 142, 3, 143, 3, 143,
	3, 143, 3, 143, 5, 143, 1231, 10, 143, 3, 143, 3, 143, 3, 143, 3, 143,
	3, 143, 7, 143, 1238, 10, 143, 12, 143, 14, 143, 1241, 11, 143, 3, 143,
	3, 143, 5, 143, 1245, 10, 143, 3, 144, 3, 144, 3, 144, 5, 144, 1250, 10,
	144, 3, 144, 3, 144, 3, 145, 3, 145, 5, 145, 1256, 10, 145, 3, 146, 3,
	146, 3, 146, 7, 146, 1261, 10, 146, 12, 146, 14, 146, 1264, 11, 146, 3,
	147, 3, 147, 3, 147, 3, 148, 3, 148, 3, 148, 3, 148, 3, 148, 3, 148, 3,
	148, 5, 148, 1276, 10, 148, 3, 149, 3, 149, 3, 149, 7, 149, 1281, 10, 149,
	12, 149, 14, 149, 1284, 11, 149, 3, 150, 3, 150, 3, 150, 3, 150, 5, 150,
	1290, 10, 150, 3, 150, 3, 150, 3, 151, 3, 151, 3, 151, 2, 2, 152, 2, 4,
	6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42,
	44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78,
	80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112,
	114, 116, 118, 120, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 142,
	144, 146, 148, 150, 152, 154, 156, 158, 160, 162, 164, 166, 168, 170, 172,
	174, 176, 178, 180, 182, 184, 186, 188, 190, 192, 194, 196, 198, 200, 202,
	204, 206, 208, 210, 212, 214, 216, 218, 220, 222, 224, 226, 228, 230, 232,
	234, 236, 238, 240, 242, 244, 246, 248, 250, 252, 254, 256, 258, 260, 262,
	264, 266, 268, 270, 272, 274, 276, 278, 280, 282, 284, 286, 288, 290, 292,
	294, 296, 298, 300, 2, 9, 4, 2, 75, 75, 77, 78, 3, 2, 62, 63, 4, 2, 26,
	26, 109, 109, 3, 2, 49, 50, 4, 2, 48, 48, 51, 51, 3, 2, 59, 60, 4, 2, 10,
	11, 21, 22, 2, 1338, 2, 303, 3, 2, 2, 2, 4, 307, 3, 2, 2, 2, 6, 331, 3,
	2, 2, 2, 8, 335, 3, 2, 2, 2, 10, 341, 3, 2, 2, 2, 12, 350, 3, 2, 2, 2,
	14, 353, 3, 2, 2, 2, 16, 359, 3, 2, 2, 2, 18, 362, 3, 2, 2, 2, 20, 364,
	3, 2, 2, 2, 22, 371, 3, 2, 2, 2, 24, 375, 3, 2, 2, 2, 26, 378, 3, 2, 2,
	2, 28, 380, 3, 2, 2, 2, 30, 388, 3, 2, 2, 2, 32, 393, 3, 2, 2, 2, 34, 400,
	3, 2, 2, 2, 36, 407, 3, 2, 2, 2, 38, 417, 3, 2, 2, 2, 40, 423, 3, 2, 2,
	2, 42, 455, 3, 2, 2, 2, 44, 457, 3, 2, 2, 2, 46, 459, 3, 2, 2, 2, 48, 479,
	3, 2, 2, 2, 50, 484, 3, 2, 2, 2, 52, 486, 3, 2, 2, 2, 54, 489, 3, 2, 2,
	2, 56, 494, 3, 2, 2, 2, 58, 496, 3, 2, 2, 2, 60, 506, 3, 2, 2, 2, 62, 508,
	3, 2, 2, 2, 64, 518, 3, 2, 2, 2, 66, 520, 3, 2, 2, 2, 68, 535, 3, 2, 2,
	2, 70, 552, 3, 2, 2, 2, 72, 554, 3, 2, 2, 2, 74, 568, 3, 2, 2, 2, 76, 574,
	3, 2, 2, 2, 78, 578, 3, 2, 2, 2, 80, 580, 3, 2, 2, 2, 82, 585, 3, 2, 2,
	2, 84, 594, 3, 2, 2, 2, 86, 596, 3, 2, 2, 2, 88, 598, 3, 2, 2, 2, 90, 602,
	3, 2, 2, 2, 92, 616, 3, 2, 2, 2, 94, 620, 3, 2, 2, 2, 96, 630, 3, 2, 2,
	2, 98, 632, 3, 2, 2, 2, 100, 642, 3, 2, 2, 2, 102, 644, 3, 2, 2, 2, 104,
	646, 3, 2, 2, 2, 106, 649, 3, 2, 2, 2, 108, 686, 3, 2, 2, 2, 110, 694,
	3, 2, 2, 2, 112, 696, 3, 2, 2, 2, 114, 708, 3, 2, 2, 2, 116, 710, 3, 2,
	2, 2, 118, 716, 3, 2, 2, 2, 120, 725, 3, 2, 2, 2, 122, 729, 3, 2, 2, 2,
	124, 731, 3, 2, 2, 2, 126, 734, 3, 2, 2, 2, 128, 738, 3, 2, 2, 2, 130,
	756, 3, 2, 2, 2, 132, 758, 3, 2, 2, 2, 134, 769, 3, 2, 2, 2, 136, 773,
	3, 2, 2, 2, 138, 782, 3, 2, 2, 2, 140, 784, 3, 2, 2, 2, 142, 789, 3, 2,
	2, 2, 144, 791, 3, 2, 2, 2, 146, 800, 3, 2, 2, 2, 148, 803, 3, 2, 2, 2,
	150, 812, 3, 2, 2, 2, 152, 814, 3, 2, 2, 2, 154, 816, 3, 2, 2, 2, 156,
	820, 3, 2, 2, 2, 158, 822, 3, 2, 2, 2, 160, 845, 3, 2, 2, 2, 162, 847,
	3, 2, 2, 2, 164, 853, 3, 2, 2, 2, 166, 862, 3, 2, 2, 2, 168, 864, 3, 2,
	2, 2, 170, 873, 3, 2, 2, 2, 172, 875, 3, 2, 2, 2, 174, 878, 3, 2, 2, 2,
	176, 884, 3, 2, 2, 2, 178, 905, 3, 2, 2, 2, 180, 907, 3, 2, 2, 2, 182,
	911, 3, 2, 2, 2, 184, 921, 3, 2, 2, 2, 186, 931, 3, 2, 2, 2, 188, 933,
	3, 2, 2, 2, 190, 941, 3, 2, 2, 2, 192, 950, 3, 2, 2, 2, 194, 952, 3, 2,
	2, 2, 196, 968, 3, 2, 2, 2, 198, 970, 3, 2, 2, 2, 200, 978, 3, 2, 2, 2,
	202, 980, 3, 2, 2, 2, 204, 999, 3, 2, 2, 2, 206, 1017, 3, 2, 2, 2, 208,
	1019, 3, 2, 2, 2, 210, 1027, 3, 2, 2, 2, 212, 1030, 3, 2, 2, 2, 214, 1032,
	3, 2, 2, 2, 216, 1041, 3, 2, 2, 2, 218, 1043, 3, 2, 2, 2, 220, 1047, 3,
	2, 2, 2, 222, 1065, 3, 2, 2, 2, 224, 1069, 3, 2, 2, 2, 226, 1071, 3, 2,
	2, 2, 228, 1075, 3, 2, 2, 2, 230, 1078, 3, 2, 2, 2, 232, 1082, 3, 2, 2,
	2, 234, 1087, 3, 2, 2, 2, 236, 1097, 3, 2, 2, 2, 238, 1099, 3, 2, 2, 2,
	240, 1109, 3, 2, 2, 2, 242, 1111, 3, 2, 2, 2, 244, 1116, 3, 2, 2, 2, 246,
	1118, 3, 2, 2, 2, 248, 1126, 3, 2, 2, 2, 250, 1129, 3, 2, 2, 2, 252, 1134,
	3, 2, 2, 2, 254, 1146, 3, 2, 2, 2, 256, 1148, 3, 2, 2, 2, 258, 1159, 3,
	2, 2, 2, 260, 1161, 3, 2, 2, 2, 262, 1169, 3, 2, 2, 2, 264, 1171, 3, 2,
	2, 2, 266, 1175, 3, 2, 2, 2, 268, 1180, 3, 2, 2, 2, 270, 1193, 3, 2, 2,
	2, 272, 1195, 3, 2, 2, 2, 274, 1204, 3, 2, 2, 2, 276, 1206, 3, 2, 2, 2,
	278, 1208, 3, 2, 2, 2, 280, 1215, 3, 2, 2, 2, 282, 1223, 3, 2, 2, 2, 284,
	1226, 3, 2, 2, 2, 286, 1249, 3, 2, 2, 2, 288, 1255, 3, 2, 2, 2, 290, 1257,
	3, 2, 2, 2, 292, 1265, 3, 2, 2, 2, 294, 1268, 3, 2, 2, 2, 296, 1277, 3,
	2, 2, 2, 298, 1285, 3, 2, 2, 2, 300, 1293, 3, 2, 2, 2, 302, 304, 5, 4,
	3, 2, 303, 302, 3, 2, 2, 2, 304, 305, 3, 2, 2, 2, 305, 303, 3, 2, 2, 2,
	305, 306, 3, 2, 2, 2, 306, 3, 3, 2, 2, 2, 307, 319, 7, 109, 2, 2, 308,
	315, 7, 24, 2, 2, 309, 310, 7, 109, 2, 2, 310, 311, 7, 27, 2, 2, 311, 312,
	7, 103, 2, 2, 312, 314, 7, 28, 2, 2, 313, 309, 3, 2, 2, 2, 314, 317, 3,
	2, 2, 2, 315, 313, 3, 2, 2, 2, 315, 316, 3, 2, 2, 2, 316, 318, 3, 2, 2,
	2, 317, 315, 3, 2, 2, 2, 318, 320, 7, 25, 2, 2, 319, 308, 3, 2, 2, 2, 319,
	320, 3, 2, 2, 2, 320, 321, 3, 2, 2, 2, 321, 322, 7, 79, 2, 2, 322, 323,
	5, 6, 4, 2, 323, 324, 5, 8, 5, 2, 324, 325, 7, 8, 2, 2, 325, 326, 7, 80,
	2, 2, 326, 327, 5, 10, 6, 2, 327, 328, 7, 81, 2, 2, 328, 5, 3, 2, 2, 2,
	329, 330, 9, 2, 2, 2, 330, 332, 7, 76, 2, 2, 331, 329, 3, 2, 2, 2, 331,
	332, 3, 2, 2, 2, 332, 7, 3, 2, 2, 2, 333, 334, 7, 73, 2, 2, 334, 336, 7,
	74, 2, 2, 335, 333, 3, 2, 2, 2, 335, 336, 3, 2, 2, 2, 336, 9, 3, 2, 2,
	2, 337, 338, 5, 12, 7, 2, 338, 339, 5, 16, 9, 2, 339, 340, 5, 32, 17, 2,
	340, 342, 3, 2, 2, 2, 341, 337, 3, 2, 2, 2, 341, 342, 3, 2, 2, 2, 342,
	11, 3, 2, 2, 2, 343, 344, 7, 72, 2, 2, 344, 345, 5, 14, 8, 2, 345, 346,
	7, 70, 2, 2, 346, 351, 3, 2, 2, 2, 347, 348, 7, 72, 2, 2, 348, 349, 7,
	46, 2, 2, 349, 351, 7, 70, 2, 2, 350, 343, 3, 2, 2, 2, 350, 347, 3, 2,
	2, 2, 350, 351, 3, 2, 2, 2, 351, 13, 3, 2, 2, 2, 352, 354, 5, 28, 15, 2,
	353, 352, 3, 2, 2, 2, 353, 354, 3, 2, 2, 2, 354, 15, 3, 2, 2, 2, 355, 356,
	7, 71, 2, 2, 356, 357, 5, 18, 10, 2, 357, 358, 7, 70, 2, 2, 358, 360, 3,
	2, 2, 2, 359, 355, 3, 2, 2, 2, 359, 360, 3, 2, 2, 2, 360, 17, 3, 2, 2,
	2, 361, 363, 5, 20, 11, 2, 362, 361, 3, 2, 2, 2, 362, 363, 3, 2, 2, 2,
	363, 19, 3, 2, 2, 2, 364, 368, 5, 22, 12, 2, 365, 367, 5, 22, 12, 2, 366,
	365, 3, 2, 2, 2, 367, 370, 3, 2, 2, 2, 368, 366, 3, 2, 2, 2, 368, 369,
	3, 2, 2, 2, 369, 21, 3, 2, 2, 2, 370, 368, 3, 2, 2, 2, 371, 372, 5, 28,
	15, 2, 372, 373, 7, 56, 2, 2, 373, 374, 5, 24, 13, 2, 374, 23, 3, 2, 2,
	2, 375, 376, 7, 109, 2, 2, 376, 377, 5, 26, 14, 2, 377, 25, 3, 2, 2, 2,
	378, 379, 3, 2, 2, 2, 379, 27, 3, 2, 2, 2, 380, 385, 5, 30, 16, 2, 381,
	382, 7, 26, 2, 2, 382, 384, 5, 30, 16, 2, 383, 381, 3, 2, 2, 2, 384, 387,
	3, 2, 2, 2, 385, 383, 3, 2, 2, 2, 385, 386, 3, 2, 2, 2, 386, 29, 3, 2,
	2, 2, 387, 385, 3, 2, 2, 2, 388, 391, 7, 109, 2, 2, 389, 390, 7, 24, 2,
	2, 390, 392, 7, 25, 2, 2, 391, 389, 3, 2, 2, 2, 391, 392, 3, 2, 2, 2, 392,
	31, 3, 2, 2, 2, 393, 397, 5, 34, 18, 2, 394, 396, 5, 34, 18, 2, 395, 394,
	3, 2, 2, 2, 396, 399, 3, 2, 2, 2, 397, 395, 3, 2, 2, 2, 397, 398, 3, 2,
	2, 2, 398, 33, 3, 2, 2, 2, 399, 397, 3, 2, 2, 2, 400, 405, 7, 109, 2, 2,
	401, 406, 5, 174, 88, 2, 402, 406, 5, 172, 87, 2, 403, 406, 5, 70, 36,
	2, 404, 406, 5, 80, 41, 2, 405, 401, 3, 2, 2, 2, 405, 402, 3, 2, 2, 2,
	405, 403, 3, 2, 2, 2, 405, 404, 3, 2, 2, 2, 406, 35, 3, 2, 2, 2, 407, 408,
	7, 39, 2, 2, 408, 413, 7, 24, 2, 2, 409, 410, 5, 38, 20, 2, 410, 411, 5,
	40, 21, 2, 411, 414, 3, 2, 2, 2, 412, 414, 5, 42, 22, 2, 413, 409, 3, 2,
	2, 2, 413, 412, 3, 2, 2, 2, 413, 414, 3, 2, 2, 2, 414, 415, 3, 2, 2, 2,
	415, 416, 7, 25, 2, 2, 416, 37, 3, 2, 2, 2, 417, 419, 7, 14, 2, 2, 418,
	420, 5, 272, 137, 2, 419, 418, 3, 2, 2, 2, 419, 420, 3, 2, 2, 2, 420, 39,
	3, 2, 2, 2, 421, 422, 7, 26, 2, 2, 422, 424, 7, 14, 2, 2, 423, 421, 3,
	2, 2, 2, 423, 424, 3, 2, 2, 2, 424, 41, 3, 2, 2, 2, 425, 442, 5, 44, 23,
	2, 426, 443, 5, 50, 26, 2, 427, 429, 7, 26, 2, 2, 428, 430, 5, 50, 26,
	2, 429, 428, 3, 2, 2, 2, 429, 430, 3, 2, 2, 2, 430, 431, 3, 2, 2, 2, 431,
	432, 5, 38, 20, 2, 432, 440, 5, 56, 29, 2, 433, 441, 5, 40, 21, 2, 434,
	435, 7, 102, 2, 2, 435, 436, 7, 26, 2, 2, 436, 438, 5, 44, 23, 2, 437,
	439, 5, 50, 26, 2, 438, 437, 3, 2, 2, 2, 438, 439, 3, 2, 2, 2, 439, 441,
	3, 2, 2, 2, 440, 433, 3, 2, 2, 2, 440, 434, 3, 2, 2, 2, 441, 443, 3, 2,
	2, 2, 442, 426, 3, 2, 2, 2, 442, 427, 3, 2, 2, 2, 442, 443, 3, 2, 2, 2,
	443, 456, 3, 2, 2, 2, 444, 445, 5, 38, 20, 2, 445, 453, 5, 56, 29, 2, 446,
	454, 5, 40, 21, 2, 447, 448, 7, 102, 2, 2, 448, 449, 7, 26, 2, 2, 449,
	451, 5, 44, 23, 2, 450, 452, 5, 50, 26, 2, 451, 450, 3, 2, 2, 2, 451, 452,
	3, 2, 2, 2, 452, 454, 3, 2, 2, 2, 453, 446, 3, 2, 2, 2, 453, 447, 3, 2,
	2, 2, 454, 456, 3, 2, 2, 2, 455, 425, 3, 2, 2, 2, 455, 444, 3, 2, 2, 2,
	456, 43, 3, 2, 2, 2, 457, 458, 5, 46, 24, 2, 458, 45, 3, 2, 2, 2, 459,
	467, 5, 48, 25, 2, 460, 462, 7, 26, 2, 2, 461, 463, 5, 50, 26, 2, 462,
	461, 3, 2, 2, 2, 462, 463, 3, 2, 2, 2, 463, 464, 3, 2, 2, 2, 464, 466,
	5, 48, 25, 2, 465, 460, 3, 2, 2, 2, 466, 469, 3, 2, 2, 2, 467, 465, 3,
	2, 2, 2, 467, 468, 3, 2, 2, 2, 468, 47, 3, 2, 2, 2, 469, 467, 3, 2, 2,
	2, 470, 474, 5, 248, 125, 2, 471, 475, 7, 40, 2, 2, 472, 473, 7, 41, 2,
	2, 473, 475, 5, 214, 108, 2, 474, 471, 3, 2, 2, 2, 474, 472, 3, 2, 2, 2,
	474, 475, 3, 2, 2, 2, 475, 480, 3, 2, 2, 2, 476, 477, 7, 42, 2, 2, 477,
	478, 7, 43, 2, 2, 478, 480, 5, 176, 89, 2, 479, 470, 3, 2, 2, 2, 479, 476,
	3, 2, 2, 2, 480, 49, 3, 2, 2, 2, 481, 485, 5, 52, 27, 2, 482, 485, 5, 54,
	28, 2, 483, 485, 7, 5, 2, 2, 484, 481, 3, 2, 2, 2, 484, 482, 3, 2, 2, 2,
	484, 483, 3, 2, 2, 2, 485, 51, 3, 2, 2, 2, 486, 487, 7, 3, 2, 2, 487, 488,
	7, 109, 2, 2, 488, 53, 3, 2, 2, 2, 489, 490, 7, 4, 2, 2, 490, 491, 7, 109,
	2, 2, 491, 55, 3, 2, 2, 2, 492, 493, 7, 26, 2, 2, 493, 495, 5, 58, 30,
	2, 494, 492, 3, 2, 2, 2, 494, 495, 3, 2, 2, 2, 495, 57, 3, 2, 2, 2, 496,
	501, 5, 60, 31, 2, 497, 498, 7, 26, 2, 2, 498, 500, 5, 60, 31, 2, 499,
	497, 3, 2, 2, 2, 500, 503, 3, 2, 2, 2, 501, 499, 3, 2, 2, 2, 501, 502,
	3, 2, 2, 2, 502, 59, 3, 2, 2, 2, 503, 501, 3, 2, 2, 2, 504, 507, 5, 48,
	25, 2, 505, 507, 5, 62, 32, 2, 506, 504, 3, 2, 2, 2, 506, 505, 3, 2, 2,
	2, 507, 61, 3, 2, 2, 2, 508, 509, 7, 82, 2, 2, 509, 510, 5, 64, 33, 2,
	510, 512, 5, 46, 24, 2, 511, 513, 5, 50, 26, 2, 512, 511, 3, 2, 2, 2, 512,
	513, 3, 2, 2, 2, 513, 514, 3, 2, 2, 2, 514, 515, 7, 83, 2, 2, 515, 63,
	3, 2, 2, 2, 516, 517, 7, 103, 2, 2, 517, 519, 7, 84, 2, 2, 518, 516, 3,
	2, 2, 2, 518, 519, 3, 2, 2, 2, 519, 65, 3, 2, 2, 2, 520, 528, 7, 39, 2,
	2, 521, 524, 7, 27, 2, 2, 522, 525, 5, 190, 96, 2, 523, 525, 5, 68, 35,
	2, 524, 522, 3, 2, 2, 2, 524, 523, 3, 2, 2, 2, 525, 526, 3, 2, 2, 2, 526,
	527, 7, 28, 2, 2, 527, 529, 3, 2, 2, 2, 528, 521, 3, 2, 2, 2, 528, 529,
	3, 2, 2, 2, 529, 530, 3, 2, 2, 2, 530, 533, 7, 43, 2, 2, 531, 534, 5, 176,
	89, 2, 532, 534, 5, 248, 125, 2, 533, 531, 3, 2, 2, 2, 533, 532, 3, 2,
	2, 2, 534, 67, 3, 2, 2, 2, 535, 536, 7, 55, 2, 2, 536, 537, 5, 190, 96,
	2, 537, 69, 3, 2, 2, 2, 538, 539, 5, 72, 37, 2, 539, 543, 7, 8, 2, 2, 540,
	544, 5, 176, 89, 2, 541, 544, 5, 214, 108, 2, 542, 544, 5, 134, 68, 2,
	543, 540, 3, 2, 2, 2, 543, 541, 3, 2, 2, 2, 543, 542, 3, 2, 2, 2, 544,
	553, 3, 2, 2, 2, 545, 546, 5, 84, 43, 2, 546, 550, 7, 8, 2, 2, 547, 551,
	5, 122, 62, 2, 548, 551, 5, 82, 42, 2, 549, 551, 5, 128, 65, 2, 550, 547,
	3, 2, 2, 2, 550, 548, 3, 2, 2, 2, 550, 549, 3, 2, 2, 2, 551, 553, 3, 2,
	2, 2, 552, 538, 3, 2, 2, 2, 552, 545, 3, 2, 2, 2, 553, 71, 3, 2, 2, 2,
	554, 555, 7, 24, 2, 2, 555, 560, 5, 74, 38, 2, 556, 557, 7, 26, 2, 2, 557,
	559, 5, 74, 38, 2, 558, 556, 3, 2, 2, 2, 559, 562, 3, 2, 2, 2, 560, 558,
	3, 2, 2, 2, 560, 561, 3, 2, 2, 2, 561, 563, 3, 2, 2, 2, 562, 560, 3, 2,
	2, 2, 563, 564, 7, 25, 2, 2, 564, 73, 3, 2, 2, 2, 565, 566, 5, 76, 39,
	2, 566, 567, 7, 84, 2, 2, 567, 569, 3, 2, 2, 2, 568, 565, 3, 2, 2, 2, 568,
	569, 3, 2, 2, 2, 569, 570, 3, 2, 2, 2, 570, 571, 7, 109, 2, 2, 571, 75,
	3, 2, 2, 2, 572, 575, 5, 78, 40, 2, 573, 575, 7, 109, 2, 2, 574, 572, 3,
	2, 2, 2, 574, 573, 3, 2, 2, 2, 575, 77, 3, 2, 2, 2, 576, 579, 5, 176, 89,
	2, 577, 579, 5, 84, 43, 2, 578, 576, 3, 2, 2, 2, 578, 577, 3, 2, 2, 2,
	579, 79, 3, 2, 2, 2, 580, 581, 7, 8, 2, 2, 581, 582, 5, 82, 42, 2, 582,
	81, 3, 2, 2, 2, 583, 586, 5, 84, 43, 2, 584, 586, 5, 90, 46, 2, 585, 583,
	3, 2, 2, 2, 585, 584, 3, 2, 2, 2, 586, 83, 3, 2, 2, 2, 587, 588, 7, 109,
	2, 2, 588, 590, 7, 12, 2, 2, 589, 587, 3, 2, 2, 2, 589, 590, 3, 2, 2, 2,
	590, 591, 3, 2, 2, 2, 591, 595, 7, 109, 2, 2, 592, 595, 7, 62, 2, 2, 593,
	595, 7, 63, 2, 2, 594, 589, 3, 2, 2, 2, 594, 592, 3, 2, 2, 2, 594, 593,
	3, 2, 2, 2, 595, 85, 3, 2, 2, 2, 596, 597, 9, 3, 2, 2, 597, 87, 3, 2, 2,
	2, 598, 599, 7, 109, 2, 2, 599, 600, 7, 12, 2, 2, 600, 601, 7, 109, 2,
	2, 601, 89, 3, 2, 2, 2, 602, 603, 7, 64, 2, 2, 603, 604, 7, 24, 2, 2, 604,
	609, 5, 106, 54, 2, 605, 606, 7, 26, 2, 2, 606, 608, 5, 106, 54, 2, 607,
	605, 3, 2, 2, 2, 608, 611, 3, 2, 2, 2, 609, 607, 3, 2, 2, 2, 609, 610,
	3, 2, 2, 2, 610, 612, 3, 2, 2, 2, 611, 609, 3, 2, 2, 2, 612, 614, 7, 25,
	2, 2, 613, 615, 5, 92, 47, 2, 614, 613, 3, 2, 2, 2, 614, 615, 3, 2, 2,
	2, 615, 91, 3, 2, 2, 2, 616, 617, 7, 57, 2, 2, 617, 618, 7, 66, 2, 2, 618,
	619, 5, 94, 48, 2, 619, 93, 3, 2, 2, 2, 620, 622, 7, 24, 2, 2, 621, 623,
	5, 96, 49, 2, 622, 621, 3, 2, 2, 2, 623, 624, 3, 2, 2, 2, 624, 622, 3,
	2, 2, 2, 624, 625, 3, 2, 2, 2, 625, 626, 3, 2, 2, 2, 626, 627, 7, 25, 2,
	2, 627, 95, 3, 2, 2, 2, 628, 631, 5, 100, 51, 2, 629, 631, 5, 98, 50, 2,
	630, 628, 3, 2, 2, 2, 630, 629, 3, 2, 2, 2, 631, 97, 3, 2, 2, 2, 632, 634,
	7, 67, 2, 2, 633, 635, 5, 96, 49, 2, 634, 633, 3, 2, 2, 2, 635, 636, 3,
	2, 2, 2, 636, 634, 3, 2, 2, 2, 636, 637, 3, 2, 2, 2, 637, 638, 3, 2, 2,
	2, 638, 639, 7, 68, 2, 2, 639, 99, 3, 2, 2, 2, 640, 643, 5, 102, 52, 2,
	641, 643, 5, 104, 53, 2, 642, 640, 3, 2, 2, 2, 642, 641, 3, 2, 2, 2, 643,
	101, 3, 2, 2, 2, 644, 645, 9, 4, 2, 2, 645, 103, 3, 2, 2, 2, 646, 647,
	7, 16, 2, 2, 647, 648, 7, 109, 2, 2, 648, 105, 3, 2, 2, 2, 649, 650, 7,
	16, 2, 2, 650, 684, 7, 109, 2, 2, 651, 653, 5, 110, 56, 2, 652, 651, 3,
	2, 2, 2, 652, 653, 3, 2, 2, 2, 653, 685, 3, 2, 2, 2, 654, 664, 5, 176,
	89, 2, 655, 657, 5, 120, 61, 2, 656, 655, 3, 2, 2, 2, 656, 657, 3, 2, 2,
	2, 657, 665, 3, 2, 2, 2, 658, 660, 7, 65, 2, 2, 659, 658, 3, 2, 2, 2, 659,
	660, 3, 2, 2, 2, 660, 662, 3, 2, 2, 2, 661, 663, 5, 114, 58, 2, 662, 661,
	3, 2, 2, 2, 662, 663, 3, 2, 2, 2, 663, 665, 3, 2, 2, 2, 664, 656, 3, 2,
	2, 2, 664, 659, 3, 2, 2, 2, 665, 685, 3, 2, 2, 2, 666, 673, 5, 132, 67,
	2, 667, 674, 7, 40, 2, 2, 668, 671, 7, 41, 2, 2, 669, 672, 5, 134, 68,
	2, 670, 672, 5, 214, 108, 2, 671, 669, 3, 2, 2, 2, 671, 670, 3, 2, 2, 2,
	672, 674, 3, 2, 2, 2, 673, 667, 3, 2, 2, 2, 673, 668, 3, 2, 2, 2, 673,
	674, 3, 2, 2, 2, 674, 685, 3, 2, 2, 2, 675, 682, 5, 84, 43, 2, 676, 683,
	7, 40, 2, 2, 677, 680, 7, 41, 2, 2, 678, 681, 5, 128, 65, 2, 679, 681,
	5, 122, 62, 2, 680, 678, 3, 2, 2, 2, 680, 679, 3, 2, 2, 2, 681, 683, 3,
	2, 2, 2, 682, 676, 3, 2, 2, 2, 682, 677, 3, 2, 2, 2, 682, 683, 3, 2, 2,
	2, 683, 685, 3, 2, 2, 2, 684, 652, 3, 2, 2, 2, 684, 654, 3, 2, 2, 2, 684,
	666, 3, 2, 2, 2, 684, 675, 3, 2, 2, 2, 685, 107, 3, 2, 2, 2, 686, 687,
	7, 16, 2, 2, 687, 689, 7, 109, 2, 2, 688, 690, 5, 110, 56, 2, 689, 688,
	3, 2, 2, 2, 689, 690, 3, 2, 2, 2, 690, 109, 3, 2, 2, 2, 691, 695, 7, 40,
	2, 2, 692, 693, 7, 41, 2, 2, 693, 695, 5, 176, 89, 2, 694, 691, 3, 2, 2,
	2, 694, 692, 3, 2, 2, 2, 695, 111, 3, 2, 2, 2, 696, 697, 7, 16, 2, 2, 697,
	698, 7, 109, 2, 2, 698, 700, 5, 176, 89, 2, 699, 701, 7, 65, 2, 2, 700,
	699, 3, 2, 2, 2, 700, 701, 3, 2, 2, 2, 701, 703, 3, 2, 2, 2, 702, 704,
	5, 114, 58, 2, 703, 702, 3, 2, 2, 2, 703, 704, 3, 2, 2, 2, 704, 113, 3,
	2, 2, 2, 705, 709, 7, 40, 2, 2, 706, 707, 7, 41, 2, 2, 707, 709, 5, 214,
	108, 2, 708, 705, 3, 2, 2, 2, 708, 706, 3, 2, 2, 2, 709, 115, 3, 2, 2,
	2, 710, 711, 7, 16, 2, 2, 711, 712, 7, 109, 2, 2, 712, 714, 5, 132, 67,
	2, 713, 715, 5, 114, 58, 2, 714, 713, 3, 2, 2, 2, 714, 715, 3, 2, 2, 2,
	715, 117, 3, 2, 2, 2, 716, 717, 7, 16, 2, 2, 717, 718, 7, 109, 2, 2, 718,
	720, 5, 176, 89, 2, 719, 721, 5, 120, 61, 2, 720, 719, 3, 2, 2, 2, 720,
	721, 3, 2, 2, 2, 721, 119, 3, 2, 2, 2, 722, 726, 7, 40, 2, 2, 723, 724,
	7, 41, 2, 2, 724, 726, 5, 134, 68, 2, 725, 722, 3, 2, 2, 2, 725, 723, 3,
	2, 2, 2, 726, 121, 3, 2, 2, 2, 727, 730, 5, 126, 64, 2, 728, 730, 5, 124,
	63, 2, 729, 727, 3, 2, 2, 2, 729, 728, 3, 2, 2, 2, 730, 123, 3, 2, 2, 2,
	731, 732, 5, 126, 64, 2, 732, 733, 5, 268, 135, 2, 733, 125, 3, 2, 2, 2,
	734, 736, 7, 109, 2, 2, 735, 737, 7, 12, 2, 2, 736, 735, 3, 2, 2, 2, 736,
	737, 3, 2, 2, 2, 737, 127, 3, 2, 2, 2, 738, 739, 7, 24, 2, 2, 739, 740,
	5, 130, 66, 2, 740, 741, 7, 25, 2, 2, 741, 129, 3, 2, 2, 2, 742, 749, 5,
	138, 70, 2, 743, 744, 7, 26, 2, 2, 744, 747, 7, 14, 2, 2, 745, 746, 7,
	26, 2, 2, 746, 748, 5, 140, 71, 2, 747, 745, 3, 2, 2, 2, 747, 748, 3, 2,
	2, 2, 748, 750, 3, 2, 2, 2, 749, 743, 3, 2, 2, 2, 749, 750, 3, 2, 2, 2,
	750, 757, 3, 2, 2, 2, 751, 754, 7, 14, 2, 2, 752, 753, 7, 26, 2, 2, 753,
	755, 5, 140, 71, 2, 754, 752, 3, 2, 2, 2, 754, 755, 3, 2, 2, 2, 755, 757,
	3, 2, 2, 2, 756, 742, 3, 2, 2, 2, 756, 751, 3, 2, 2, 2, 757, 131, 3, 2,
	2, 2, 758, 759, 7, 16, 2, 2, 759, 760, 7, 109, 2, 2, 760, 766, 3, 2, 2,
	2, 761, 762, 7, 16, 2, 2, 762, 763, 7, 109, 2, 2, 763, 765, 7, 12, 2, 2,
	764, 761, 3, 2, 2, 2, 765, 768, 3, 2, 2, 2, 766, 764, 3, 2, 2, 2, 766,
	767, 3, 2, 2, 2, 767, 133, 3, 2, 2, 2, 768, 766, 3, 2, 2, 2, 769, 770,
	7, 24, 2, 2, 770, 771, 5, 136, 69, 2, 771, 772, 7, 25, 2, 2, 772, 135,
	3, 2, 2, 2, 773, 780, 5, 138, 70, 2, 774, 775, 7, 26, 2, 2, 775, 778, 7,
	14, 2, 2, 776, 777, 7, 26, 2, 2, 777, 779, 5, 140, 71, 2, 778, 776, 3,
	2, 2, 2, 778, 779, 3, 2, 2, 2, 779, 781, 3, 2, 2, 2, 780, 774, 3, 2, 2,
	2, 780, 781, 3, 2, 2, 2, 781, 137, 3, 2, 2, 2, 782, 783, 5, 142, 72, 2,
	783, 139, 3, 2, 2, 2, 784, 785, 5, 142, 72, 2, 785, 141, 3, 2, 2, 2, 786,
	790, 5, 144, 73, 2, 787, 788, 7, 46, 2, 2, 788, 790, 5, 146, 74, 2, 789,
	786, 3, 2, 2, 2, 789, 787, 3, 2, 2, 2, 790, 143, 3, 2, 2, 2, 791, 797,
	5, 148, 75, 2, 792, 793, 5, 150, 76, 2, 793, 794, 5, 148, 75, 2, 794, 796,
	3, 2, 2, 2, 795, 792, 3, 2, 2, 2, 796, 799, 3, 2, 2, 2, 797, 795, 3, 2,
	2, 2, 797, 798, 3, 2, 2, 2, 798, 145, 3, 2, 2, 2, 799, 797, 3, 2, 2, 2,
	800, 801, 7, 47, 2, 2, 801, 802, 5, 154, 78, 2, 802, 147, 3, 2, 2, 2, 803,
	809, 5, 158, 80, 2, 804, 805, 5, 152, 77, 2, 805, 806, 5, 158, 80, 2, 806,
	808, 3, 2, 2, 2, 807, 804, 3, 2, 2, 2, 808, 811, 3, 2, 2, 2, 809, 807,
	3, 2, 2, 2, 809, 810, 3, 2, 2, 2, 810, 149, 3, 2, 2, 2, 811, 809, 3, 2,
	2, 2, 812, 813, 9, 5, 2, 2, 813, 151, 3, 2, 2, 2, 814, 815, 9, 6, 2, 2,
	815, 153, 3, 2, 2, 2, 816, 817, 5, 160, 81, 2, 817, 155, 3, 2, 2, 2, 818,
	821, 5, 122, 62, 2, 819, 821, 5, 126, 64, 2, 820, 818, 3, 2, 2, 2, 820,
	819, 3, 2, 2, 2, 821, 157, 3, 2, 2, 2, 822, 824, 5, 154, 78, 2, 823, 825,
	5, 146, 74, 2, 824, 823, 3, 2, 2, 2, 824, 825, 3, 2, 2, 2, 825, 159, 3,
	2, 2, 2, 826, 829, 5, 214, 108, 2, 827, 829, 7, 53, 2, 2, 828, 826, 3,
	2, 2, 2, 828, 827, 3, 2, 2, 2, 829, 831, 3, 2, 2, 2, 830, 832, 7, 17, 2,
	2, 831, 830, 3, 2, 2, 2, 831, 832, 3, 2, 2, 2, 832, 833, 3, 2, 2, 2, 833,
	835, 7, 13, 2, 2, 834, 836, 7, 17, 2, 2, 835, 834, 3, 2, 2, 2, 835, 836,
	3, 2, 2, 2, 836, 839, 3, 2, 2, 2, 837, 840, 5, 214, 108, 2, 838, 840, 7,
	54, 2, 2, 839, 837, 3, 2, 2, 2, 839, 838, 3, 2, 2, 2, 840, 846, 3, 2, 2,
	2, 841, 846, 5, 68, 35, 2, 842, 843, 7, 61, 2, 2, 843, 846, 5, 214, 108,
	2, 844, 846, 5, 214, 108, 2, 845, 828, 3, 2, 2, 2, 845, 841, 3, 2, 2, 2,
	845, 842, 3, 2, 2, 2, 845, 844, 3, 2, 2, 2, 846, 161, 3, 2, 2, 2, 847,
	848, 7, 16, 2, 2, 848, 849, 7, 109, 2, 2, 849, 851, 5, 132, 67, 2, 850,
	852, 5, 120, 61, 2, 851, 850, 3, 2, 2, 2, 851, 852, 3, 2, 2, 2, 852, 163,
	3, 2, 2, 2, 853, 854, 7, 16, 2, 2, 854, 855, 7, 109, 2, 2, 855, 857, 5,
	84, 43, 2, 856, 858, 5, 166, 84, 2, 857, 856, 3, 2, 2, 2, 857, 858, 3,
	2, 2, 2, 858, 165, 3, 2, 2, 2, 859, 863, 7, 40, 2, 2, 860, 861, 7, 41,
	2, 2, 861, 863, 5, 122, 62, 2, 862, 859, 3, 2, 2, 2, 862, 860, 3, 2, 2,
	2, 863, 167, 3, 2, 2, 2, 864, 865, 7, 16, 2, 2, 865, 866, 7, 109, 2, 2,
	866, 868, 5, 84, 43, 2, 867, 869, 5, 170, 86, 2, 868, 867, 3, 2, 2, 2,
	868, 869, 3, 2, 2, 2, 869, 169, 3, 2, 2, 2, 870, 874, 7, 40, 2, 2, 871,
	872, 7, 41, 2, 2, 872, 874, 5, 128, 65, 2, 873, 870, 3, 2, 2, 2, 873, 871,
	3, 2, 2, 2, 874, 171, 3, 2, 2, 2, 875, 876, 7, 8, 2, 2, 876, 877, 5, 176,
	89, 2, 877, 173, 3, 2, 2, 2, 878, 879, 5, 176, 89, 2, 879, 880, 7, 8, 2,
	2, 880, 881, 5, 214, 108, 2, 881, 175, 3, 2, 2, 2, 882, 885, 5, 178, 90,
	2, 883, 885, 5, 186, 94, 2, 884, 882, 3, 2, 2, 2, 884, 883, 3, 2, 2, 2,
	885, 889, 3, 2, 2, 2, 886, 888, 5, 190, 96, 2, 887, 886, 3, 2, 2, 2, 888,
	891, 3, 2, 2, 2, 889, 887, 3, 2, 2, 2, 889, 890, 3, 2, 2, 2, 890, 177,
	3, 2, 2, 2, 891, 889, 3, 2, 2, 2, 892, 906, 5, 292, 147, 2, 893, 906, 5,
	294, 148, 2, 894, 906, 5, 232, 117, 2, 895, 906, 5, 250, 126, 2, 896, 906,
	5, 278, 140, 2, 897, 906, 5, 36, 19, 2, 898, 906, 5, 66, 34, 2, 899, 906,
	5, 182, 92, 2, 900, 906, 5, 184, 93, 2, 901, 906, 5, 282, 142, 2, 902,
	906, 5, 180, 91, 2, 903, 906, 7, 9, 2, 2, 904, 906, 7, 38, 2, 2, 905, 892,
	3, 2, 2, 2, 905, 893, 3, 2, 2, 2, 905, 894, 3, 2, 2, 2, 905, 895, 3, 2,
	2, 2, 905, 896, 3, 2, 2, 2, 905, 897, 3, 2, 2, 2, 905, 898, 3, 2, 2, 2,
	905, 899, 3, 2, 2, 2, 905, 900, 3, 2, 2, 2, 905, 901, 3, 2, 2, 2, 905,
	902, 3, 2, 2, 2, 905, 903, 3, 2, 2, 2, 905, 904, 3, 2, 2, 2, 906, 179,
	3, 2, 2, 2, 907, 908, 5, 84, 43, 2, 908, 909, 7, 12, 2, 2, 909, 910, 5,
	132, 67, 2, 910, 181, 3, 2, 2, 2, 911, 912, 7, 44, 2, 2, 912, 917, 7, 24,
	2, 2, 913, 914, 5, 38, 20, 2, 914, 915, 5, 40, 21, 2, 915, 918, 3, 2, 2,
	2, 916, 918, 5, 42, 22, 2, 917, 913, 3, 2, 2, 2, 917, 916, 3, 2, 2, 2,
	917, 918, 3, 2, 2, 2, 918, 919, 3, 2, 2, 2, 919, 920, 7, 25, 2, 2, 920,
	183, 3, 2, 2, 2, 921, 924, 7, 44, 2, 2, 922, 925, 5, 190, 96, 2, 923, 925,
	5, 68, 35, 2, 924, 922, 3, 2, 2, 2, 924, 923, 3, 2, 2, 2, 924, 925, 3,
	2, 2, 2, 925, 926, 3, 2, 2, 2, 926, 929, 7, 43, 2, 2, 927, 930, 5, 176,
	89, 2, 928, 930, 5, 248, 125, 2, 929, 927, 3, 2, 2, 2, 929, 928, 3, 2,
	2, 2, 930, 185, 3, 2, 2, 2, 931, 932, 5, 188, 95, 2, 932, 187, 3, 2, 2,
	2, 933, 936, 7, 109, 2, 2, 934, 935, 7, 12, 2, 2, 935, 937, 7, 109, 2,
	2, 936, 934, 3, 2, 2, 2, 936, 937, 3, 2, 2, 2, 937, 939, 3, 2, 2, 2, 938,
	940, 5, 268, 135, 2, 939, 938, 3, 2, 2, 2, 939, 940, 3, 2, 2, 2, 940, 189,
	3, 2, 2, 2, 941, 942, 7, 27, 2, 2, 942, 944, 5, 192, 97, 2, 943, 945, 5,
	272, 137, 2, 944, 943, 3, 2, 2, 2, 944, 945, 3, 2, 2, 2, 945, 946, 3, 2,
	2, 2, 946, 947, 7, 28, 2, 2, 947, 191, 3, 2, 2, 2, 948, 951, 5, 196, 99,
	2, 949, 951, 5, 212, 107, 2, 950, 948, 3, 2, 2, 2, 950, 949, 3, 2, 2, 2,
	951, 193, 3, 2, 2, 2, 952, 953, 7, 96, 2, 2, 953, 954, 7, 97, 2, 2, 954,
	955, 7, 24, 2, 2, 955, 960, 5, 198, 100, 2, 956, 957, 7, 26, 2, 2, 957,
	959, 5, 198, 100, 2, 958, 956, 3, 2, 2, 2, 959, 962, 3, 2, 2, 2, 960, 958,
	3, 2, 2, 2, 960, 961, 3, 2, 2, 2, 961, 963, 3, 2, 2, 2, 962, 960, 3, 2,
	2, 2, 963, 964, 7, 25, 2, 2, 964, 195, 3, 2, 2, 2, 965, 969, 5, 194, 98,
	2, 966, 969, 5, 200, 101, 2, 967, 969, 5, 204, 103, 2, 968, 965, 3, 2,
	2, 2, 968, 966, 3, 2, 2, 2, 968, 967, 3, 2, 2, 2, 969, 197, 3, 2, 2, 2,
	970, 976, 5, 78, 40, 2, 971, 972, 7, 84, 2, 2, 972, 977, 5, 214, 108, 2,
	973, 977, 5, 134, 68, 2, 974, 977, 5, 122, 62, 2, 975, 977, 5, 128, 65,
	2, 976, 971, 3, 2, 2, 2, 976, 973, 3, 2, 2, 2, 976, 974, 3, 2, 2, 2, 976,
	975, 3, 2, 2, 2, 976, 977, 3, 2, 2, 2, 977, 199, 3, 2, 2, 2, 978, 979,
	5, 284, 143, 2, 979, 201, 3, 2, 2, 2, 980, 981, 5, 128, 65, 2, 981, 203,
	3, 2, 2, 2, 982, 983, 7, 36, 2, 2, 983, 1000, 5, 176, 89, 2, 984, 985,
	7, 99, 2, 2, 985, 986, 7, 97, 2, 2, 986, 1000, 5, 214, 108, 2, 987, 988,
	7, 36, 2, 2, 988, 989, 5, 176, 89, 2, 989, 990, 7, 99, 2, 2, 990, 991,
	7, 97, 2, 2, 991, 992, 5, 214, 108, 2, 992, 1000, 3, 2, 2, 2, 993, 994,
	7, 57, 2, 2, 994, 995, 7, 42, 2, 2, 995, 996, 7, 24, 2, 2, 996, 997, 5,
	206, 104, 2, 997, 998, 7, 25, 2, 2, 998, 1000, 3, 2, 2, 2, 999, 982, 3,
	2, 2, 2, 999, 984, 3, 2, 2, 2, 999, 987, 3, 2, 2, 2, 999, 993, 3, 2, 2,
	2, 1000, 205, 3, 2, 2, 2, 1001, 1003, 5, 208, 105, 2, 1002, 1001, 3, 2,
	2, 2, 1002, 1003, 3, 2, 2, 2, 1003, 1010, 3, 2, 2, 2, 1004, 1005, 7, 26,
	2, 2, 1005, 1008, 7, 14, 2, 2, 1006, 1007, 7, 26, 2, 2, 1007, 1009, 5,
	208, 105, 2, 1008, 1006, 3, 2, 2, 2, 1008, 1009, 3, 2, 2, 2, 1009, 1011,
	3, 2, 2, 2, 1010, 1004, 3, 2, 2, 2, 1010, 1011, 3, 2, 2, 2, 1011, 1018,
	3, 2, 2, 2, 1012, 1015, 7, 14, 2, 2, 1013, 1014, 7, 26, 2, 2, 1014, 1016,
	5, 208, 105, 2, 1015, 1013, 3, 2, 2, 2, 1015, 1016, 3, 2, 2, 2, 1016, 1018,
	3, 2, 2, 2, 1017, 1002, 3, 2, 2, 2, 1017, 1012, 3, 2, 2, 2, 1018, 207,
	3, 2, 2, 2, 1019, 1024, 5, 210, 106, 2, 1020, 1021, 7, 26, 2, 2, 1021,
	1023, 5, 210, 106, 2, 1022, 1020, 3, 2, 2, 2, 1023, 1026, 3, 2, 2, 2, 1024,
	1022, 3, 2, 2, 2, 1024, 1025, 3, 2, 2, 2, 1025, 209, 3, 2, 2, 2, 1026,
	1024, 3, 2, 2, 2, 1027, 1028, 7, 109, 2, 2, 1028, 1029, 9, 7, 2, 2, 1029,
	211, 3, 2, 2, 2, 1030, 1031, 5, 136, 69, 2, 1031, 213, 3, 2, 2, 2, 1032,
	1033, 5, 216, 109, 2, 1033, 215, 3, 2, 2, 2, 1034, 1042, 5, 228, 115, 2,
	1035, 1042, 5, 224, 113, 2, 1036, 1042, 5, 226, 114, 2, 1037, 1042, 5,
	218, 110, 2, 1038, 1042, 5, 300, 151, 2, 1039, 1042, 7, 108, 2, 2, 1040,
	1042, 7, 106, 2, 2, 1041, 1034, 3, 2, 2, 2, 1041, 1035, 3, 2, 2, 2, 1041,
	1036, 3, 2, 2, 2, 1041, 1037, 3, 2, 2, 2, 1041, 1038, 3, 2, 2, 2, 1041,
	1039, 3, 2, 2, 2, 1041, 1040, 3, 2, 2, 2, 1042, 217, 3, 2, 2, 2, 1043,
	1044, 7, 24, 2, 2, 1044, 1045, 5, 220, 111, 2, 1045, 1046, 7, 25, 2, 2,
	1046, 219, 3, 2, 2, 2, 1047, 1051, 5, 222, 112, 2, 1048, 1050, 5, 222,
	112, 2, 1049, 1048, 3, 2, 2, 2, 1050, 1053, 3, 2, 2, 2, 1051, 1049, 3,
	2, 2, 2, 1051, 1052, 3, 2, 2, 2, 1052, 221, 3, 2, 2, 2, 1053, 1051, 3,
	2, 2, 2, 1054, 1066, 7, 103, 2, 2, 1055, 1062, 7, 109, 2, 2, 1056, 1059,
	7, 27, 2, 2, 1057, 1060, 7, 103, 2, 2, 1058, 1060, 5, 262, 132, 2, 1059,
	1057, 3, 2, 2, 2, 1059, 1058, 3, 2, 2, 2, 1060, 1061, 3, 2, 2, 2, 1061,
	1063, 7, 28, 2, 2, 1062, 1056, 3, 2, 2, 2, 1062, 1063, 3, 2, 2, 2, 1063,
	1066, 3, 2, 2, 2, 1064, 1066, 5, 262, 132, 2, 1065, 1054, 3, 2, 2, 2, 1065,
	1055, 3, 2, 2, 2, 1065, 1064, 3, 2, 2, 2, 1066, 223, 3, 2, 2, 2, 1067,
	1070, 5, 230, 116, 2, 1068, 1070, 7, 109, 2, 2, 1069, 1067, 3, 2, 2, 2,
	1069, 1068, 3, 2, 2, 2, 1070, 225, 3, 2, 2, 2, 1071, 1072, 7, 109, 2, 2,
	1072, 1073, 7, 84, 2, 2, 1073, 1074, 5, 214, 108, 2, 1074, 227, 3, 2, 2,
	2, 1075, 1076, 7, 109, 2, 2, 1076, 229, 3, 2, 2, 2, 1077, 1079, 7, 29,
	2, 2, 1078, 1077, 3, 2, 2, 2, 1078, 1079, 3, 2, 2, 2, 1079, 1080, 3, 2,
	2, 2, 1080, 1081, 7, 103, 2, 2, 1081, 231, 3, 2, 2, 2, 1082, 1083, 7, 85,
	2, 2, 1083, 1084, 7, 24, 2, 2, 1084, 1085, 5, 234, 118, 2, 1085, 1086,
	7, 25, 2, 2, 1086, 233, 3, 2, 2, 2, 1087, 1093, 5, 244, 123, 2, 1088, 1089,
	7, 26, 2, 2, 1089, 1090, 5, 38, 20, 2, 1090, 1091, 5, 236, 119, 2, 1091,
	1092, 5, 40, 21, 2, 1092, 1094, 3, 2, 2, 2, 1093, 1088, 3, 2, 2, 2, 1093,
	1094, 3, 2, 2, 2, 1094, 235, 3, 2, 2, 2, 1095, 1096, 7, 26, 2, 2, 1096,
	1098, 5, 238, 120, 2, 1097, 1095, 3, 2, 2, 2, 1097, 1098, 3, 2, 2, 2, 1098,
	237, 3, 2, 2, 2, 1099, 1104, 5, 240, 121, 2, 1100, 1101, 7, 26, 2, 2, 1101,
	1103, 5, 240, 121, 2, 1102, 1100, 3, 2, 2, 2, 1103, 1106, 3, 2, 2, 2, 1104,
	1102, 3, 2, 2, 2, 1104, 1105, 3, 2, 2, 2, 1105, 239, 3, 2, 2, 2, 1106,
	1104, 3, 2, 2, 2, 1107, 1110, 5, 242, 122, 2, 1108, 1110, 5, 248, 125,
	2, 1109, 1107, 3, 2, 2, 2, 1109, 1108, 3, 2, 2, 2, 1110, 241, 3, 2, 2,
	2, 1111, 1112, 7, 82, 2, 2, 1112, 1113, 5, 64, 33, 2, 1113, 1114, 5, 246,
	124, 2, 1114, 1115, 7, 83, 2, 2, 1115, 243, 3, 2, 2, 2, 1116, 1117, 5,
	246, 124, 2, 1117, 245, 3, 2, 2, 2, 1118, 1123, 5, 248, 125, 2, 1119, 1120,
	7, 26, 2, 2, 1120, 1122, 5, 248, 125, 2, 1121, 1119, 3, 2, 2, 2, 1122,
	1125, 3, 2, 2, 2, 1123, 1121, 3, 2, 2, 2, 1123, 1124, 3, 2, 2, 2, 1124,
	247, 3, 2, 2, 2, 1125, 1123, 3, 2, 2, 2, 1126, 1127, 7, 109, 2, 2, 1127,
	1128, 5, 176, 89, 2, 1128, 249, 3, 2, 2, 2, 1129, 1130, 7, 30, 2, 2, 1130,
	1131, 7, 24, 2, 2, 1131, 1132, 5, 252, 127, 2, 1132, 1133, 7, 25, 2, 2,
	1133, 251, 3, 2, 2, 2, 1134, 1144, 5, 254, 128, 2, 1135, 1136, 7, 26, 2,
	2, 1136, 1138, 7, 14, 2, 2, 1137, 1139, 5, 272, 137, 2, 1138, 1137, 3,
	2, 2, 2, 1138, 1139, 3, 2, 2, 2, 1139, 1142, 3, 2, 2, 2, 1140, 1141, 7,
	26, 2, 2, 1141, 1143, 5, 276, 139, 2, 1142, 1140, 3, 2, 2, 2, 1142, 1143,
	3, 2, 2, 2, 1143, 1145, 3, 2, 2, 2, 1144, 1135, 3, 2, 2, 2, 1144, 1145,
	3, 2, 2, 2, 1145, 253, 3, 2, 2, 2, 1146, 1147, 5, 256, 129, 2, 1147, 255,
	3, 2, 2, 2, 1148, 1153, 5, 258, 130, 2, 1149, 1150, 7, 26, 2, 2, 1150,
	1152, 5, 258, 130, 2, 1151, 1149, 3, 2, 2, 2, 1152, 1155, 3, 2, 2, 2, 1153,
	1151, 3, 2, 2, 2, 1153, 1154, 3, 2, 2, 2, 1154, 257, 3, 2, 2, 2, 1155,
	1153, 3, 2, 2, 2, 1156, 1160, 7, 109, 2, 2, 1157, 1160, 5, 260, 131, 2,
	1158, 1160, 5, 214, 108, 2, 1159, 1156, 3, 2, 2, 2, 1159, 1157, 3, 2, 2,
	2, 1159, 1158, 3, 2, 2, 2, 1160, 259, 3, 2, 2, 2, 1161, 1162, 7, 109, 2,
	2, 1162, 1165, 7, 27, 2, 2, 1163, 1166, 5, 230, 116, 2, 1164, 1166, 5,
	262, 132, 2, 1165, 1163, 3, 2, 2, 2, 1165, 1164, 3, 2, 2, 2, 1166, 1167,
	3, 2, 2, 2, 1167, 1168, 7, 28, 2, 2, 1168, 261, 3, 2, 2, 2, 1169, 1170,
	5, 264, 133, 2, 1170, 263, 3, 2, 2, 2, 1171, 1173, 5, 266, 134, 2, 1172,
	1174, 5, 268, 135, 2, 1173, 1172, 3, 2, 2, 2, 1173, 1174, 3, 2, 2, 2, 1174,
	265, 3, 2, 2, 2, 1175, 1178, 7, 109, 2, 2, 1176, 1177, 7, 12, 2, 2, 1177,
	1179, 7, 109, 2, 2, 1178, 1176, 3, 2, 2, 2, 1178, 1179, 3, 2, 2, 2, 1179,
	267, 3, 2, 2, 2, 1180, 1181, 7, 24, 2, 2, 1181, 1186, 5, 270, 136, 2, 1182,
	1183, 7, 26, 2, 2, 1183, 1185, 5, 270, 136, 2, 1184, 1182, 3, 2, 2, 2,
	1185, 1188, 3, 2, 2, 2, 1186, 1184, 3, 2, 2, 2, 1186, 1187, 3, 2, 2, 2,
	1187, 1189, 3, 2, 2, 2, 1188, 1186, 3, 2, 2, 2, 1189, 1190, 7, 25, 2, 2,
	1190, 269, 3, 2, 2, 2, 1191, 1194, 5, 176, 89, 2, 1192, 1194, 5, 214, 108,
	2, 1193, 1191, 3, 2, 2, 2, 1193, 1192, 3, 2, 2, 2, 1194, 271, 3, 2, 2,
	2, 1195, 1196, 7, 45, 2, 2, 1196, 1197, 5, 274, 138, 2, 1197, 273, 3, 2,
	2, 2, 1198, 1205, 5, 230, 116, 2, 1199, 1205, 5, 262, 132, 2, 1200, 1201,
	5, 176, 89, 2, 1201, 1202, 7, 84, 2, 2, 1202, 1203, 5, 214, 108, 2, 1203,
	1205, 3, 2, 2, 2, 1204, 1198, 3, 2, 2, 2, 1204, 1199, 3, 2, 2, 2, 1204,
	1200, 3, 2, 2, 2, 1205, 275, 3, 2, 2, 2, 1206, 1207, 5, 256, 129, 2, 1207,
	277, 3, 2, 2, 2, 1208, 1213, 7, 23, 2, 2, 1209, 1210, 7, 24, 2, 2, 1210,
	1211, 5, 280, 141, 2, 1211, 1212, 7, 25, 2, 2, 1212, 1214, 3, 2, 2, 2,
	1213, 1209, 3, 2, 2, 2, 1213, 1214, 3, 2, 2, 2, 1214, 279, 3, 2, 2, 2,
	1215, 1220, 5, 260, 131, 2, 1216, 1217, 7, 26, 2, 2, 1217, 1219, 5, 260,
	131, 2, 1218, 1216, 3, 2, 2, 2, 1219, 1222, 3, 2, 2, 2, 1220, 1218, 3,
	2, 2, 2, 1220, 1221, 3, 2, 2, 2, 1221, 281, 3, 2, 2, 2, 1222, 1220, 3,
	2, 2, 2, 1223, 1224, 7, 92, 2, 2, 1224, 1225, 7, 93, 2, 2, 1225, 283, 3,
	2, 2, 2, 1226, 1227, 7, 24, 2, 2, 1227, 1230, 7, 109, 2, 2, 1228, 1229,
	7, 12, 2, 2, 1229, 1231, 7, 109, 2, 2, 1230, 1228, 3, 2, 2, 2, 1230, 1231,
	3, 2, 2, 2, 1231, 1232, 3, 2, 2, 2, 1232, 1244, 7, 25, 2, 2, 1233, 1234,
	7, 24, 2, 2, 1234, 1239, 5, 286, 144, 2, 1235, 1236, 7, 26, 2, 2, 1236,
	1238, 5, 286, 144, 2, 1237, 1235, 3, 2, 2, 2, 1238, 1241, 3, 2, 2, 2, 1239,
	1237, 3, 2, 2, 2, 1239, 1240, 3, 2, 2, 2, 1240, 1242, 3, 2, 2, 2, 1241,
	1239, 3, 2, 2, 2, 1242, 1243, 7, 25, 2, 2, 1243, 1245, 3, 2, 2, 2, 1244,
	1233, 3, 2, 2, 2, 1244, 1245, 3, 2, 2, 2, 1245, 285, 3, 2, 2, 2, 1246,
	1250, 7, 6, 2, 2, 1247, 1248, 7, 98, 2, 2, 1248, 1250, 5, 288, 145, 2,
	1249, 1246, 3, 2, 2, 2, 1249, 1247, 3, 2, 2, 2, 1250, 1251, 3, 2, 2, 2,
	1251, 1252, 5, 290, 146, 2, 1252, 287, 3, 2, 2, 2, 1253, 1254, 7, 12, 2,
	2, 1254, 1256, 5, 288, 145, 2, 1255, 1253, 3, 2, 2, 2, 1255, 1256, 3, 2,
	2, 2, 1256, 289, 3, 2, 2, 2, 1257, 1262, 7, 109, 2, 2, 1258, 1259, 7, 12,
	2, 2, 1259, 1261, 7, 109, 2, 2, 1260, 1258, 3, 2, 2, 2, 1261, 1264, 3,
	2, 2, 2, 1262, 1260, 3, 2, 2, 2, 1262, 1263, 3, 2, 2, 2, 1263, 291, 3,
	2, 2, 2, 1264, 1262, 3, 2, 2, 2, 1265, 1266, 7, 37, 2, 2, 1266, 1267, 7,
	35, 2, 2, 1267, 293, 3, 2, 2, 2, 1268, 1269, 7, 34, 2, 2, 1269, 1270, 7,
	35, 2, 2, 1270, 1275, 3, 2, 2, 2, 1271, 1272, 7, 24, 2, 2, 1272, 1273,
	5, 296, 149, 2, 1273, 1274, 7, 25, 2, 2, 1274, 1276, 3, 2, 2, 2, 1275,
	1271, 3, 2, 2, 2, 1275, 1276, 3, 2, 2, 2, 1276, 295, 3, 2, 2, 2, 1277,
	1282, 5, 298, 150, 2, 1278, 1279, 7, 26, 2, 2, 1279, 1281, 5, 298, 150,
	2, 1280, 1278, 3, 2, 2, 2, 1281, 1284, 3, 2, 2, 2, 1282, 1280, 3, 2, 2,
	2, 1282, 1283, 3, 2, 2, 2, 1283, 297, 3, 2, 2, 2, 1284, 1282, 3, 2, 2,
	2, 1285, 1286, 7, 109, 2, 2, 1286, 1289, 7, 27, 2, 2, 1287, 1290, 7, 103,
	2, 2, 1288, 1290, 5, 262, 132, 2, 1289, 1287, 3, 2, 2, 2, 1289, 1288, 3,
	2, 2, 2, 1290, 1291, 3, 2, 2, 2, 1291, 1292, 7, 28, 2, 2, 1292, 299, 3,
	2, 2, 2, 1293, 1294, 9, 8, 2, 2, 1294, 301, 3, 2, 2, 2, 152, 305, 315,
	319, 331, 335, 341, 350, 353, 359, 362, 368, 385, 391, 397, 405, 413, 419,
	423, 429, 438, 440, 442, 451, 453, 455, 462, 467, 474, 479, 484, 494, 501,
	506, 512, 518, 524, 528, 533, 543, 550, 552, 560, 568, 574, 578, 585, 589,
	594, 609, 614, 624, 630, 636, 642, 652, 656, 659, 662, 664, 671, 673, 680,
	682, 684, 689, 694, 700, 703, 708, 714, 720, 725, 729, 736, 747, 749, 754,
	756, 766, 778, 780, 789, 797, 809, 820, 824, 828, 831, 835, 839, 845, 851,
	857, 862, 868, 873, 884, 889, 905, 917, 924, 929, 936, 939, 944, 950, 960,
	968, 976, 999, 1002, 1008, 1010, 1015, 1017, 1024, 1041, 1051, 1059, 1062,
	1065, 1069, 1078, 1093, 1097, 1104, 1109, 1123, 1138, 1142, 1144, 1153,
	1159, 1165, 1173, 1178, 1186, 1193, 1204, 1213, 1220, 1230, 1239, 1244,
	1249, 1255, 1262, 1275, 1282, 1289,
}
var deserializer = antlr.NewATNDeserializer(nil)
var deserializedATN = deserializer.DeserializeFromUInt16(parserATN)

var literalNames = []string{
	"", "", "", "", "'@'", "'*'", "'::='", "'BOOLEAN'", "'TRUE'", "'FALSE'",
	"'.'", "'..'", "'...'", "'''", "'&'", "'<'", "'>'", "'</'", "'/>'", "'true'",
	"'false'", "'INTEGER'", "'{'", "'}'", "','", "'('", "')'", "'-'", "'ENUMERATED'",
	"'REAL'", "'PLUS-INFINITY'", "'MINUS-INFINITY'", "'BIT'", "'STRING'", "'CONTAINING'",
	"'OCTET'", "'NULL'", "'SEQUENCE'", "'OPTIONAL'", "'DEFAULT'", "'COMPONENTS'",
	"'OF'", "'SET'", "'!'", "'ALL'", "'EXCEPT'", "'^'", "'|'", "'UNION'", "'INTERSECTION'",
	"'INCLUDES'", "'MIN'", "'MAX'", "'SIZE'", "'FROM'", "'WITH'", "'COMPONENT'",
	"'PRESENT'", "'ABSENT'", "'PATTERN'", "'TYPE-Identifier'", "'ABSTRACT-SYNTAX'",
	"'CLASS'", "'UNIQUE'", "'SYNTAX'", "'['", "']'", "'INSTANCE'", "';'", "'IMPORTS'",
	"'EXPORTS'", "'EXTENSIBILITY'", "'IMPLIED'", "'EXPLICIT'", "'TAGS'", "'IMPLICIT'",
	"'AUTOMATIC'", "'DEFINITIONS'", "'BEGIN'", "'END'", "'[['", "']]'", "':'",
	"'CHOICE'", "'UNIVERSAL'", "'APPLICATION'", "'PRIVATE'", "'EMBEDDED'",
	"'PDV'", "'EXTERNAL'", "'OBJECT'", "'IDENTIFIER'", "'RELATIVE-OID'", "'CHARACTER'",
	"'CONSTRAINED'", "'BY'", "'@.'", "'ENCODED'", "'--'",
}
var symbolicNames = []string{
	"", "NEED_LITERAL", "COND_LITERAL", "INVALID_TAG", "A_ROND", "STAR", "ASSIGN_OP",
	"BOOLEAN_LITERAL", "TRUE_LITERAL", "FALSE_LITERAL", "DOT", "DOUBLE_DOT",
	"ELLIPSIS", "APOSTROPHE", "AMPERSAND", "LESS_THAN", "GREATER_THAN", "LESS_THAN_SLASH",
	"SLASH_GREATER_THAN", "TRUE_SMALL_LITERAL", "FALSE_SMALL_LITERAL", "INTEGER_LITERAL",
	"L_BRACE", "R_BRACE", "COMMA", "L_PARAN", "R_PARAN", "MINUS", "ENUMERATED_LITERAL",
	"REAL_LITERAL", "PLUS_INFINITY_LITERAL", "MINUS_INFINITY_LITERAL", "BIT_LITERAL",
	"STRING_LITERAL", "CONTAINING_LITERAL", "OCTET_LITERAL", "NULL_LITERAL",
	"SEQUENCE_LITERAL", "OPTIONAL_LITERAL", "DEFAULT_LITERAL", "COMPONENTS_LITERAL",
	"OF_LITERAL", "SET_LITERAL", "EXCLAM", "ALL_LITERAL", "EXCEPT_LITERAL",
	"POWER", "PIPE", "UNION_LITERAL", "INTERSECTION_LITERAL", "INCLUDES_LITERAL",
	"MIN_LITERAL", "MAX_LITERAL", "SIZE_LITERAL", "FROM_LITERAL", "WITH_LITERAL",
	"COMPONENT_LITERAL", "PRESENT_LITERAL", "ABSENT_LITERAL", "PATTERN_LITERAL",
	"TYPE_IDENTIFIER_LITERAL", "ABSTRACT_SYNTAX_LITERAL", "CLASS_LITERAL",
	"UNIQUE_LITERAL", "SYNTAX_LITERAL", "L_BRACKET", "R_BRACKET", "INSTANCE_LITERAL",
	"SEMI_COLON", "IMPORTS_LITERAL", "EXPORTS_LITERAL", "EXTENSIBILITY_LITERAL",
	"IMPLIED_LITERAL", "EXPLICIT_LITERAL", "TAGS_LITERAL", "IMPLICIT_LITERAL",
	"AUTOMATIC_LITERAL", "DEFINITIONS_LITERAL", "BEGIN_LITERAL", "END_LITERAL",
	"DOUBLE_L_BRACKET", "DOUBLE_R_BRACKET", "COLON", "CHOICE_LITERAL", "UNIVERSAL_LITERAL",
	"APPLICATION_LITERAL", "PRIVATE_LITERAL", "EMBEDDED_LITERAL", "PDV_LITERAL",
	"EXTERNAL_LITERAL", "OBJECT_LITERAL", "IDENTIFIER_LITERAL", "RELATIVE_OID_LITERAL",
	"CHARACTER_LITERAL", "CONSTRAINED_LITERAL", "BY_LITERAL", "A_ROND_DOT",
	"ENCODED_LITERAL", "COMMENT", "UNRESTRICTEDCHARACTERSTRINGTYPE", "EXTENSTIONENDMARKER",
	"NUMBER", "WS", "LINE_COMMENT", "BSTRING", "HSTRING", "CSTRING", "IDENTIFIER",
}

var ruleNames = []string{
	"modules", "moduleDefinition", "tagDefault", "extensionDefault", "moduleBody",
	"exports", "symbolsExported", "imports", "symbolsImported", "symbolsFromModuleList",
	"symbolsFromModule", "globalModuleReference", "assignedIdentifier", "symbolList",
	"symbol", "assignmentList", "assignment", "sequenceType", "extensionAndException",
	"optionalExtensionMarker", "componentTypeLists", "rootComponentTypeList",
	"componentTypeList", "componentType", "tag", "needTag", "condTag", "extensionAdditions",
	"extensionAdditionList", "extensionAddition", "extensionAdditionGroup",
	"versionNumber", "sequenceOfType", "sizeConstraint", "parameterizedAssignment",
	"parameterList", "parameter", "paramGovernor", "governor", "objectClassAssignment",
	"objectClass", "definedObjectClass", "usefulObjectClassReference", "externalObjectClassReference",
	"objectClassDefn", "withSyntaxSpec", "syntaxList", "tokenOrGroupSpec",
	"optionalGroup", "requiredToken", "literal", "primitiveFieldName", "fieldSpec",
	"typeFieldSpec", "typeOptionalitySpec", "fixedTypeValueFieldSpec", "valueOptionalitySpec",
	"variableTypeValueFieldSpec", "fixedTypeValueSetFieldSpec", "valueSetOptionalitySpec",
	"object", "parameterizedObject", "definedObject", "objectSet", "objectSetSpec",
	"fieldName", "valueSet", "elementSetSpecs", "rootElementSetSpec", "additionalElementSetSpec",
	"elementSetSpec", "unions", "exclusions", "intersections", "unionMark",
	"intersectionMark", "elements", "objectSetElements", "intersectionElements",
	"subtypeElements", "variableTypeValueSetFieldSpec", "objectFieldSpec",
	"objectOptionalitySpec", "objectSetFieldSpec", "objectSetOptionalitySpec",
	"typeAssignment", "valueAssignment", "asnType", "builtinType", "objectClassFieldType",
	"setType", "setOfType", "referencedType", "definedType", "constraint",
	"constraintSpec", "userDefinedConstraint", "generalConstraint", "userDefinedConstraintParameter",
	"tableConstraint", "simpleTableConstraint", "contentsConstraint", "componentPresenceLists",
	"componentPresenceList", "componentPresence", "subtypeConstraint", "value",
	"builtinValue", "objectIdentifierValue", "objIdComponentsList", "objIdComponents",
	"integerValue", "choiceValue", "enumeratedValue", "signedNumber", "choiceType",
	"alternativeTypeLists", "extensionAdditionAlternatives", "extensionAdditionAlternativesList",
	"extensionAdditionAlternative", "extensionAdditionAlternativesGroup", "rootAlternativeTypeList",
	"alternativeTypeList", "namedType", "enumeratedType", "enumerations", "rootEnumeration",
	"enumeration", "enumerationItem", "namedNumber", "definedValue", "parameterizedValue",
	"simpleDefinedValue", "actualParameterList", "actualParameter", "exceptionSpec",
	"exceptionIdentification", "additionalEnumeration", "integerType", "namedNumberList",
	"objectidentifiertype", "componentRelationConstraint", "atNotation", "level",
	"componentIdList", "octetStringType", "bitStringType", "namedBitList",
	"namedBit", "booleanValue",
}
var decisionToDFA = make([]*antlr.DFA, len(deserializedATN.DecisionToState))

func init() {
	for index, ds := range deserializedATN.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(ds, index)
	}
}

type ASN_3gppParser struct {
	*antlr.BaseParser
}

func NewASN_3gppParser(input antlr.TokenStream) *ASN_3gppParser {
	this := new(ASN_3gppParser)

	this.BaseParser = antlr.NewBaseParser(input)

	this.Interpreter = antlr.NewParserATNSimulator(this, deserializedATN, decisionToDFA, antlr.NewPredictionContextCache())
	this.RuleNames = ruleNames
	this.LiteralNames = literalNames
	this.SymbolicNames = symbolicNames
	this.GrammarFileName = "ASN_3gpp.g4"

	return this
}

// ASN_3gppParser tokens.
const (
	ASN_3gppParserEOF                             = antlr.TokenEOF
	ASN_3gppParserNEED_LITERAL                    = 1
	ASN_3gppParserCOND_LITERAL                    = 2
	ASN_3gppParserINVALID_TAG                     = 3
	ASN_3gppParserA_ROND                          = 4
	ASN_3gppParserSTAR                            = 5
	ASN_3gppParserASSIGN_OP                       = 6
	ASN_3gppParserBOOLEAN_LITERAL                 = 7
	ASN_3gppParserTRUE_LITERAL                    = 8
	ASN_3gppParserFALSE_LITERAL                   = 9
	ASN_3gppParserDOT                             = 10
	ASN_3gppParserDOUBLE_DOT                      = 11
	ASN_3gppParserELLIPSIS                        = 12
	ASN_3gppParserAPOSTROPHE                      = 13
	ASN_3gppParserAMPERSAND                       = 14
	ASN_3gppParserLESS_THAN                       = 15
	ASN_3gppParserGREATER_THAN                    = 16
	ASN_3gppParserLESS_THAN_SLASH                 = 17
	ASN_3gppParserSLASH_GREATER_THAN              = 18
	ASN_3gppParserTRUE_SMALL_LITERAL              = 19
	ASN_3gppParserFALSE_SMALL_LITERAL             = 20
	ASN_3gppParserINTEGER_LITERAL                 = 21
	ASN_3gppParserL_BRACE                         = 22
	ASN_3gppParserR_BRACE                         = 23
	ASN_3gppParserCOMMA                           = 24
	ASN_3gppParserL_PARAN                         = 25
	ASN_3gppParserR_PARAN                         = 26
	ASN_3gppParserMINUS                           = 27
	ASN_3gppParserENUMERATED_LITERAL              = 28
	ASN_3gppParserREAL_LITERAL                    = 29
	ASN_3gppParserPLUS_INFINITY_LITERAL           = 30
	ASN_3gppParserMINUS_INFINITY_LITERAL          = 31
	ASN_3gppParserBIT_LITERAL                     = 32
	ASN_3gppParserSTRING_LITERAL                  = 33
	ASN_3gppParserCONTAINING_LITERAL              = 34
	ASN_3gppParserOCTET_LITERAL                   = 35
	ASN_3gppParserNULL_LITERAL                    = 36
	ASN_3gppParserSEQUENCE_LITERAL                = 37
	ASN_3gppParserOPTIONAL_LITERAL                = 38
	ASN_3gppParserDEFAULT_LITERAL                 = 39
	ASN_3gppParserCOMPONENTS_LITERAL              = 40
	ASN_3gppParserOF_LITERAL                      = 41
	ASN_3gppParserSET_LITERAL                     = 42
	ASN_3gppParserEXCLAM                          = 43
	ASN_3gppParserALL_LITERAL                     = 44
	ASN_3gppParserEXCEPT_LITERAL                  = 45
	ASN_3gppParserPOWER                           = 46
	ASN_3gppParserPIPE                            = 47
	ASN_3gppParserUNION_LITERAL                   = 48
	ASN_3gppParserINTERSECTION_LITERAL            = 49
	ASN_3gppParserINCLUDES_LITERAL                = 50
	ASN_3gppParserMIN_LITERAL                     = 51
	ASN_3gppParserMAX_LITERAL                     = 52
	ASN_3gppParserSIZE_LITERAL                    = 53
	ASN_3gppParserFROM_LITERAL                    = 54
	ASN_3gppParserWITH_LITERAL                    = 55
	ASN_3gppParserCOMPONENT_LITERAL               = 56
	ASN_3gppParserPRESENT_LITERAL                 = 57
	ASN_3gppParserABSENT_LITERAL                  = 58
	ASN_3gppParserPATTERN_LITERAL                 = 59
	ASN_3gppParserTYPE_IDENTIFIER_LITERAL         = 60
	ASN_3gppParserABSTRACT_SYNTAX_LITERAL         = 61
	ASN_3gppParserCLASS_LITERAL                   = 62
	ASN_3gppParserUNIQUE_LITERAL                  = 63
	ASN_3gppParserSYNTAX_LITERAL                  = 64
	ASN_3gppParserL_BRACKET                       = 65
	ASN_3gppParserR_BRACKET                       = 66
	ASN_3gppParserINSTANCE_LITERAL                = 67
	ASN_3gppParserSEMI_COLON                      = 68
	ASN_3gppParserIMPORTS_LITERAL                 = 69
	ASN_3gppParserEXPORTS_LITERAL                 = 70
	ASN_3gppParserEXTENSIBILITY_LITERAL           = 71
	ASN_3gppParserIMPLIED_LITERAL                 = 72
	ASN_3gppParserEXPLICIT_LITERAL                = 73
	ASN_3gppParserTAGS_LITERAL                    = 74
	ASN_3gppParserIMPLICIT_LITERAL                = 75
	ASN_3gppParserAUTOMATIC_LITERAL               = 76
	ASN_3gppParserDEFINITIONS_LITERAL             = 77
	ASN_3gppParserBEGIN_LITERAL                   = 78
	ASN_3gppParserEND_LITERAL                     = 79
	ASN_3gppParserDOUBLE_L_BRACKET                = 80
	ASN_3gppParserDOUBLE_R_BRACKET                = 81
	ASN_3gppParserCOLON                           = 82
	ASN_3gppParserCHOICE_LITERAL                  = 83
	ASN_3gppParserUNIVERSAL_LITERAL               = 84
	ASN_3gppParserAPPLICATION_LITERAL             = 85
	ASN_3gppParserPRIVATE_LITERAL                 = 86
	ASN_3gppParserEMBEDDED_LITERAL                = 87
	ASN_3gppParserPDV_LITERAL                     = 88
	ASN_3gppParserEXTERNAL_LITERAL                = 89
	ASN_3gppParserOBJECT_LITERAL                  = 90
	ASN_3gppParserIDENTIFIER_LITERAL              = 91
	ASN_3gppParserRELATIVE_OID_LITERAL            = 92
	ASN_3gppParserCHARACTER_LITERAL               = 93
	ASN_3gppParserCONSTRAINED_LITERAL             = 94
	ASN_3gppParserBY_LITERAL                      = 95
	ASN_3gppParserA_ROND_DOT                      = 96
	ASN_3gppParserENCODED_LITERAL                 = 97
	ASN_3gppParserCOMMENT                         = 98
	ASN_3gppParserUNRESTRICTEDCHARACTERSTRINGTYPE = 99
	ASN_3gppParserEXTENSTIONENDMARKER             = 100
	ASN_3gppParserNUMBER                          = 101
	ASN_3gppParserWS                              = 102
	ASN_3gppParserLINE_COMMENT                    = 103
	ASN_3gppParserBSTRING                         = 104
	ASN_3gppParserHSTRING                         = 105
	ASN_3gppParserCSTRING                         = 106
	ASN_3gppParserIDENTIFIER                      = 107
)

// ASN_3gppParser rules.
const (
	ASN_3gppParserRULE_modules                            = 0
	ASN_3gppParserRULE_moduleDefinition                   = 1
	ASN_3gppParserRULE_tagDefault                         = 2
	ASN_3gppParserRULE_extensionDefault                   = 3
	ASN_3gppParserRULE_moduleBody                         = 4
	ASN_3gppParserRULE_exports                            = 5
	ASN_3gppParserRULE_symbolsExported                    = 6
	ASN_3gppParserRULE_imports                            = 7
	ASN_3gppParserRULE_symbolsImported                    = 8
	ASN_3gppParserRULE_symbolsFromModuleList              = 9
	ASN_3gppParserRULE_symbolsFromModule                  = 10
	ASN_3gppParserRULE_globalModuleReference              = 11
	ASN_3gppParserRULE_assignedIdentifier                 = 12
	ASN_3gppParserRULE_symbolList                         = 13
	ASN_3gppParserRULE_symbol                             = 14
	ASN_3gppParserRULE_assignmentList                     = 15
	ASN_3gppParserRULE_assignment                         = 16
	ASN_3gppParserRULE_sequenceType                       = 17
	ASN_3gppParserRULE_extensionAndException              = 18
	ASN_3gppParserRULE_optionalExtensionMarker            = 19
	ASN_3gppParserRULE_componentTypeLists                 = 20
	ASN_3gppParserRULE_rootComponentTypeList              = 21
	ASN_3gppParserRULE_componentTypeList                  = 22
	ASN_3gppParserRULE_componentType                      = 23
	ASN_3gppParserRULE_tag                                = 24
	ASN_3gppParserRULE_needTag                            = 25
	ASN_3gppParserRULE_condTag                            = 26
	ASN_3gppParserRULE_extensionAdditions                 = 27
	ASN_3gppParserRULE_extensionAdditionList              = 28
	ASN_3gppParserRULE_extensionAddition                  = 29
	ASN_3gppParserRULE_extensionAdditionGroup             = 30
	ASN_3gppParserRULE_versionNumber                      = 31
	ASN_3gppParserRULE_sequenceOfType                     = 32
	ASN_3gppParserRULE_sizeConstraint                     = 33
	ASN_3gppParserRULE_parameterizedAssignment            = 34
	ASN_3gppParserRULE_parameterList                      = 35
	ASN_3gppParserRULE_parameter                          = 36
	ASN_3gppParserRULE_paramGovernor                      = 37
	ASN_3gppParserRULE_governor                           = 38
	ASN_3gppParserRULE_objectClassAssignment              = 39
	ASN_3gppParserRULE_objectClass                        = 40
	ASN_3gppParserRULE_definedObjectClass                 = 41
	ASN_3gppParserRULE_usefulObjectClassReference         = 42
	ASN_3gppParserRULE_externalObjectClassReference       = 43
	ASN_3gppParserRULE_objectClassDefn                    = 44
	ASN_3gppParserRULE_withSyntaxSpec                     = 45
	ASN_3gppParserRULE_syntaxList                         = 46
	ASN_3gppParserRULE_tokenOrGroupSpec                   = 47
	ASN_3gppParserRULE_optionalGroup                      = 48
	ASN_3gppParserRULE_requiredToken                      = 49
	ASN_3gppParserRULE_literal                            = 50
	ASN_3gppParserRULE_primitiveFieldName                 = 51
	ASN_3gppParserRULE_fieldSpec                          = 52
	ASN_3gppParserRULE_typeFieldSpec                      = 53
	ASN_3gppParserRULE_typeOptionalitySpec                = 54
	ASN_3gppParserRULE_fixedTypeValueFieldSpec            = 55
	ASN_3gppParserRULE_valueOptionalitySpec               = 56
	ASN_3gppParserRULE_variableTypeValueFieldSpec         = 57
	ASN_3gppParserRULE_fixedTypeValueSetFieldSpec         = 58
	ASN_3gppParserRULE_valueSetOptionalitySpec            = 59
	ASN_3gppParserRULE_object                             = 60
	ASN_3gppParserRULE_parameterizedObject                = 61
	ASN_3gppParserRULE_definedObject                      = 62
	ASN_3gppParserRULE_objectSet                          = 63
	ASN_3gppParserRULE_objectSetSpec                      = 64
	ASN_3gppParserRULE_fieldName                          = 65
	ASN_3gppParserRULE_valueSet                           = 66
	ASN_3gppParserRULE_elementSetSpecs                    = 67
	ASN_3gppParserRULE_rootElementSetSpec                 = 68
	ASN_3gppParserRULE_additionalElementSetSpec           = 69
	ASN_3gppParserRULE_elementSetSpec                     = 70
	ASN_3gppParserRULE_unions                             = 71
	ASN_3gppParserRULE_exclusions                         = 72
	ASN_3gppParserRULE_intersections                      = 73
	ASN_3gppParserRULE_unionMark                          = 74
	ASN_3gppParserRULE_intersectionMark                   = 75
	ASN_3gppParserRULE_elements                           = 76
	ASN_3gppParserRULE_objectSetElements                  = 77
	ASN_3gppParserRULE_intersectionElements               = 78
	ASN_3gppParserRULE_subtypeElements                    = 79
	ASN_3gppParserRULE_variableTypeValueSetFieldSpec      = 80
	ASN_3gppParserRULE_objectFieldSpec                    = 81
	ASN_3gppParserRULE_objectOptionalitySpec              = 82
	ASN_3gppParserRULE_objectSetFieldSpec                 = 83
	ASN_3gppParserRULE_objectSetOptionalitySpec           = 84
	ASN_3gppParserRULE_typeAssignment                     = 85
	ASN_3gppParserRULE_valueAssignment                    = 86
	ASN_3gppParserRULE_asnType                            = 87
	ASN_3gppParserRULE_builtinType                        = 88
	ASN_3gppParserRULE_objectClassFieldType               = 89
	ASN_3gppParserRULE_setType                            = 90
	ASN_3gppParserRULE_setOfType                          = 91
	ASN_3gppParserRULE_referencedType                     = 92
	ASN_3gppParserRULE_definedType                        = 93
	ASN_3gppParserRULE_constraint                         = 94
	ASN_3gppParserRULE_constraintSpec                     = 95
	ASN_3gppParserRULE_userDefinedConstraint              = 96
	ASN_3gppParserRULE_generalConstraint                  = 97
	ASN_3gppParserRULE_userDefinedConstraintParameter     = 98
	ASN_3gppParserRULE_tableConstraint                    = 99
	ASN_3gppParserRULE_simpleTableConstraint              = 100
	ASN_3gppParserRULE_contentsConstraint                 = 101
	ASN_3gppParserRULE_componentPresenceLists             = 102
	ASN_3gppParserRULE_componentPresenceList              = 103
	ASN_3gppParserRULE_componentPresence                  = 104
	ASN_3gppParserRULE_subtypeConstraint                  = 105
	ASN_3gppParserRULE_value                              = 106
	ASN_3gppParserRULE_builtinValue                       = 107
	ASN_3gppParserRULE_objectIdentifierValue              = 108
	ASN_3gppParserRULE_objIdComponentsList                = 109
	ASN_3gppParserRULE_objIdComponents                    = 110
	ASN_3gppParserRULE_integerValue                       = 111
	ASN_3gppParserRULE_choiceValue                        = 112
	ASN_3gppParserRULE_enumeratedValue                    = 113
	ASN_3gppParserRULE_signedNumber                       = 114
	ASN_3gppParserRULE_choiceType                         = 115
	ASN_3gppParserRULE_alternativeTypeLists               = 116
	ASN_3gppParserRULE_extensionAdditionAlternatives      = 117
	ASN_3gppParserRULE_extensionAdditionAlternativesList  = 118
	ASN_3gppParserRULE_extensionAdditionAlternative       = 119
	ASN_3gppParserRULE_extensionAdditionAlternativesGroup = 120
	ASN_3gppParserRULE_rootAlternativeTypeList            = 121
	ASN_3gppParserRULE_alternativeTypeList                = 122
	ASN_3gppParserRULE_namedType                          = 123
	ASN_3gppParserRULE_enumeratedType                     = 124
	ASN_3gppParserRULE_enumerations                       = 125
	ASN_3gppParserRULE_rootEnumeration                    = 126
	ASN_3gppParserRULE_enumeration                        = 127
	ASN_3gppParserRULE_enumerationItem                    = 128
	ASN_3gppParserRULE_namedNumber                        = 129
	ASN_3gppParserRULE_definedValue                       = 130
	ASN_3gppParserRULE_parameterizedValue                 = 131
	ASN_3gppParserRULE_simpleDefinedValue                 = 132
	ASN_3gppParserRULE_actualParameterList                = 133
	ASN_3gppParserRULE_actualParameter                    = 134
	ASN_3gppParserRULE_exceptionSpec                      = 135
	ASN_3gppParserRULE_exceptionIdentification            = 136
	ASN_3gppParserRULE_additionalEnumeration              = 137
	ASN_3gppParserRULE_integerType                        = 138
	ASN_3gppParserRULE_namedNumberList                    = 139
	ASN_3gppParserRULE_objectidentifiertype               = 140
	ASN_3gppParserRULE_componentRelationConstraint        = 141
	ASN_3gppParserRULE_atNotation                         = 142
	ASN_3gppParserRULE_level                              = 143
	ASN_3gppParserRULE_componentIdList                    = 144
	ASN_3gppParserRULE_octetStringType                    = 145
	ASN_3gppParserRULE_bitStringType                      = 146
	ASN_3gppParserRULE_namedBitList                       = 147
	ASN_3gppParserRULE_namedBit                           = 148
	ASN_3gppParserRULE_booleanValue                       = 149
)

// IModulesContext is an interface to support dynamic dispatch.
type IModulesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModulesContext differentiates from other interfaces.
	IsModulesContext()
}

type ModulesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModulesContext() *ModulesContext {
	var p = new(ModulesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_modules
	return p
}

func (*ModulesContext) IsModulesContext() {}

func NewModulesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModulesContext {
	var p = new(ModulesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_modules

	return p
}

func (s *ModulesContext) GetParser() antlr.Parser { return s.parser }

func (s *ModulesContext) AllModuleDefinition() []IModuleDefinitionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IModuleDefinitionContext)(nil)).Elem())
	var tst = make([]IModuleDefinitionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IModuleDefinitionContext)
		}
	}

	return tst
}

func (s *ModulesContext) ModuleDefinition(i int) IModuleDefinitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModuleDefinitionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IModuleDefinitionContext)
}

func (s *ModulesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModulesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModulesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterModules(s)
	}
}

func (s *ModulesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitModules(s)
	}
}

func (p *ASN_3gppParser) Modules() (localctx IModulesContext) {
	localctx = NewModulesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, ASN_3gppParserRULE_modules)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(301)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == ASN_3gppParserIDENTIFIER {
		{
			p.SetState(300)
			p.ModuleDefinition()
		}

		p.SetState(303)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IModuleDefinitionContext is an interface to support dynamic dispatch.
type IModuleDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModuleDefinitionContext differentiates from other interfaces.
	IsModuleDefinitionContext()
}

type ModuleDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModuleDefinitionContext() *ModuleDefinitionContext {
	var p = new(ModuleDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_moduleDefinition
	return p
}

func (*ModuleDefinitionContext) IsModuleDefinitionContext() {}

func NewModuleDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModuleDefinitionContext {
	var p = new(ModuleDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_moduleDefinition

	return p
}

func (s *ModuleDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *ModuleDefinitionContext) AllIDENTIFIER() []antlr.TerminalNode {
	return s.GetTokens(ASN_3gppParserIDENTIFIER)
}

func (s *ModuleDefinitionContext) IDENTIFIER(i int) antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserIDENTIFIER, i)
}

func (s *ModuleDefinitionContext) DEFINITIONS_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserDEFINITIONS_LITERAL, 0)
}

func (s *ModuleDefinitionContext) TagDefault() ITagDefaultContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITagDefaultContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITagDefaultContext)
}

func (s *ModuleDefinitionContext) ExtensionDefault() IExtensionDefaultContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExtensionDefaultContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExtensionDefaultContext)
}

func (s *ModuleDefinitionContext) ASSIGN_OP() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserASSIGN_OP, 0)
}

func (s *ModuleDefinitionContext) BEGIN_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserBEGIN_LITERAL, 0)
}

func (s *ModuleDefinitionContext) ModuleBody() IModuleBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModuleBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModuleBodyContext)
}

func (s *ModuleDefinitionContext) END_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserEND_LITERAL, 0)
}

func (s *ModuleDefinitionContext) L_BRACE() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserL_BRACE, 0)
}

func (s *ModuleDefinitionContext) R_BRACE() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserR_BRACE, 0)
}

func (s *ModuleDefinitionContext) AllL_PARAN() []antlr.TerminalNode {
	return s.GetTokens(ASN_3gppParserL_PARAN)
}

func (s *ModuleDefinitionContext) L_PARAN(i int) antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserL_PARAN, i)
}

func (s *ModuleDefinitionContext) AllNUMBER() []antlr.TerminalNode {
	return s.GetTokens(ASN_3gppParserNUMBER)
}

func (s *ModuleDefinitionContext) NUMBER(i int) antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserNUMBER, i)
}

func (s *ModuleDefinitionContext) AllR_PARAN() []antlr.TerminalNode {
	return s.GetTokens(ASN_3gppParserR_PARAN)
}

func (s *ModuleDefinitionContext) R_PARAN(i int) antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserR_PARAN, i)
}

func (s *ModuleDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModuleDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModuleDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterModuleDefinition(s)
	}
}

func (s *ModuleDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitModuleDefinition(s)
	}
}

func (p *ASN_3gppParser) ModuleDefinition() (localctx IModuleDefinitionContext) {
	localctx = NewModuleDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, ASN_3gppParserRULE_moduleDefinition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(305)
		p.Match(ASN_3gppParserIDENTIFIER)
	}
	p.SetState(317)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ASN_3gppParserL_BRACE {
		{
			p.SetState(306)
			p.Match(ASN_3gppParserL_BRACE)
		}
		p.SetState(313)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == ASN_3gppParserIDENTIFIER {
			{
				p.SetState(307)
				p.Match(ASN_3gppParserIDENTIFIER)
			}
			{
				p.SetState(308)
				p.Match(ASN_3gppParserL_PARAN)
			}
			{
				p.SetState(309)
				p.Match(ASN_3gppParserNUMBER)
			}
			{
				p.SetState(310)
				p.Match(ASN_3gppParserR_PARAN)
			}

			p.SetState(315)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(316)
			p.Match(ASN_3gppParserR_BRACE)
		}

	}
	{
		p.SetState(319)
		p.Match(ASN_3gppParserDEFINITIONS_LITERAL)
	}
	{
		p.SetState(320)
		p.TagDefault()
	}
	{
		p.SetState(321)
		p.ExtensionDefault()
	}
	{
		p.SetState(322)
		p.Match(ASN_3gppParserASSIGN_OP)
	}
	{
		p.SetState(323)
		p.Match(ASN_3gppParserBEGIN_LITERAL)
	}
	{
		p.SetState(324)
		p.ModuleBody()
	}
	{
		p.SetState(325)
		p.Match(ASN_3gppParserEND_LITERAL)
	}

	return localctx
}

// ITagDefaultContext is an interface to support dynamic dispatch.
type ITagDefaultContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTagDefaultContext differentiates from other interfaces.
	IsTagDefaultContext()
}

type TagDefaultContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTagDefaultContext() *TagDefaultContext {
	var p = new(TagDefaultContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_tagDefault
	return p
}

func (*TagDefaultContext) IsTagDefaultContext() {}

func NewTagDefaultContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TagDefaultContext {
	var p = new(TagDefaultContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_tagDefault

	return p
}

func (s *TagDefaultContext) GetParser() antlr.Parser { return s.parser }

func (s *TagDefaultContext) TAGS_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserTAGS_LITERAL, 0)
}

func (s *TagDefaultContext) EXPLICIT_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserEXPLICIT_LITERAL, 0)
}

func (s *TagDefaultContext) IMPLICIT_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserIMPLICIT_LITERAL, 0)
}

func (s *TagDefaultContext) AUTOMATIC_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserAUTOMATIC_LITERAL, 0)
}

func (s *TagDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TagDefaultContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TagDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterTagDefault(s)
	}
}

func (s *TagDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitTagDefault(s)
	}
}

func (p *ASN_3gppParser) TagDefault() (localctx ITagDefaultContext) {
	localctx = NewTagDefaultContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, ASN_3gppParserRULE_tagDefault)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(329)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if ((_la-73)&-(0x1f+1)) == 0 && ((1<<uint((_la-73)))&((1<<(ASN_3gppParserEXPLICIT_LITERAL-73))|(1<<(ASN_3gppParserIMPLICIT_LITERAL-73))|(1<<(ASN_3gppParserAUTOMATIC_LITERAL-73)))) != 0 {
		{
			p.SetState(327)
			_la = p.GetTokenStream().LA(1)

			if !(((_la-73)&-(0x1f+1)) == 0 && ((1<<uint((_la-73)))&((1<<(ASN_3gppParserEXPLICIT_LITERAL-73))|(1<<(ASN_3gppParserIMPLICIT_LITERAL-73))|(1<<(ASN_3gppParserAUTOMATIC_LITERAL-73)))) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(328)
			p.Match(ASN_3gppParserTAGS_LITERAL)
		}

	}

	return localctx
}

// IExtensionDefaultContext is an interface to support dynamic dispatch.
type IExtensionDefaultContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExtensionDefaultContext differentiates from other interfaces.
	IsExtensionDefaultContext()
}

type ExtensionDefaultContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExtensionDefaultContext() *ExtensionDefaultContext {
	var p = new(ExtensionDefaultContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_extensionDefault
	return p
}

func (*ExtensionDefaultContext) IsExtensionDefaultContext() {}

func NewExtensionDefaultContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExtensionDefaultContext {
	var p = new(ExtensionDefaultContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_extensionDefault

	return p
}

func (s *ExtensionDefaultContext) GetParser() antlr.Parser { return s.parser }

func (s *ExtensionDefaultContext) EXTENSIBILITY_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserEXTENSIBILITY_LITERAL, 0)
}

func (s *ExtensionDefaultContext) IMPLIED_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserIMPLIED_LITERAL, 0)
}

func (s *ExtensionDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExtensionDefaultContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExtensionDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterExtensionDefault(s)
	}
}

func (s *ExtensionDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitExtensionDefault(s)
	}
}

func (p *ASN_3gppParser) ExtensionDefault() (localctx IExtensionDefaultContext) {
	localctx = NewExtensionDefaultContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, ASN_3gppParserRULE_extensionDefault)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(333)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ASN_3gppParserEXTENSIBILITY_LITERAL {
		{
			p.SetState(331)
			p.Match(ASN_3gppParserEXTENSIBILITY_LITERAL)
		}
		{
			p.SetState(332)
			p.Match(ASN_3gppParserIMPLIED_LITERAL)
		}

	}

	return localctx
}

// IModuleBodyContext is an interface to support dynamic dispatch.
type IModuleBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModuleBodyContext differentiates from other interfaces.
	IsModuleBodyContext()
}

type ModuleBodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModuleBodyContext() *ModuleBodyContext {
	var p = new(ModuleBodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_moduleBody
	return p
}

func (*ModuleBodyContext) IsModuleBodyContext() {}

func NewModuleBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModuleBodyContext {
	var p = new(ModuleBodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_moduleBody

	return p
}

func (s *ModuleBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *ModuleBodyContext) Exports() IExportsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExportsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExportsContext)
}

func (s *ModuleBodyContext) Imports() IImportsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImportsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImportsContext)
}

func (s *ModuleBodyContext) AssignmentList() IAssignmentListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssignmentListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssignmentListContext)
}

func (s *ModuleBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModuleBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModuleBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterModuleBody(s)
	}
}

func (s *ModuleBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitModuleBody(s)
	}
}

func (p *ASN_3gppParser) ModuleBody() (localctx IModuleBodyContext) {
	localctx = NewModuleBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, ASN_3gppParserRULE_moduleBody)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(339)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ASN_3gppParserIMPORTS_LITERAL || _la == ASN_3gppParserEXPORTS_LITERAL || _la == ASN_3gppParserIDENTIFIER {
		{
			p.SetState(335)
			p.Exports()
		}
		{
			p.SetState(336)
			p.Imports()
		}
		{
			p.SetState(337)
			p.AssignmentList()
		}

	}

	return localctx
}

// IExportsContext is an interface to support dynamic dispatch.
type IExportsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExportsContext differentiates from other interfaces.
	IsExportsContext()
}

type ExportsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExportsContext() *ExportsContext {
	var p = new(ExportsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_exports
	return p
}

func (*ExportsContext) IsExportsContext() {}

func NewExportsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExportsContext {
	var p = new(ExportsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_exports

	return p
}

func (s *ExportsContext) GetParser() antlr.Parser { return s.parser }

func (s *ExportsContext) EXPORTS_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserEXPORTS_LITERAL, 0)
}

func (s *ExportsContext) SymbolsExported() ISymbolsExportedContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISymbolsExportedContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISymbolsExportedContext)
}

func (s *ExportsContext) SEMI_COLON() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserSEMI_COLON, 0)
}

func (s *ExportsContext) ALL_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserALL_LITERAL, 0)
}

func (s *ExportsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExportsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExportsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterExports(s)
	}
}

func (s *ExportsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitExports(s)
	}
}

func (p *ASN_3gppParser) Exports() (localctx IExportsContext) {
	localctx = NewExportsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, ASN_3gppParserRULE_exports)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(348)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 6, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(341)
			p.Match(ASN_3gppParserEXPORTS_LITERAL)
		}
		{
			p.SetState(342)
			p.SymbolsExported()
		}
		{
			p.SetState(343)
			p.Match(ASN_3gppParserSEMI_COLON)
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 6, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(345)
			p.Match(ASN_3gppParserEXPORTS_LITERAL)
		}
		{
			p.SetState(346)
			p.Match(ASN_3gppParserALL_LITERAL)
		}
		{
			p.SetState(347)
			p.Match(ASN_3gppParserSEMI_COLON)
		}

	}

	return localctx
}

// ISymbolsExportedContext is an interface to support dynamic dispatch.
type ISymbolsExportedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSymbolsExportedContext differentiates from other interfaces.
	IsSymbolsExportedContext()
}

type SymbolsExportedContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySymbolsExportedContext() *SymbolsExportedContext {
	var p = new(SymbolsExportedContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_symbolsExported
	return p
}

func (*SymbolsExportedContext) IsSymbolsExportedContext() {}

func NewSymbolsExportedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SymbolsExportedContext {
	var p = new(SymbolsExportedContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_symbolsExported

	return p
}

func (s *SymbolsExportedContext) GetParser() antlr.Parser { return s.parser }

func (s *SymbolsExportedContext) SymbolList() ISymbolListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISymbolListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISymbolListContext)
}

func (s *SymbolsExportedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SymbolsExportedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SymbolsExportedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterSymbolsExported(s)
	}
}

func (s *SymbolsExportedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitSymbolsExported(s)
	}
}

func (p *ASN_3gppParser) SymbolsExported() (localctx ISymbolsExportedContext) {
	localctx = NewSymbolsExportedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, ASN_3gppParserRULE_symbolsExported)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(351)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ASN_3gppParserIDENTIFIER {
		{
			p.SetState(350)
			p.SymbolList()
		}

	}

	return localctx
}

// IImportsContext is an interface to support dynamic dispatch.
type IImportsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImportsContext differentiates from other interfaces.
	IsImportsContext()
}

type ImportsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportsContext() *ImportsContext {
	var p = new(ImportsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_imports
	return p
}

func (*ImportsContext) IsImportsContext() {}

func NewImportsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportsContext {
	var p = new(ImportsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_imports

	return p
}

func (s *ImportsContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportsContext) IMPORTS_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserIMPORTS_LITERAL, 0)
}

func (s *ImportsContext) SymbolsImported() ISymbolsImportedContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISymbolsImportedContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISymbolsImportedContext)
}

func (s *ImportsContext) SEMI_COLON() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserSEMI_COLON, 0)
}

func (s *ImportsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterImports(s)
	}
}

func (s *ImportsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitImports(s)
	}
}

func (p *ASN_3gppParser) Imports() (localctx IImportsContext) {
	localctx = NewImportsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, ASN_3gppParserRULE_imports)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(357)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ASN_3gppParserIMPORTS_LITERAL {
		{
			p.SetState(353)
			p.Match(ASN_3gppParserIMPORTS_LITERAL)
		}
		{
			p.SetState(354)
			p.SymbolsImported()
		}
		{
			p.SetState(355)
			p.Match(ASN_3gppParserSEMI_COLON)
		}

	}

	return localctx
}

// ISymbolsImportedContext is an interface to support dynamic dispatch.
type ISymbolsImportedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSymbolsImportedContext differentiates from other interfaces.
	IsSymbolsImportedContext()
}

type SymbolsImportedContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySymbolsImportedContext() *SymbolsImportedContext {
	var p = new(SymbolsImportedContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_symbolsImported
	return p
}

func (*SymbolsImportedContext) IsSymbolsImportedContext() {}

func NewSymbolsImportedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SymbolsImportedContext {
	var p = new(SymbolsImportedContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_symbolsImported

	return p
}

func (s *SymbolsImportedContext) GetParser() antlr.Parser { return s.parser }

func (s *SymbolsImportedContext) SymbolsFromModuleList() ISymbolsFromModuleListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISymbolsFromModuleListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISymbolsFromModuleListContext)
}

func (s *SymbolsImportedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SymbolsImportedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SymbolsImportedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterSymbolsImported(s)
	}
}

func (s *SymbolsImportedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitSymbolsImported(s)
	}
}

func (p *ASN_3gppParser) SymbolsImported() (localctx ISymbolsImportedContext) {
	localctx = NewSymbolsImportedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, ASN_3gppParserRULE_symbolsImported)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(360)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ASN_3gppParserIDENTIFIER {
		{
			p.SetState(359)
			p.SymbolsFromModuleList()
		}

	}

	return localctx
}

// ISymbolsFromModuleListContext is an interface to support dynamic dispatch.
type ISymbolsFromModuleListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSymbolsFromModuleListContext differentiates from other interfaces.
	IsSymbolsFromModuleListContext()
}

type SymbolsFromModuleListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySymbolsFromModuleListContext() *SymbolsFromModuleListContext {
	var p = new(SymbolsFromModuleListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_symbolsFromModuleList
	return p
}

func (*SymbolsFromModuleListContext) IsSymbolsFromModuleListContext() {}

func NewSymbolsFromModuleListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SymbolsFromModuleListContext {
	var p = new(SymbolsFromModuleListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_symbolsFromModuleList

	return p
}

func (s *SymbolsFromModuleListContext) GetParser() antlr.Parser { return s.parser }

func (s *SymbolsFromModuleListContext) AllSymbolsFromModule() []ISymbolsFromModuleContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISymbolsFromModuleContext)(nil)).Elem())
	var tst = make([]ISymbolsFromModuleContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISymbolsFromModuleContext)
		}
	}

	return tst
}

func (s *SymbolsFromModuleListContext) SymbolsFromModule(i int) ISymbolsFromModuleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISymbolsFromModuleContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISymbolsFromModuleContext)
}

func (s *SymbolsFromModuleListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SymbolsFromModuleListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SymbolsFromModuleListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterSymbolsFromModuleList(s)
	}
}

func (s *SymbolsFromModuleListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitSymbolsFromModuleList(s)
	}
}

func (p *ASN_3gppParser) SymbolsFromModuleList() (localctx ISymbolsFromModuleListContext) {
	localctx = NewSymbolsFromModuleListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, ASN_3gppParserRULE_symbolsFromModuleList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(362)
		p.SymbolsFromModule()
	}

	p.SetState(366)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ASN_3gppParserIDENTIFIER {
		{
			p.SetState(363)
			p.SymbolsFromModule()
		}

		p.SetState(368)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ISymbolsFromModuleContext is an interface to support dynamic dispatch.
type ISymbolsFromModuleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSymbolsFromModuleContext differentiates from other interfaces.
	IsSymbolsFromModuleContext()
}

type SymbolsFromModuleContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySymbolsFromModuleContext() *SymbolsFromModuleContext {
	var p = new(SymbolsFromModuleContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_symbolsFromModule
	return p
}

func (*SymbolsFromModuleContext) IsSymbolsFromModuleContext() {}

func NewSymbolsFromModuleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SymbolsFromModuleContext {
	var p = new(SymbolsFromModuleContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_symbolsFromModule

	return p
}

func (s *SymbolsFromModuleContext) GetParser() antlr.Parser { return s.parser }

func (s *SymbolsFromModuleContext) SymbolList() ISymbolListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISymbolListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISymbolListContext)
}

func (s *SymbolsFromModuleContext) FROM_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserFROM_LITERAL, 0)
}

func (s *SymbolsFromModuleContext) GlobalModuleReference() IGlobalModuleReferenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGlobalModuleReferenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGlobalModuleReferenceContext)
}

func (s *SymbolsFromModuleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SymbolsFromModuleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SymbolsFromModuleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterSymbolsFromModule(s)
	}
}

func (s *SymbolsFromModuleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitSymbolsFromModule(s)
	}
}

func (p *ASN_3gppParser) SymbolsFromModule() (localctx ISymbolsFromModuleContext) {
	localctx = NewSymbolsFromModuleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, ASN_3gppParserRULE_symbolsFromModule)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(369)
		p.SymbolList()
	}
	{
		p.SetState(370)
		p.Match(ASN_3gppParserFROM_LITERAL)
	}
	{
		p.SetState(371)
		p.GlobalModuleReference()
	}

	return localctx
}

// IGlobalModuleReferenceContext is an interface to support dynamic dispatch.
type IGlobalModuleReferenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGlobalModuleReferenceContext differentiates from other interfaces.
	IsGlobalModuleReferenceContext()
}

type GlobalModuleReferenceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGlobalModuleReferenceContext() *GlobalModuleReferenceContext {
	var p = new(GlobalModuleReferenceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_globalModuleReference
	return p
}

func (*GlobalModuleReferenceContext) IsGlobalModuleReferenceContext() {}

func NewGlobalModuleReferenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GlobalModuleReferenceContext {
	var p = new(GlobalModuleReferenceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_globalModuleReference

	return p
}

func (s *GlobalModuleReferenceContext) GetParser() antlr.Parser { return s.parser }

func (s *GlobalModuleReferenceContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserIDENTIFIER, 0)
}

func (s *GlobalModuleReferenceContext) AssignedIdentifier() IAssignedIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssignedIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssignedIdentifierContext)
}

func (s *GlobalModuleReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GlobalModuleReferenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GlobalModuleReferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterGlobalModuleReference(s)
	}
}

func (s *GlobalModuleReferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitGlobalModuleReference(s)
	}
}

func (p *ASN_3gppParser) GlobalModuleReference() (localctx IGlobalModuleReferenceContext) {
	localctx = NewGlobalModuleReferenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, ASN_3gppParserRULE_globalModuleReference)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(373)
		p.Match(ASN_3gppParserIDENTIFIER)
	}
	{
		p.SetState(374)
		p.AssignedIdentifier()
	}

	return localctx
}

// IAssignedIdentifierContext is an interface to support dynamic dispatch.
type IAssignedIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssignedIdentifierContext differentiates from other interfaces.
	IsAssignedIdentifierContext()
}

type AssignedIdentifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignedIdentifierContext() *AssignedIdentifierContext {
	var p = new(AssignedIdentifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_assignedIdentifier
	return p
}

func (*AssignedIdentifierContext) IsAssignedIdentifierContext() {}

func NewAssignedIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignedIdentifierContext {
	var p = new(AssignedIdentifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_assignedIdentifier

	return p
}

func (s *AssignedIdentifierContext) GetParser() antlr.Parser { return s.parser }
func (s *AssignedIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignedIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignedIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterAssignedIdentifier(s)
	}
}

func (s *AssignedIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitAssignedIdentifier(s)
	}
}

func (p *ASN_3gppParser) AssignedIdentifier() (localctx IAssignedIdentifierContext) {
	localctx = NewAssignedIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, ASN_3gppParserRULE_assignedIdentifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)

	return localctx
}

// ISymbolListContext is an interface to support dynamic dispatch.
type ISymbolListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSymbolListContext differentiates from other interfaces.
	IsSymbolListContext()
}

type SymbolListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySymbolListContext() *SymbolListContext {
	var p = new(SymbolListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_symbolList
	return p
}

func (*SymbolListContext) IsSymbolListContext() {}

func NewSymbolListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SymbolListContext {
	var p = new(SymbolListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_symbolList

	return p
}

func (s *SymbolListContext) GetParser() antlr.Parser { return s.parser }

func (s *SymbolListContext) AllSymbol() []ISymbolContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISymbolContext)(nil)).Elem())
	var tst = make([]ISymbolContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISymbolContext)
		}
	}

	return tst
}

func (s *SymbolListContext) Symbol(i int) ISymbolContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISymbolContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISymbolContext)
}

func (s *SymbolListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ASN_3gppParserCOMMA)
}

func (s *SymbolListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserCOMMA, i)
}

func (s *SymbolListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SymbolListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SymbolListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterSymbolList(s)
	}
}

func (s *SymbolListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitSymbolList(s)
	}
}

func (p *ASN_3gppParser) SymbolList() (localctx ISymbolListContext) {
	localctx = NewSymbolListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, ASN_3gppParserRULE_symbolList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(378)
		p.Symbol()
	}

	p.SetState(383)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ASN_3gppParserCOMMA {
		{
			p.SetState(379)
			p.Match(ASN_3gppParserCOMMA)
		}
		{
			p.SetState(380)
			p.Symbol()
		}

		p.SetState(385)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ISymbolContext is an interface to support dynamic dispatch.
type ISymbolContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSymbolContext differentiates from other interfaces.
	IsSymbolContext()
}

type SymbolContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySymbolContext() *SymbolContext {
	var p = new(SymbolContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_symbol
	return p
}

func (*SymbolContext) IsSymbolContext() {}

func NewSymbolContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SymbolContext {
	var p = new(SymbolContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_symbol

	return p
}

func (s *SymbolContext) GetParser() antlr.Parser { return s.parser }

func (s *SymbolContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserIDENTIFIER, 0)
}

func (s *SymbolContext) L_BRACE() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserL_BRACE, 0)
}

func (s *SymbolContext) R_BRACE() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserR_BRACE, 0)
}

func (s *SymbolContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SymbolContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SymbolContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterSymbol(s)
	}
}

func (s *SymbolContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitSymbol(s)
	}
}

func (p *ASN_3gppParser) Symbol() (localctx ISymbolContext) {
	localctx = NewSymbolContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, ASN_3gppParserRULE_symbol)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(386)
		p.Match(ASN_3gppParserIDENTIFIER)
	}
	p.SetState(389)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ASN_3gppParserL_BRACE {
		{
			p.SetState(387)
			p.Match(ASN_3gppParserL_BRACE)
		}
		{
			p.SetState(388)
			p.Match(ASN_3gppParserR_BRACE)
		}

	}

	return localctx
}

// IAssignmentListContext is an interface to support dynamic dispatch.
type IAssignmentListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssignmentListContext differentiates from other interfaces.
	IsAssignmentListContext()
}

type AssignmentListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignmentListContext() *AssignmentListContext {
	var p = new(AssignmentListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_assignmentList
	return p
}

func (*AssignmentListContext) IsAssignmentListContext() {}

func NewAssignmentListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentListContext {
	var p = new(AssignmentListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_assignmentList

	return p
}

func (s *AssignmentListContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentListContext) AllAssignment() []IAssignmentContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAssignmentContext)(nil)).Elem())
	var tst = make([]IAssignmentContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAssignmentContext)
		}
	}

	return tst
}

func (s *AssignmentListContext) Assignment(i int) IAssignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssignmentContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAssignmentContext)
}

func (s *AssignmentListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignmentListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterAssignmentList(s)
	}
}

func (s *AssignmentListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitAssignmentList(s)
	}
}

func (p *ASN_3gppParser) AssignmentList() (localctx IAssignmentListContext) {
	localctx = NewAssignmentListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, ASN_3gppParserRULE_assignmentList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(391)
		p.Assignment()
	}

	p.SetState(395)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ASN_3gppParserIDENTIFIER {
		{
			p.SetState(392)
			p.Assignment()
		}

		p.SetState(397)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IAssignmentContext is an interface to support dynamic dispatch.
type IAssignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssignmentContext differentiates from other interfaces.
	IsAssignmentContext()
}

type AssignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignmentContext() *AssignmentContext {
	var p = new(AssignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_assignment
	return p
}

func (*AssignmentContext) IsAssignmentContext() {}

func NewAssignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentContext {
	var p = new(AssignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_assignment

	return p
}

func (s *AssignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserIDENTIFIER, 0)
}

func (s *AssignmentContext) ValueAssignment() IValueAssignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueAssignmentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueAssignmentContext)
}

func (s *AssignmentContext) TypeAssignment() ITypeAssignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeAssignmentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeAssignmentContext)
}

func (s *AssignmentContext) ParameterizedAssignment() IParameterizedAssignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameterizedAssignmentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameterizedAssignmentContext)
}

func (s *AssignmentContext) ObjectClassAssignment() IObjectClassAssignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObjectClassAssignmentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObjectClassAssignmentContext)
}

func (s *AssignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterAssignment(s)
	}
}

func (s *AssignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitAssignment(s)
	}
}

func (p *ASN_3gppParser) Assignment() (localctx IAssignmentContext) {
	localctx = NewAssignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, ASN_3gppParserRULE_assignment)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(398)
		p.Match(ASN_3gppParserIDENTIFIER)
	}
	p.SetState(403)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 14, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(399)
			p.ValueAssignment()
		}

	case 2:
		{
			p.SetState(400)
			p.TypeAssignment()
		}

	case 3:
		{
			p.SetState(401)
			p.ParameterizedAssignment()
		}

	case 4:
		{
			p.SetState(402)
			p.ObjectClassAssignment()
		}

	}

	return localctx
}

// ISequenceTypeContext is an interface to support dynamic dispatch.
type ISequenceTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSequenceTypeContext differentiates from other interfaces.
	IsSequenceTypeContext()
}

type SequenceTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySequenceTypeContext() *SequenceTypeContext {
	var p = new(SequenceTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_sequenceType
	return p
}

func (*SequenceTypeContext) IsSequenceTypeContext() {}

func NewSequenceTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SequenceTypeContext {
	var p = new(SequenceTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_sequenceType

	return p
}

func (s *SequenceTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *SequenceTypeContext) SEQUENCE_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserSEQUENCE_LITERAL, 0)
}

func (s *SequenceTypeContext) L_BRACE() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserL_BRACE, 0)
}

func (s *SequenceTypeContext) R_BRACE() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserR_BRACE, 0)
}

func (s *SequenceTypeContext) ExtensionAndException() IExtensionAndExceptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExtensionAndExceptionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExtensionAndExceptionContext)
}

func (s *SequenceTypeContext) OptionalExtensionMarker() IOptionalExtensionMarkerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOptionalExtensionMarkerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOptionalExtensionMarkerContext)
}

func (s *SequenceTypeContext) ComponentTypeLists() IComponentTypeListsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComponentTypeListsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComponentTypeListsContext)
}

func (s *SequenceTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SequenceTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SequenceTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterSequenceType(s)
	}
}

func (s *SequenceTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitSequenceType(s)
	}
}

func (p *ASN_3gppParser) SequenceType() (localctx ISequenceTypeContext) {
	localctx = NewSequenceTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, ASN_3gppParserRULE_sequenceType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(405)
		p.Match(ASN_3gppParserSEQUENCE_LITERAL)
	}
	{
		p.SetState(406)
		p.Match(ASN_3gppParserL_BRACE)
	}
	p.SetState(411)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 15, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(407)
			p.ExtensionAndException()
		}
		{
			p.SetState(408)
			p.OptionalExtensionMarker()
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 15, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(410)
			p.ComponentTypeLists()
		}

	}
	{
		p.SetState(413)
		p.Match(ASN_3gppParserR_BRACE)
	}

	return localctx
}

// IExtensionAndExceptionContext is an interface to support dynamic dispatch.
type IExtensionAndExceptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExtensionAndExceptionContext differentiates from other interfaces.
	IsExtensionAndExceptionContext()
}

type ExtensionAndExceptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExtensionAndExceptionContext() *ExtensionAndExceptionContext {
	var p = new(ExtensionAndExceptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_extensionAndException
	return p
}

func (*ExtensionAndExceptionContext) IsExtensionAndExceptionContext() {}

func NewExtensionAndExceptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExtensionAndExceptionContext {
	var p = new(ExtensionAndExceptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_extensionAndException

	return p
}

func (s *ExtensionAndExceptionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExtensionAndExceptionContext) ELLIPSIS() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserELLIPSIS, 0)
}

func (s *ExtensionAndExceptionContext) ExceptionSpec() IExceptionSpecContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExceptionSpecContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExceptionSpecContext)
}

func (s *ExtensionAndExceptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExtensionAndExceptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExtensionAndExceptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterExtensionAndException(s)
	}
}

func (s *ExtensionAndExceptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitExtensionAndException(s)
	}
}

func (p *ASN_3gppParser) ExtensionAndException() (localctx IExtensionAndExceptionContext) {
	localctx = NewExtensionAndExceptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, ASN_3gppParserRULE_extensionAndException)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(415)
		p.Match(ASN_3gppParserELLIPSIS)
	}
	p.SetState(417)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ASN_3gppParserEXCLAM {
		{
			p.SetState(416)
			p.ExceptionSpec()
		}

	}

	return localctx
}

// IOptionalExtensionMarkerContext is an interface to support dynamic dispatch.
type IOptionalExtensionMarkerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOptionalExtensionMarkerContext differentiates from other interfaces.
	IsOptionalExtensionMarkerContext()
}

type OptionalExtensionMarkerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOptionalExtensionMarkerContext() *OptionalExtensionMarkerContext {
	var p = new(OptionalExtensionMarkerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_optionalExtensionMarker
	return p
}

func (*OptionalExtensionMarkerContext) IsOptionalExtensionMarkerContext() {}

func NewOptionalExtensionMarkerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OptionalExtensionMarkerContext {
	var p = new(OptionalExtensionMarkerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_optionalExtensionMarker

	return p
}

func (s *OptionalExtensionMarkerContext) GetParser() antlr.Parser { return s.parser }

func (s *OptionalExtensionMarkerContext) COMMA() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserCOMMA, 0)
}

func (s *OptionalExtensionMarkerContext) ELLIPSIS() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserELLIPSIS, 0)
}

func (s *OptionalExtensionMarkerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OptionalExtensionMarkerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OptionalExtensionMarkerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterOptionalExtensionMarker(s)
	}
}

func (s *OptionalExtensionMarkerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitOptionalExtensionMarker(s)
	}
}

func (p *ASN_3gppParser) OptionalExtensionMarker() (localctx IOptionalExtensionMarkerContext) {
	localctx = NewOptionalExtensionMarkerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, ASN_3gppParserRULE_optionalExtensionMarker)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(421)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ASN_3gppParserCOMMA {
		{
			p.SetState(419)
			p.Match(ASN_3gppParserCOMMA)
		}
		{
			p.SetState(420)
			p.Match(ASN_3gppParserELLIPSIS)
		}

	}

	return localctx
}

// IComponentTypeListsContext is an interface to support dynamic dispatch.
type IComponentTypeListsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComponentTypeListsContext differentiates from other interfaces.
	IsComponentTypeListsContext()
}

type ComponentTypeListsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComponentTypeListsContext() *ComponentTypeListsContext {
	var p = new(ComponentTypeListsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_componentTypeLists
	return p
}

func (*ComponentTypeListsContext) IsComponentTypeListsContext() {}

func NewComponentTypeListsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComponentTypeListsContext {
	var p = new(ComponentTypeListsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_componentTypeLists

	return p
}

func (s *ComponentTypeListsContext) GetParser() antlr.Parser { return s.parser }

func (s *ComponentTypeListsContext) AllRootComponentTypeList() []IRootComponentTypeListContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IRootComponentTypeListContext)(nil)).Elem())
	var tst = make([]IRootComponentTypeListContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IRootComponentTypeListContext)
		}
	}

	return tst
}

func (s *ComponentTypeListsContext) RootComponentTypeList(i int) IRootComponentTypeListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRootComponentTypeListContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IRootComponentTypeListContext)
}

func (s *ComponentTypeListsContext) AllTag() []ITagContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITagContext)(nil)).Elem())
	var tst = make([]ITagContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITagContext)
		}
	}

	return tst
}

func (s *ComponentTypeListsContext) Tag(i int) ITagContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITagContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITagContext)
}

func (s *ComponentTypeListsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ASN_3gppParserCOMMA)
}

func (s *ComponentTypeListsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserCOMMA, i)
}

func (s *ComponentTypeListsContext) ExtensionAndException() IExtensionAndExceptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExtensionAndExceptionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExtensionAndExceptionContext)
}

func (s *ComponentTypeListsContext) ExtensionAdditions() IExtensionAdditionsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExtensionAdditionsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExtensionAdditionsContext)
}

func (s *ComponentTypeListsContext) OptionalExtensionMarker() IOptionalExtensionMarkerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOptionalExtensionMarkerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOptionalExtensionMarkerContext)
}

func (s *ComponentTypeListsContext) EXTENSTIONENDMARKER() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserEXTENSTIONENDMARKER, 0)
}

func (s *ComponentTypeListsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComponentTypeListsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComponentTypeListsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterComponentTypeLists(s)
	}
}

func (s *ComponentTypeListsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitComponentTypeLists(s)
	}
}

func (p *ASN_3gppParser) ComponentTypeLists() (localctx IComponentTypeListsContext) {
	localctx = NewComponentTypeListsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, ASN_3gppParserRULE_componentTypeLists)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(453)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ASN_3gppParserCOMPONENTS_LITERAL, ASN_3gppParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(423)
			p.RootComponentTypeList()
		}
		p.SetState(440)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case ASN_3gppParserNEED_LITERAL, ASN_3gppParserCOND_LITERAL, ASN_3gppParserINVALID_TAG:
			{
				p.SetState(424)
				p.Tag()
			}

		case ASN_3gppParserCOMMA:
			{
				p.SetState(425)
				p.Match(ASN_3gppParserCOMMA)
			}
			p.SetState(427)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ASN_3gppParserNEED_LITERAL)|(1<<ASN_3gppParserCOND_LITERAL)|(1<<ASN_3gppParserINVALID_TAG))) != 0 {
				{
					p.SetState(426)
					p.Tag()
				}

			}
			{
				p.SetState(429)
				p.ExtensionAndException()
			}
			{
				p.SetState(430)
				p.ExtensionAdditions()
			}
			p.SetState(438)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case ASN_3gppParserR_BRACE, ASN_3gppParserCOMMA:
				{
					p.SetState(431)
					p.OptionalExtensionMarker()
				}

			case ASN_3gppParserEXTENSTIONENDMARKER:
				{
					p.SetState(432)
					p.Match(ASN_3gppParserEXTENSTIONENDMARKER)
				}
				{
					p.SetState(433)
					p.Match(ASN_3gppParserCOMMA)
				}
				{
					p.SetState(434)
					p.RootComponentTypeList()
				}
				p.SetState(436)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ASN_3gppParserNEED_LITERAL)|(1<<ASN_3gppParserCOND_LITERAL)|(1<<ASN_3gppParserINVALID_TAG))) != 0 {
					{
						p.SetState(435)
						p.Tag()
					}

				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

		case ASN_3gppParserR_BRACE:

		default:
		}

	case ASN_3gppParserELLIPSIS:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(442)
			p.ExtensionAndException()
		}
		{
			p.SetState(443)
			p.ExtensionAdditions()
		}
		p.SetState(451)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case ASN_3gppParserR_BRACE, ASN_3gppParserCOMMA:
			{
				p.SetState(444)
				p.OptionalExtensionMarker()
			}

		case ASN_3gppParserEXTENSTIONENDMARKER:
			{
				p.SetState(445)
				p.Match(ASN_3gppParserEXTENSTIONENDMARKER)
			}
			{
				p.SetState(446)
				p.Match(ASN_3gppParserCOMMA)
			}
			{
				p.SetState(447)
				p.RootComponentTypeList()
			}
			p.SetState(449)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ASN_3gppParserNEED_LITERAL)|(1<<ASN_3gppParserCOND_LITERAL)|(1<<ASN_3gppParserINVALID_TAG))) != 0 {
				{
					p.SetState(448)
					p.Tag()
				}

			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IRootComponentTypeListContext is an interface to support dynamic dispatch.
type IRootComponentTypeListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRootComponentTypeListContext differentiates from other interfaces.
	IsRootComponentTypeListContext()
}

type RootComponentTypeListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRootComponentTypeListContext() *RootComponentTypeListContext {
	var p = new(RootComponentTypeListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_rootComponentTypeList
	return p
}

func (*RootComponentTypeListContext) IsRootComponentTypeListContext() {}

func NewRootComponentTypeListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RootComponentTypeListContext {
	var p = new(RootComponentTypeListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_rootComponentTypeList

	return p
}

func (s *RootComponentTypeListContext) GetParser() antlr.Parser { return s.parser }

func (s *RootComponentTypeListContext) ComponentTypeList() IComponentTypeListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComponentTypeListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComponentTypeListContext)
}

func (s *RootComponentTypeListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RootComponentTypeListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RootComponentTypeListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterRootComponentTypeList(s)
	}
}

func (s *RootComponentTypeListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitRootComponentTypeList(s)
	}
}

func (p *ASN_3gppParser) RootComponentTypeList() (localctx IRootComponentTypeListContext) {
	localctx = NewRootComponentTypeListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, ASN_3gppParserRULE_rootComponentTypeList)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(455)
		p.ComponentTypeList()
	}

	return localctx
}

// IComponentTypeListContext is an interface to support dynamic dispatch.
type IComponentTypeListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComponentTypeListContext differentiates from other interfaces.
	IsComponentTypeListContext()
}

type ComponentTypeListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComponentTypeListContext() *ComponentTypeListContext {
	var p = new(ComponentTypeListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_componentTypeList
	return p
}

func (*ComponentTypeListContext) IsComponentTypeListContext() {}

func NewComponentTypeListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComponentTypeListContext {
	var p = new(ComponentTypeListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_componentTypeList

	return p
}

func (s *ComponentTypeListContext) GetParser() antlr.Parser { return s.parser }

func (s *ComponentTypeListContext) AllComponentType() []IComponentTypeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IComponentTypeContext)(nil)).Elem())
	var tst = make([]IComponentTypeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IComponentTypeContext)
		}
	}

	return tst
}

func (s *ComponentTypeListContext) ComponentType(i int) IComponentTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComponentTypeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IComponentTypeContext)
}

func (s *ComponentTypeListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ASN_3gppParserCOMMA)
}

func (s *ComponentTypeListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserCOMMA, i)
}

func (s *ComponentTypeListContext) AllTag() []ITagContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITagContext)(nil)).Elem())
	var tst = make([]ITagContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITagContext)
		}
	}

	return tst
}

func (s *ComponentTypeListContext) Tag(i int) ITagContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITagContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITagContext)
}

func (s *ComponentTypeListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComponentTypeListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComponentTypeListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterComponentTypeList(s)
	}
}

func (s *ComponentTypeListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitComponentTypeList(s)
	}
}

func (p *ASN_3gppParser) ComponentTypeList() (localctx IComponentTypeListContext) {
	localctx = NewComponentTypeListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, ASN_3gppParserRULE_componentTypeList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(457)
		p.ComponentType()
	}

	p.SetState(465)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 26, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(458)
				p.Match(ASN_3gppParserCOMMA)
			}
			p.SetState(460)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ASN_3gppParserNEED_LITERAL)|(1<<ASN_3gppParserCOND_LITERAL)|(1<<ASN_3gppParserINVALID_TAG))) != 0 {
				{
					p.SetState(459)
					p.Tag()
				}

			}
			{
				p.SetState(462)
				p.ComponentType()
			}

		}
		p.SetState(467)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 26, p.GetParserRuleContext())
	}

	return localctx
}

// IComponentTypeContext is an interface to support dynamic dispatch.
type IComponentTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComponentTypeContext differentiates from other interfaces.
	IsComponentTypeContext()
}

type ComponentTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComponentTypeContext() *ComponentTypeContext {
	var p = new(ComponentTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_componentType
	return p
}

func (*ComponentTypeContext) IsComponentTypeContext() {}

func NewComponentTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComponentTypeContext {
	var p = new(ComponentTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_componentType

	return p
}

func (s *ComponentTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ComponentTypeContext) NamedType() INamedTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INamedTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INamedTypeContext)
}

func (s *ComponentTypeContext) OPTIONAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserOPTIONAL_LITERAL, 0)
}

func (s *ComponentTypeContext) DEFAULT_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserDEFAULT_LITERAL, 0)
}

func (s *ComponentTypeContext) Value() IValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueContext)
}

func (s *ComponentTypeContext) COMPONENTS_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserCOMPONENTS_LITERAL, 0)
}

func (s *ComponentTypeContext) OF_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserOF_LITERAL, 0)
}

func (s *ComponentTypeContext) AsnType() IAsnTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAsnTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAsnTypeContext)
}

func (s *ComponentTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComponentTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComponentTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterComponentType(s)
	}
}

func (s *ComponentTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitComponentType(s)
	}
}

func (p *ASN_3gppParser) ComponentType() (localctx IComponentTypeContext) {
	localctx = NewComponentTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, ASN_3gppParserRULE_componentType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(477)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ASN_3gppParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(468)
			p.NamedType()
		}
		p.SetState(472)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case ASN_3gppParserOPTIONAL_LITERAL:
			{
				p.SetState(469)
				p.Match(ASN_3gppParserOPTIONAL_LITERAL)
			}

		case ASN_3gppParserDEFAULT_LITERAL:
			{
				p.SetState(470)
				p.Match(ASN_3gppParserDEFAULT_LITERAL)
			}
			{
				p.SetState(471)
				p.Value()
			}

		case ASN_3gppParserNEED_LITERAL, ASN_3gppParserCOND_LITERAL, ASN_3gppParserINVALID_TAG, ASN_3gppParserR_BRACE, ASN_3gppParserCOMMA, ASN_3gppParserDOUBLE_R_BRACKET, ASN_3gppParserEXTENSTIONENDMARKER:

		default:
		}

	case ASN_3gppParserCOMPONENTS_LITERAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(474)
			p.Match(ASN_3gppParserCOMPONENTS_LITERAL)
		}
		{
			p.SetState(475)
			p.Match(ASN_3gppParserOF_LITERAL)
		}
		{
			p.SetState(476)
			p.AsnType()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ITagContext is an interface to support dynamic dispatch.
type ITagContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTagContext differentiates from other interfaces.
	IsTagContext()
}

type TagContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTagContext() *TagContext {
	var p = new(TagContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_tag
	return p
}

func (*TagContext) IsTagContext() {}

func NewTagContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TagContext {
	var p = new(TagContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_tag

	return p
}

func (s *TagContext) GetParser() antlr.Parser { return s.parser }

func (s *TagContext) NeedTag() INeedTagContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INeedTagContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INeedTagContext)
}

func (s *TagContext) CondTag() ICondTagContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICondTagContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICondTagContext)
}

func (s *TagContext) INVALID_TAG() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserINVALID_TAG, 0)
}

func (s *TagContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TagContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TagContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterTag(s)
	}
}

func (s *TagContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitTag(s)
	}
}

func (p *ASN_3gppParser) Tag() (localctx ITagContext) {
	localctx = NewTagContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, ASN_3gppParserRULE_tag)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(482)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ASN_3gppParserNEED_LITERAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(479)
			p.NeedTag()
		}

	case ASN_3gppParserCOND_LITERAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(480)
			p.CondTag()
		}

	case ASN_3gppParserINVALID_TAG:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(481)
			p.Match(ASN_3gppParserINVALID_TAG)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// INeedTagContext is an interface to support dynamic dispatch.
type INeedTagContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNeedTagContext differentiates from other interfaces.
	IsNeedTagContext()
}

type NeedTagContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNeedTagContext() *NeedTagContext {
	var p = new(NeedTagContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_needTag
	return p
}

func (*NeedTagContext) IsNeedTagContext() {}

func NewNeedTagContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NeedTagContext {
	var p = new(NeedTagContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_needTag

	return p
}

func (s *NeedTagContext) GetParser() antlr.Parser { return s.parser }

func (s *NeedTagContext) NEED_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserNEED_LITERAL, 0)
}

func (s *NeedTagContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserIDENTIFIER, 0)
}

func (s *NeedTagContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NeedTagContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NeedTagContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterNeedTag(s)
	}
}

func (s *NeedTagContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitNeedTag(s)
	}
}

func (p *ASN_3gppParser) NeedTag() (localctx INeedTagContext) {
	localctx = NewNeedTagContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, ASN_3gppParserRULE_needTag)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(484)
		p.Match(ASN_3gppParserNEED_LITERAL)
	}
	{
		p.SetState(485)
		p.Match(ASN_3gppParserIDENTIFIER)
	}

	return localctx
}

// ICondTagContext is an interface to support dynamic dispatch.
type ICondTagContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCondTagContext differentiates from other interfaces.
	IsCondTagContext()
}

type CondTagContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCondTagContext() *CondTagContext {
	var p = new(CondTagContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_condTag
	return p
}

func (*CondTagContext) IsCondTagContext() {}

func NewCondTagContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CondTagContext {
	var p = new(CondTagContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_condTag

	return p
}

func (s *CondTagContext) GetParser() antlr.Parser { return s.parser }

func (s *CondTagContext) COND_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserCOND_LITERAL, 0)
}

func (s *CondTagContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserIDENTIFIER, 0)
}

func (s *CondTagContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CondTagContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CondTagContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterCondTag(s)
	}
}

func (s *CondTagContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitCondTag(s)
	}
}

func (p *ASN_3gppParser) CondTag() (localctx ICondTagContext) {
	localctx = NewCondTagContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, ASN_3gppParserRULE_condTag)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(487)
		p.Match(ASN_3gppParserCOND_LITERAL)
	}
	{
		p.SetState(488)
		p.Match(ASN_3gppParserIDENTIFIER)
	}

	return localctx
}

// IExtensionAdditionsContext is an interface to support dynamic dispatch.
type IExtensionAdditionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExtensionAdditionsContext differentiates from other interfaces.
	IsExtensionAdditionsContext()
}

type ExtensionAdditionsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExtensionAdditionsContext() *ExtensionAdditionsContext {
	var p = new(ExtensionAdditionsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_extensionAdditions
	return p
}

func (*ExtensionAdditionsContext) IsExtensionAdditionsContext() {}

func NewExtensionAdditionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExtensionAdditionsContext {
	var p = new(ExtensionAdditionsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_extensionAdditions

	return p
}

func (s *ExtensionAdditionsContext) GetParser() antlr.Parser { return s.parser }

func (s *ExtensionAdditionsContext) COMMA() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserCOMMA, 0)
}

func (s *ExtensionAdditionsContext) ExtensionAdditionList() IExtensionAdditionListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExtensionAdditionListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExtensionAdditionListContext)
}

func (s *ExtensionAdditionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExtensionAdditionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExtensionAdditionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterExtensionAdditions(s)
	}
}

func (s *ExtensionAdditionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitExtensionAdditions(s)
	}
}

func (p *ASN_3gppParser) ExtensionAdditions() (localctx IExtensionAdditionsContext) {
	localctx = NewExtensionAdditionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, ASN_3gppParserRULE_extensionAdditions)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(492)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 30, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(490)
			p.Match(ASN_3gppParserCOMMA)
		}
		{
			p.SetState(491)
			p.ExtensionAdditionList()
		}

	}

	return localctx
}

// IExtensionAdditionListContext is an interface to support dynamic dispatch.
type IExtensionAdditionListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExtensionAdditionListContext differentiates from other interfaces.
	IsExtensionAdditionListContext()
}

type ExtensionAdditionListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExtensionAdditionListContext() *ExtensionAdditionListContext {
	var p = new(ExtensionAdditionListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_extensionAdditionList
	return p
}

func (*ExtensionAdditionListContext) IsExtensionAdditionListContext() {}

func NewExtensionAdditionListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExtensionAdditionListContext {
	var p = new(ExtensionAdditionListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_extensionAdditionList

	return p
}

func (s *ExtensionAdditionListContext) GetParser() antlr.Parser { return s.parser }

func (s *ExtensionAdditionListContext) AllExtensionAddition() []IExtensionAdditionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExtensionAdditionContext)(nil)).Elem())
	var tst = make([]IExtensionAdditionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExtensionAdditionContext)
		}
	}

	return tst
}

func (s *ExtensionAdditionListContext) ExtensionAddition(i int) IExtensionAdditionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExtensionAdditionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExtensionAdditionContext)
}

func (s *ExtensionAdditionListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ASN_3gppParserCOMMA)
}

func (s *ExtensionAdditionListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserCOMMA, i)
}

func (s *ExtensionAdditionListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExtensionAdditionListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExtensionAdditionListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterExtensionAdditionList(s)
	}
}

func (s *ExtensionAdditionListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitExtensionAdditionList(s)
	}
}

func (p *ASN_3gppParser) ExtensionAdditionList() (localctx IExtensionAdditionListContext) {
	localctx = NewExtensionAdditionListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, ASN_3gppParserRULE_extensionAdditionList)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(494)
		p.ExtensionAddition()
	}

	p.SetState(499)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 31, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(495)
				p.Match(ASN_3gppParserCOMMA)
			}
			{
				p.SetState(496)
				p.ExtensionAddition()
			}

		}
		p.SetState(501)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 31, p.GetParserRuleContext())
	}

	return localctx
}

// IExtensionAdditionContext is an interface to support dynamic dispatch.
type IExtensionAdditionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExtensionAdditionContext differentiates from other interfaces.
	IsExtensionAdditionContext()
}

type ExtensionAdditionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExtensionAdditionContext() *ExtensionAdditionContext {
	var p = new(ExtensionAdditionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_extensionAddition
	return p
}

func (*ExtensionAdditionContext) IsExtensionAdditionContext() {}

func NewExtensionAdditionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExtensionAdditionContext {
	var p = new(ExtensionAdditionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_extensionAddition

	return p
}

func (s *ExtensionAdditionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExtensionAdditionContext) ComponentType() IComponentTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComponentTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComponentTypeContext)
}

func (s *ExtensionAdditionContext) ExtensionAdditionGroup() IExtensionAdditionGroupContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExtensionAdditionGroupContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExtensionAdditionGroupContext)
}

func (s *ExtensionAdditionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExtensionAdditionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExtensionAdditionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterExtensionAddition(s)
	}
}

func (s *ExtensionAdditionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitExtensionAddition(s)
	}
}

func (p *ASN_3gppParser) ExtensionAddition() (localctx IExtensionAdditionContext) {
	localctx = NewExtensionAdditionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, ASN_3gppParserRULE_extensionAddition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(504)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ASN_3gppParserCOMPONENTS_LITERAL, ASN_3gppParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(502)
			p.ComponentType()
		}

	case ASN_3gppParserDOUBLE_L_BRACKET:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(503)
			p.ExtensionAdditionGroup()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IExtensionAdditionGroupContext is an interface to support dynamic dispatch.
type IExtensionAdditionGroupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExtensionAdditionGroupContext differentiates from other interfaces.
	IsExtensionAdditionGroupContext()
}

type ExtensionAdditionGroupContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExtensionAdditionGroupContext() *ExtensionAdditionGroupContext {
	var p = new(ExtensionAdditionGroupContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_extensionAdditionGroup
	return p
}

func (*ExtensionAdditionGroupContext) IsExtensionAdditionGroupContext() {}

func NewExtensionAdditionGroupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExtensionAdditionGroupContext {
	var p = new(ExtensionAdditionGroupContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_extensionAdditionGroup

	return p
}

func (s *ExtensionAdditionGroupContext) GetParser() antlr.Parser { return s.parser }

func (s *ExtensionAdditionGroupContext) DOUBLE_L_BRACKET() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserDOUBLE_L_BRACKET, 0)
}

func (s *ExtensionAdditionGroupContext) VersionNumber() IVersionNumberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVersionNumberContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVersionNumberContext)
}

func (s *ExtensionAdditionGroupContext) ComponentTypeList() IComponentTypeListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComponentTypeListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComponentTypeListContext)
}

func (s *ExtensionAdditionGroupContext) DOUBLE_R_BRACKET() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserDOUBLE_R_BRACKET, 0)
}

func (s *ExtensionAdditionGroupContext) Tag() ITagContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITagContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITagContext)
}

func (s *ExtensionAdditionGroupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExtensionAdditionGroupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExtensionAdditionGroupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterExtensionAdditionGroup(s)
	}
}

func (s *ExtensionAdditionGroupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitExtensionAdditionGroup(s)
	}
}

func (p *ASN_3gppParser) ExtensionAdditionGroup() (localctx IExtensionAdditionGroupContext) {
	localctx = NewExtensionAdditionGroupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, ASN_3gppParserRULE_extensionAdditionGroup)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(506)
		p.Match(ASN_3gppParserDOUBLE_L_BRACKET)
	}
	{
		p.SetState(507)
		p.VersionNumber()
	}
	{
		p.SetState(508)
		p.ComponentTypeList()
	}
	p.SetState(510)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ASN_3gppParserNEED_LITERAL)|(1<<ASN_3gppParserCOND_LITERAL)|(1<<ASN_3gppParserINVALID_TAG))) != 0 {
		{
			p.SetState(509)
			p.Tag()
		}

	}
	{
		p.SetState(512)
		p.Match(ASN_3gppParserDOUBLE_R_BRACKET)
	}

	return localctx
}

// IVersionNumberContext is an interface to support dynamic dispatch.
type IVersionNumberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVersionNumberContext differentiates from other interfaces.
	IsVersionNumberContext()
}

type VersionNumberContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVersionNumberContext() *VersionNumberContext {
	var p = new(VersionNumberContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_versionNumber
	return p
}

func (*VersionNumberContext) IsVersionNumberContext() {}

func NewVersionNumberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VersionNumberContext {
	var p = new(VersionNumberContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_versionNumber

	return p
}

func (s *VersionNumberContext) GetParser() antlr.Parser { return s.parser }

func (s *VersionNumberContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserNUMBER, 0)
}

func (s *VersionNumberContext) COLON() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserCOLON, 0)
}

func (s *VersionNumberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VersionNumberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VersionNumberContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterVersionNumber(s)
	}
}

func (s *VersionNumberContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitVersionNumber(s)
	}
}

func (p *ASN_3gppParser) VersionNumber() (localctx IVersionNumberContext) {
	localctx = NewVersionNumberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, ASN_3gppParserRULE_versionNumber)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(516)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ASN_3gppParserNUMBER {
		{
			p.SetState(514)
			p.Match(ASN_3gppParserNUMBER)
		}
		{
			p.SetState(515)
			p.Match(ASN_3gppParserCOLON)
		}

	}

	return localctx
}

// ISequenceOfTypeContext is an interface to support dynamic dispatch.
type ISequenceOfTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSequenceOfTypeContext differentiates from other interfaces.
	IsSequenceOfTypeContext()
}

type SequenceOfTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySequenceOfTypeContext() *SequenceOfTypeContext {
	var p = new(SequenceOfTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_sequenceOfType
	return p
}

func (*SequenceOfTypeContext) IsSequenceOfTypeContext() {}

func NewSequenceOfTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SequenceOfTypeContext {
	var p = new(SequenceOfTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_sequenceOfType

	return p
}

func (s *SequenceOfTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *SequenceOfTypeContext) SEQUENCE_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserSEQUENCE_LITERAL, 0)
}

func (s *SequenceOfTypeContext) OF_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserOF_LITERAL, 0)
}

func (s *SequenceOfTypeContext) AsnType() IAsnTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAsnTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAsnTypeContext)
}

func (s *SequenceOfTypeContext) NamedType() INamedTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INamedTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INamedTypeContext)
}

func (s *SequenceOfTypeContext) L_PARAN() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserL_PARAN, 0)
}

func (s *SequenceOfTypeContext) R_PARAN() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserR_PARAN, 0)
}

func (s *SequenceOfTypeContext) Constraint() IConstraintContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstraintContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstraintContext)
}

func (s *SequenceOfTypeContext) SizeConstraint() ISizeConstraintContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISizeConstraintContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISizeConstraintContext)
}

func (s *SequenceOfTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SequenceOfTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SequenceOfTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterSequenceOfType(s)
	}
}

func (s *SequenceOfTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitSequenceOfType(s)
	}
}

func (p *ASN_3gppParser) SequenceOfType() (localctx ISequenceOfTypeContext) {
	localctx = NewSequenceOfTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, ASN_3gppParserRULE_sequenceOfType)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(518)
		p.Match(ASN_3gppParserSEQUENCE_LITERAL)
	}
	p.SetState(526)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ASN_3gppParserL_PARAN {
		{
			p.SetState(519)
			p.Match(ASN_3gppParserL_PARAN)
		}
		p.SetState(522)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case ASN_3gppParserL_PARAN:
			{
				p.SetState(520)
				p.Constraint()
			}

		case ASN_3gppParserSIZE_LITERAL:
			{
				p.SetState(521)
				p.SizeConstraint()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		{
			p.SetState(524)
			p.Match(ASN_3gppParserR_PARAN)
		}

	}
	{
		p.SetState(528)
		p.Match(ASN_3gppParserOF_LITERAL)
	}
	p.SetState(531)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 37, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(529)
			p.AsnType()
		}

	case 2:
		{
			p.SetState(530)
			p.NamedType()
		}

	}

	return localctx
}

// ISizeConstraintContext is an interface to support dynamic dispatch.
type ISizeConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSizeConstraintContext differentiates from other interfaces.
	IsSizeConstraintContext()
}

type SizeConstraintContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySizeConstraintContext() *SizeConstraintContext {
	var p = new(SizeConstraintContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_sizeConstraint
	return p
}

func (*SizeConstraintContext) IsSizeConstraintContext() {}

func NewSizeConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SizeConstraintContext {
	var p = new(SizeConstraintContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_sizeConstraint

	return p
}

func (s *SizeConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *SizeConstraintContext) SIZE_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserSIZE_LITERAL, 0)
}

func (s *SizeConstraintContext) Constraint() IConstraintContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstraintContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstraintContext)
}

func (s *SizeConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SizeConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SizeConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterSizeConstraint(s)
	}
}

func (s *SizeConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitSizeConstraint(s)
	}
}

func (p *ASN_3gppParser) SizeConstraint() (localctx ISizeConstraintContext) {
	localctx = NewSizeConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, ASN_3gppParserRULE_sizeConstraint)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(533)
		p.Match(ASN_3gppParserSIZE_LITERAL)
	}
	{
		p.SetState(534)
		p.Constraint()
	}

	return localctx
}

// IParameterizedAssignmentContext is an interface to support dynamic dispatch.
type IParameterizedAssignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParameterizedAssignmentContext differentiates from other interfaces.
	IsParameterizedAssignmentContext()
}

type ParameterizedAssignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameterizedAssignmentContext() *ParameterizedAssignmentContext {
	var p = new(ParameterizedAssignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_parameterizedAssignment
	return p
}

func (*ParameterizedAssignmentContext) IsParameterizedAssignmentContext() {}

func NewParameterizedAssignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParameterizedAssignmentContext {
	var p = new(ParameterizedAssignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_parameterizedAssignment

	return p
}

func (s *ParameterizedAssignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *ParameterizedAssignmentContext) ParameterList() IParameterListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameterListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameterListContext)
}

func (s *ParameterizedAssignmentContext) ASSIGN_OP() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserASSIGN_OP, 0)
}

func (s *ParameterizedAssignmentContext) AsnType() IAsnTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAsnTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAsnTypeContext)
}

func (s *ParameterizedAssignmentContext) Value() IValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueContext)
}

func (s *ParameterizedAssignmentContext) ValueSet() IValueSetContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueSetContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueSetContext)
}

func (s *ParameterizedAssignmentContext) DefinedObjectClass() IDefinedObjectClassContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDefinedObjectClassContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDefinedObjectClassContext)
}

func (s *ParameterizedAssignmentContext) Object() IObjectContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObjectContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObjectContext)
}

func (s *ParameterizedAssignmentContext) ObjectClass() IObjectClassContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObjectClassContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObjectClassContext)
}

func (s *ParameterizedAssignmentContext) ObjectSet() IObjectSetContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObjectSetContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObjectSetContext)
}

func (s *ParameterizedAssignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParameterizedAssignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParameterizedAssignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterParameterizedAssignment(s)
	}
}

func (s *ParameterizedAssignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitParameterizedAssignment(s)
	}
}

func (p *ASN_3gppParser) ParameterizedAssignment() (localctx IParameterizedAssignmentContext) {
	localctx = NewParameterizedAssignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, ASN_3gppParserRULE_parameterizedAssignment)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(550)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ASN_3gppParserL_BRACE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(536)
			p.ParameterList()
		}

		{
			p.SetState(537)
			p.Match(ASN_3gppParserASSIGN_OP)
		}
		p.SetState(541)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 38, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(538)
				p.AsnType()
			}

		case 2:
			{
				p.SetState(539)
				p.Value()
			}

		case 3:
			{
				p.SetState(540)
				p.ValueSet()
			}

		}

	case ASN_3gppParserTYPE_IDENTIFIER_LITERAL, ASN_3gppParserABSTRACT_SYNTAX_LITERAL, ASN_3gppParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(543)
			p.DefinedObjectClass()
		}
		{
			p.SetState(544)
			p.Match(ASN_3gppParserASSIGN_OP)
		}
		p.SetState(548)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 39, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(545)
				p.Object()
			}

		case 2:
			{
				p.SetState(546)
				p.ObjectClass()
			}

		case 3:
			{
				p.SetState(547)
				p.ObjectSet()
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IParameterListContext is an interface to support dynamic dispatch.
type IParameterListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParameterListContext differentiates from other interfaces.
	IsParameterListContext()
}

type ParameterListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameterListContext() *ParameterListContext {
	var p = new(ParameterListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_parameterList
	return p
}

func (*ParameterListContext) IsParameterListContext() {}

func NewParameterListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParameterListContext {
	var p = new(ParameterListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_parameterList

	return p
}

func (s *ParameterListContext) GetParser() antlr.Parser { return s.parser }

func (s *ParameterListContext) L_BRACE() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserL_BRACE, 0)
}

func (s *ParameterListContext) AllParameter() []IParameterContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IParameterContext)(nil)).Elem())
	var tst = make([]IParameterContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IParameterContext)
		}
	}

	return tst
}

func (s *ParameterListContext) Parameter(i int) IParameterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameterContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IParameterContext)
}

func (s *ParameterListContext) R_BRACE() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserR_BRACE, 0)
}

func (s *ParameterListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ASN_3gppParserCOMMA)
}

func (s *ParameterListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserCOMMA, i)
}

func (s *ParameterListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParameterListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParameterListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterParameterList(s)
	}
}

func (s *ParameterListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitParameterList(s)
	}
}

func (p *ASN_3gppParser) ParameterList() (localctx IParameterListContext) {
	localctx = NewParameterListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, ASN_3gppParserRULE_parameterList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(552)
		p.Match(ASN_3gppParserL_BRACE)
	}
	{
		p.SetState(553)
		p.Parameter()
	}
	p.SetState(558)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ASN_3gppParserCOMMA {
		{
			p.SetState(554)
			p.Match(ASN_3gppParserCOMMA)
		}
		{
			p.SetState(555)
			p.Parameter()
		}

		p.SetState(560)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(561)
		p.Match(ASN_3gppParserR_BRACE)
	}

	return localctx
}

// IParameterContext is an interface to support dynamic dispatch.
type IParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParameterContext differentiates from other interfaces.
	IsParameterContext()
}

type ParameterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameterContext() *ParameterContext {
	var p = new(ParameterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_parameter
	return p
}

func (*ParameterContext) IsParameterContext() {}

func NewParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParameterContext {
	var p = new(ParameterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_parameter

	return p
}

func (s *ParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *ParameterContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserIDENTIFIER, 0)
}

func (s *ParameterContext) ParamGovernor() IParamGovernorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParamGovernorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParamGovernorContext)
}

func (s *ParameterContext) COLON() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserCOLON, 0)
}

func (s *ParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterParameter(s)
	}
}

func (s *ParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitParameter(s)
	}
}

func (p *ASN_3gppParser) Parameter() (localctx IParameterContext) {
	localctx = NewParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, ASN_3gppParserRULE_parameter)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(566)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 42, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(563)
			p.ParamGovernor()
		}
		{
			p.SetState(564)
			p.Match(ASN_3gppParserCOLON)
		}

	}
	{
		p.SetState(568)
		p.Match(ASN_3gppParserIDENTIFIER)
	}

	return localctx
}

// IParamGovernorContext is an interface to support dynamic dispatch.
type IParamGovernorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParamGovernorContext differentiates from other interfaces.
	IsParamGovernorContext()
}

type ParamGovernorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParamGovernorContext() *ParamGovernorContext {
	var p = new(ParamGovernorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_paramGovernor
	return p
}

func (*ParamGovernorContext) IsParamGovernorContext() {}

func NewParamGovernorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParamGovernorContext {
	var p = new(ParamGovernorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_paramGovernor

	return p
}

func (s *ParamGovernorContext) GetParser() antlr.Parser { return s.parser }

func (s *ParamGovernorContext) Governor() IGovernorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGovernorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGovernorContext)
}

func (s *ParamGovernorContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserIDENTIFIER, 0)
}

func (s *ParamGovernorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParamGovernorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParamGovernorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterParamGovernor(s)
	}
}

func (s *ParamGovernorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitParamGovernor(s)
	}
}

func (p *ASN_3gppParser) ParamGovernor() (localctx IParamGovernorContext) {
	localctx = NewParamGovernorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, ASN_3gppParserRULE_paramGovernor)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(572)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 43, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(570)
			p.Governor()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(571)
			p.Match(ASN_3gppParserIDENTIFIER)
		}

	}

	return localctx
}

// IGovernorContext is an interface to support dynamic dispatch.
type IGovernorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGovernorContext differentiates from other interfaces.
	IsGovernorContext()
}

type GovernorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGovernorContext() *GovernorContext {
	var p = new(GovernorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_governor
	return p
}

func (*GovernorContext) IsGovernorContext() {}

func NewGovernorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GovernorContext {
	var p = new(GovernorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_governor

	return p
}

func (s *GovernorContext) GetParser() antlr.Parser { return s.parser }

func (s *GovernorContext) AsnType() IAsnTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAsnTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAsnTypeContext)
}

func (s *GovernorContext) DefinedObjectClass() IDefinedObjectClassContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDefinedObjectClassContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDefinedObjectClassContext)
}

func (s *GovernorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GovernorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GovernorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterGovernor(s)
	}
}

func (s *GovernorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitGovernor(s)
	}
}

func (p *ASN_3gppParser) Governor() (localctx IGovernorContext) {
	localctx = NewGovernorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, ASN_3gppParserRULE_governor)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(576)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 44, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(574)
			p.AsnType()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(575)
			p.DefinedObjectClass()
		}

	}

	return localctx
}

// IObjectClassAssignmentContext is an interface to support dynamic dispatch.
type IObjectClassAssignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObjectClassAssignmentContext differentiates from other interfaces.
	IsObjectClassAssignmentContext()
}

type ObjectClassAssignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObjectClassAssignmentContext() *ObjectClassAssignmentContext {
	var p = new(ObjectClassAssignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_objectClassAssignment
	return p
}

func (*ObjectClassAssignmentContext) IsObjectClassAssignmentContext() {}

func NewObjectClassAssignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjectClassAssignmentContext {
	var p = new(ObjectClassAssignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_objectClassAssignment

	return p
}

func (s *ObjectClassAssignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjectClassAssignmentContext) ASSIGN_OP() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserASSIGN_OP, 0)
}

func (s *ObjectClassAssignmentContext) ObjectClass() IObjectClassContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObjectClassContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObjectClassContext)
}

func (s *ObjectClassAssignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectClassAssignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObjectClassAssignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterObjectClassAssignment(s)
	}
}

func (s *ObjectClassAssignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitObjectClassAssignment(s)
	}
}

func (p *ASN_3gppParser) ObjectClassAssignment() (localctx IObjectClassAssignmentContext) {
	localctx = NewObjectClassAssignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, ASN_3gppParserRULE_objectClassAssignment)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(578)
		p.Match(ASN_3gppParserASSIGN_OP)
	}
	{
		p.SetState(579)
		p.ObjectClass()
	}

	return localctx
}

// IObjectClassContext is an interface to support dynamic dispatch.
type IObjectClassContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObjectClassContext differentiates from other interfaces.
	IsObjectClassContext()
}

type ObjectClassContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObjectClassContext() *ObjectClassContext {
	var p = new(ObjectClassContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_objectClass
	return p
}

func (*ObjectClassContext) IsObjectClassContext() {}

func NewObjectClassContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjectClassContext {
	var p = new(ObjectClassContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_objectClass

	return p
}

func (s *ObjectClassContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjectClassContext) DefinedObjectClass() IDefinedObjectClassContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDefinedObjectClassContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDefinedObjectClassContext)
}

func (s *ObjectClassContext) ObjectClassDefn() IObjectClassDefnContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObjectClassDefnContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObjectClassDefnContext)
}

func (s *ObjectClassContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectClassContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObjectClassContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterObjectClass(s)
	}
}

func (s *ObjectClassContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitObjectClass(s)
	}
}

func (p *ASN_3gppParser) ObjectClass() (localctx IObjectClassContext) {
	localctx = NewObjectClassContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, ASN_3gppParserRULE_objectClass)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(583)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ASN_3gppParserTYPE_IDENTIFIER_LITERAL, ASN_3gppParserABSTRACT_SYNTAX_LITERAL, ASN_3gppParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(581)
			p.DefinedObjectClass()
		}

	case ASN_3gppParserCLASS_LITERAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(582)
			p.ObjectClassDefn()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IDefinedObjectClassContext is an interface to support dynamic dispatch.
type IDefinedObjectClassContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDefinedObjectClassContext differentiates from other interfaces.
	IsDefinedObjectClassContext()
}

type DefinedObjectClassContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefinedObjectClassContext() *DefinedObjectClassContext {
	var p = new(DefinedObjectClassContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_definedObjectClass
	return p
}

func (*DefinedObjectClassContext) IsDefinedObjectClassContext() {}

func NewDefinedObjectClassContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefinedObjectClassContext {
	var p = new(DefinedObjectClassContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_definedObjectClass

	return p
}

func (s *DefinedObjectClassContext) GetParser() antlr.Parser { return s.parser }

func (s *DefinedObjectClassContext) AllIDENTIFIER() []antlr.TerminalNode {
	return s.GetTokens(ASN_3gppParserIDENTIFIER)
}

func (s *DefinedObjectClassContext) IDENTIFIER(i int) antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserIDENTIFIER, i)
}

func (s *DefinedObjectClassContext) DOT() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserDOT, 0)
}

func (s *DefinedObjectClassContext) TYPE_IDENTIFIER_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserTYPE_IDENTIFIER_LITERAL, 0)
}

func (s *DefinedObjectClassContext) ABSTRACT_SYNTAX_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserABSTRACT_SYNTAX_LITERAL, 0)
}

func (s *DefinedObjectClassContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefinedObjectClassContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DefinedObjectClassContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterDefinedObjectClass(s)
	}
}

func (s *DefinedObjectClassContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitDefinedObjectClass(s)
	}
}

func (p *ASN_3gppParser) DefinedObjectClass() (localctx IDefinedObjectClassContext) {
	localctx = NewDefinedObjectClassContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, ASN_3gppParserRULE_definedObjectClass)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(592)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ASN_3gppParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(587)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 46, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(585)
				p.Match(ASN_3gppParserIDENTIFIER)
			}
			{
				p.SetState(586)
				p.Match(ASN_3gppParserDOT)
			}

		}
		{
			p.SetState(589)
			p.Match(ASN_3gppParserIDENTIFIER)
		}

	case ASN_3gppParserTYPE_IDENTIFIER_LITERAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(590)
			p.Match(ASN_3gppParserTYPE_IDENTIFIER_LITERAL)
		}

	case ASN_3gppParserABSTRACT_SYNTAX_LITERAL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(591)
			p.Match(ASN_3gppParserABSTRACT_SYNTAX_LITERAL)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IUsefulObjectClassReferenceContext is an interface to support dynamic dispatch.
type IUsefulObjectClassReferenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUsefulObjectClassReferenceContext differentiates from other interfaces.
	IsUsefulObjectClassReferenceContext()
}

type UsefulObjectClassReferenceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUsefulObjectClassReferenceContext() *UsefulObjectClassReferenceContext {
	var p = new(UsefulObjectClassReferenceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_usefulObjectClassReference
	return p
}

func (*UsefulObjectClassReferenceContext) IsUsefulObjectClassReferenceContext() {}

func NewUsefulObjectClassReferenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UsefulObjectClassReferenceContext {
	var p = new(UsefulObjectClassReferenceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_usefulObjectClassReference

	return p
}

func (s *UsefulObjectClassReferenceContext) GetParser() antlr.Parser { return s.parser }

func (s *UsefulObjectClassReferenceContext) TYPE_IDENTIFIER_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserTYPE_IDENTIFIER_LITERAL, 0)
}

func (s *UsefulObjectClassReferenceContext) ABSTRACT_SYNTAX_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserABSTRACT_SYNTAX_LITERAL, 0)
}

func (s *UsefulObjectClassReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UsefulObjectClassReferenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UsefulObjectClassReferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterUsefulObjectClassReference(s)
	}
}

func (s *UsefulObjectClassReferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitUsefulObjectClassReference(s)
	}
}

func (p *ASN_3gppParser) UsefulObjectClassReference() (localctx IUsefulObjectClassReferenceContext) {
	localctx = NewUsefulObjectClassReferenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, ASN_3gppParserRULE_usefulObjectClassReference)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(594)
		_la = p.GetTokenStream().LA(1)

		if !(_la == ASN_3gppParserTYPE_IDENTIFIER_LITERAL || _la == ASN_3gppParserABSTRACT_SYNTAX_LITERAL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IExternalObjectClassReferenceContext is an interface to support dynamic dispatch.
type IExternalObjectClassReferenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExternalObjectClassReferenceContext differentiates from other interfaces.
	IsExternalObjectClassReferenceContext()
}

type ExternalObjectClassReferenceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExternalObjectClassReferenceContext() *ExternalObjectClassReferenceContext {
	var p = new(ExternalObjectClassReferenceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_externalObjectClassReference
	return p
}

func (*ExternalObjectClassReferenceContext) IsExternalObjectClassReferenceContext() {}

func NewExternalObjectClassReferenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExternalObjectClassReferenceContext {
	var p = new(ExternalObjectClassReferenceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_externalObjectClassReference

	return p
}

func (s *ExternalObjectClassReferenceContext) GetParser() antlr.Parser { return s.parser }

func (s *ExternalObjectClassReferenceContext) AllIDENTIFIER() []antlr.TerminalNode {
	return s.GetTokens(ASN_3gppParserIDENTIFIER)
}

func (s *ExternalObjectClassReferenceContext) IDENTIFIER(i int) antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserIDENTIFIER, i)
}

func (s *ExternalObjectClassReferenceContext) DOT() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserDOT, 0)
}

func (s *ExternalObjectClassReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExternalObjectClassReferenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExternalObjectClassReferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterExternalObjectClassReference(s)
	}
}

func (s *ExternalObjectClassReferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitExternalObjectClassReference(s)
	}
}

func (p *ASN_3gppParser) ExternalObjectClassReference() (localctx IExternalObjectClassReferenceContext) {
	localctx = NewExternalObjectClassReferenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, ASN_3gppParserRULE_externalObjectClassReference)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(596)
		p.Match(ASN_3gppParserIDENTIFIER)
	}
	{
		p.SetState(597)
		p.Match(ASN_3gppParserDOT)
	}
	{
		p.SetState(598)
		p.Match(ASN_3gppParserIDENTIFIER)
	}

	return localctx
}

// IObjectClassDefnContext is an interface to support dynamic dispatch.
type IObjectClassDefnContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObjectClassDefnContext differentiates from other interfaces.
	IsObjectClassDefnContext()
}

type ObjectClassDefnContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObjectClassDefnContext() *ObjectClassDefnContext {
	var p = new(ObjectClassDefnContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_objectClassDefn
	return p
}

func (*ObjectClassDefnContext) IsObjectClassDefnContext() {}

func NewObjectClassDefnContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjectClassDefnContext {
	var p = new(ObjectClassDefnContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_objectClassDefn

	return p
}

func (s *ObjectClassDefnContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjectClassDefnContext) CLASS_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserCLASS_LITERAL, 0)
}

func (s *ObjectClassDefnContext) L_BRACE() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserL_BRACE, 0)
}

func (s *ObjectClassDefnContext) AllFieldSpec() []IFieldSpecContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFieldSpecContext)(nil)).Elem())
	var tst = make([]IFieldSpecContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFieldSpecContext)
		}
	}

	return tst
}

func (s *ObjectClassDefnContext) FieldSpec(i int) IFieldSpecContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFieldSpecContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFieldSpecContext)
}

func (s *ObjectClassDefnContext) R_BRACE() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserR_BRACE, 0)
}

func (s *ObjectClassDefnContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ASN_3gppParserCOMMA)
}

func (s *ObjectClassDefnContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserCOMMA, i)
}

func (s *ObjectClassDefnContext) WithSyntaxSpec() IWithSyntaxSpecContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWithSyntaxSpecContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWithSyntaxSpecContext)
}

func (s *ObjectClassDefnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectClassDefnContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObjectClassDefnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterObjectClassDefn(s)
	}
}

func (s *ObjectClassDefnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitObjectClassDefn(s)
	}
}

func (p *ASN_3gppParser) ObjectClassDefn() (localctx IObjectClassDefnContext) {
	localctx = NewObjectClassDefnContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, ASN_3gppParserRULE_objectClassDefn)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(600)
		p.Match(ASN_3gppParserCLASS_LITERAL)
	}
	{
		p.SetState(601)
		p.Match(ASN_3gppParserL_BRACE)
	}
	{
		p.SetState(602)
		p.FieldSpec()
	}
	p.SetState(607)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ASN_3gppParserCOMMA {
		{
			p.SetState(603)
			p.Match(ASN_3gppParserCOMMA)
		}
		{
			p.SetState(604)
			p.FieldSpec()
		}

		p.SetState(609)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(610)
		p.Match(ASN_3gppParserR_BRACE)
	}
	p.SetState(612)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ASN_3gppParserWITH_LITERAL {
		{
			p.SetState(611)
			p.WithSyntaxSpec()
		}

	}

	return localctx
}

// IWithSyntaxSpecContext is an interface to support dynamic dispatch.
type IWithSyntaxSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWithSyntaxSpecContext differentiates from other interfaces.
	IsWithSyntaxSpecContext()
}

type WithSyntaxSpecContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWithSyntaxSpecContext() *WithSyntaxSpecContext {
	var p = new(WithSyntaxSpecContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_withSyntaxSpec
	return p
}

func (*WithSyntaxSpecContext) IsWithSyntaxSpecContext() {}

func NewWithSyntaxSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WithSyntaxSpecContext {
	var p = new(WithSyntaxSpecContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_withSyntaxSpec

	return p
}

func (s *WithSyntaxSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *WithSyntaxSpecContext) WITH_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserWITH_LITERAL, 0)
}

func (s *WithSyntaxSpecContext) SYNTAX_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserSYNTAX_LITERAL, 0)
}

func (s *WithSyntaxSpecContext) SyntaxList() ISyntaxListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISyntaxListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISyntaxListContext)
}

func (s *WithSyntaxSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WithSyntaxSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WithSyntaxSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterWithSyntaxSpec(s)
	}
}

func (s *WithSyntaxSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitWithSyntaxSpec(s)
	}
}

func (p *ASN_3gppParser) WithSyntaxSpec() (localctx IWithSyntaxSpecContext) {
	localctx = NewWithSyntaxSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, ASN_3gppParserRULE_withSyntaxSpec)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(614)
		p.Match(ASN_3gppParserWITH_LITERAL)
	}
	{
		p.SetState(615)
		p.Match(ASN_3gppParserSYNTAX_LITERAL)
	}
	{
		p.SetState(616)
		p.SyntaxList()
	}

	return localctx
}

// ISyntaxListContext is an interface to support dynamic dispatch.
type ISyntaxListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSyntaxListContext differentiates from other interfaces.
	IsSyntaxListContext()
}

type SyntaxListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySyntaxListContext() *SyntaxListContext {
	var p = new(SyntaxListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_syntaxList
	return p
}

func (*SyntaxListContext) IsSyntaxListContext() {}

func NewSyntaxListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SyntaxListContext {
	var p = new(SyntaxListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_syntaxList

	return p
}

func (s *SyntaxListContext) GetParser() antlr.Parser { return s.parser }

func (s *SyntaxListContext) L_BRACE() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserL_BRACE, 0)
}

func (s *SyntaxListContext) R_BRACE() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserR_BRACE, 0)
}

func (s *SyntaxListContext) AllTokenOrGroupSpec() []ITokenOrGroupSpecContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITokenOrGroupSpecContext)(nil)).Elem())
	var tst = make([]ITokenOrGroupSpecContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITokenOrGroupSpecContext)
		}
	}

	return tst
}

func (s *SyntaxListContext) TokenOrGroupSpec(i int) ITokenOrGroupSpecContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITokenOrGroupSpecContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITokenOrGroupSpecContext)
}

func (s *SyntaxListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SyntaxListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SyntaxListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterSyntaxList(s)
	}
}

func (s *SyntaxListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitSyntaxList(s)
	}
}

func (p *ASN_3gppParser) SyntaxList() (localctx ISyntaxListContext) {
	localctx = NewSyntaxListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, ASN_3gppParserRULE_syntaxList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(618)
		p.Match(ASN_3gppParserL_BRACE)
	}
	p.SetState(620)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == ASN_3gppParserAMPERSAND || _la == ASN_3gppParserCOMMA || _la == ASN_3gppParserL_BRACKET || _la == ASN_3gppParserIDENTIFIER {
		{
			p.SetState(619)
			p.TokenOrGroupSpec()
		}

		p.SetState(622)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(624)
		p.Match(ASN_3gppParserR_BRACE)
	}

	return localctx
}

// ITokenOrGroupSpecContext is an interface to support dynamic dispatch.
type ITokenOrGroupSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTokenOrGroupSpecContext differentiates from other interfaces.
	IsTokenOrGroupSpecContext()
}

type TokenOrGroupSpecContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTokenOrGroupSpecContext() *TokenOrGroupSpecContext {
	var p = new(TokenOrGroupSpecContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_tokenOrGroupSpec
	return p
}

func (*TokenOrGroupSpecContext) IsTokenOrGroupSpecContext() {}

func NewTokenOrGroupSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TokenOrGroupSpecContext {
	var p = new(TokenOrGroupSpecContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_tokenOrGroupSpec

	return p
}

func (s *TokenOrGroupSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *TokenOrGroupSpecContext) RequiredToken() IRequiredTokenContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRequiredTokenContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRequiredTokenContext)
}

func (s *TokenOrGroupSpecContext) OptionalGroup() IOptionalGroupContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOptionalGroupContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOptionalGroupContext)
}

func (s *TokenOrGroupSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TokenOrGroupSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TokenOrGroupSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterTokenOrGroupSpec(s)
	}
}

func (s *TokenOrGroupSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitTokenOrGroupSpec(s)
	}
}

func (p *ASN_3gppParser) TokenOrGroupSpec() (localctx ITokenOrGroupSpecContext) {
	localctx = NewTokenOrGroupSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, ASN_3gppParserRULE_tokenOrGroupSpec)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(628)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ASN_3gppParserAMPERSAND, ASN_3gppParserCOMMA, ASN_3gppParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(626)
			p.RequiredToken()
		}

	case ASN_3gppParserL_BRACKET:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(627)
			p.OptionalGroup()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IOptionalGroupContext is an interface to support dynamic dispatch.
type IOptionalGroupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOptionalGroupContext differentiates from other interfaces.
	IsOptionalGroupContext()
}

type OptionalGroupContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOptionalGroupContext() *OptionalGroupContext {
	var p = new(OptionalGroupContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_optionalGroup
	return p
}

func (*OptionalGroupContext) IsOptionalGroupContext() {}

func NewOptionalGroupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OptionalGroupContext {
	var p = new(OptionalGroupContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_optionalGroup

	return p
}

func (s *OptionalGroupContext) GetParser() antlr.Parser { return s.parser }

func (s *OptionalGroupContext) L_BRACKET() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserL_BRACKET, 0)
}

func (s *OptionalGroupContext) R_BRACKET() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserR_BRACKET, 0)
}

func (s *OptionalGroupContext) AllTokenOrGroupSpec() []ITokenOrGroupSpecContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITokenOrGroupSpecContext)(nil)).Elem())
	var tst = make([]ITokenOrGroupSpecContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITokenOrGroupSpecContext)
		}
	}

	return tst
}

func (s *OptionalGroupContext) TokenOrGroupSpec(i int) ITokenOrGroupSpecContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITokenOrGroupSpecContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITokenOrGroupSpecContext)
}

func (s *OptionalGroupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OptionalGroupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OptionalGroupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterOptionalGroup(s)
	}
}

func (s *OptionalGroupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitOptionalGroup(s)
	}
}

func (p *ASN_3gppParser) OptionalGroup() (localctx IOptionalGroupContext) {
	localctx = NewOptionalGroupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, ASN_3gppParserRULE_optionalGroup)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(630)
		p.Match(ASN_3gppParserL_BRACKET)
	}
	p.SetState(632)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == ASN_3gppParserAMPERSAND || _la == ASN_3gppParserCOMMA || _la == ASN_3gppParserL_BRACKET || _la == ASN_3gppParserIDENTIFIER {
		{
			p.SetState(631)
			p.TokenOrGroupSpec()
		}

		p.SetState(634)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(636)
		p.Match(ASN_3gppParserR_BRACKET)
	}

	return localctx
}

// IRequiredTokenContext is an interface to support dynamic dispatch.
type IRequiredTokenContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRequiredTokenContext differentiates from other interfaces.
	IsRequiredTokenContext()
}

type RequiredTokenContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRequiredTokenContext() *RequiredTokenContext {
	var p = new(RequiredTokenContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_requiredToken
	return p
}

func (*RequiredTokenContext) IsRequiredTokenContext() {}

func NewRequiredTokenContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RequiredTokenContext {
	var p = new(RequiredTokenContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_requiredToken

	return p
}

func (s *RequiredTokenContext) GetParser() antlr.Parser { return s.parser }

func (s *RequiredTokenContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *RequiredTokenContext) PrimitiveFieldName() IPrimitiveFieldNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimitiveFieldNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrimitiveFieldNameContext)
}

func (s *RequiredTokenContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RequiredTokenContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RequiredTokenContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterRequiredToken(s)
	}
}

func (s *RequiredTokenContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitRequiredToken(s)
	}
}

func (p *ASN_3gppParser) RequiredToken() (localctx IRequiredTokenContext) {
	localctx = NewRequiredTokenContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, ASN_3gppParserRULE_requiredToken)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(640)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ASN_3gppParserCOMMA, ASN_3gppParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(638)
			p.Literal()
		}

	case ASN_3gppParserAMPERSAND:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(639)
			p.PrimitiveFieldName()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ILiteralContext is an interface to support dynamic dispatch.
type ILiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLiteralContext differentiates from other interfaces.
	IsLiteralContext()
}

type LiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteralContext() *LiteralContext {
	var p = new(LiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_literal
	return p
}

func (*LiteralContext) IsLiteralContext() {}

func NewLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LiteralContext {
	var p = new(LiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_literal

	return p
}

func (s *LiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *LiteralContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserIDENTIFIER, 0)
}

func (s *LiteralContext) COMMA() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserCOMMA, 0)
}

func (s *LiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterLiteral(s)
	}
}

func (s *LiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitLiteral(s)
	}
}

func (p *ASN_3gppParser) Literal() (localctx ILiteralContext) {
	localctx = NewLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, ASN_3gppParserRULE_literal)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(642)
		_la = p.GetTokenStream().LA(1)

		if !(_la == ASN_3gppParserCOMMA || _la == ASN_3gppParserIDENTIFIER) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IPrimitiveFieldNameContext is an interface to support dynamic dispatch.
type IPrimitiveFieldNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPrimitiveFieldNameContext differentiates from other interfaces.
	IsPrimitiveFieldNameContext()
}

type PrimitiveFieldNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimitiveFieldNameContext() *PrimitiveFieldNameContext {
	var p = new(PrimitiveFieldNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_primitiveFieldName
	return p
}

func (*PrimitiveFieldNameContext) IsPrimitiveFieldNameContext() {}

func NewPrimitiveFieldNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimitiveFieldNameContext {
	var p = new(PrimitiveFieldNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_primitiveFieldName

	return p
}

func (s *PrimitiveFieldNameContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimitiveFieldNameContext) AMPERSAND() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserAMPERSAND, 0)
}

func (s *PrimitiveFieldNameContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserIDENTIFIER, 0)
}

func (s *PrimitiveFieldNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimitiveFieldNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrimitiveFieldNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterPrimitiveFieldName(s)
	}
}

func (s *PrimitiveFieldNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitPrimitiveFieldName(s)
	}
}

func (p *ASN_3gppParser) PrimitiveFieldName() (localctx IPrimitiveFieldNameContext) {
	localctx = NewPrimitiveFieldNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, ASN_3gppParserRULE_primitiveFieldName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(644)
		p.Match(ASN_3gppParserAMPERSAND)
	}
	{
		p.SetState(645)
		p.Match(ASN_3gppParserIDENTIFIER)
	}

	return localctx
}

// IFieldSpecContext is an interface to support dynamic dispatch.
type IFieldSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFieldSpecContext differentiates from other interfaces.
	IsFieldSpecContext()
}

type FieldSpecContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFieldSpecContext() *FieldSpecContext {
	var p = new(FieldSpecContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_fieldSpec
	return p
}

func (*FieldSpecContext) IsFieldSpecContext() {}

func NewFieldSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FieldSpecContext {
	var p = new(FieldSpecContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_fieldSpec

	return p
}

func (s *FieldSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *FieldSpecContext) AMPERSAND() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserAMPERSAND, 0)
}

func (s *FieldSpecContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserIDENTIFIER, 0)
}

func (s *FieldSpecContext) AsnType() IAsnTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAsnTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAsnTypeContext)
}

func (s *FieldSpecContext) FieldName() IFieldNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFieldNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFieldNameContext)
}

func (s *FieldSpecContext) DefinedObjectClass() IDefinedObjectClassContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDefinedObjectClassContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDefinedObjectClassContext)
}

func (s *FieldSpecContext) TypeOptionalitySpec() ITypeOptionalitySpecContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeOptionalitySpecContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeOptionalitySpecContext)
}

func (s *FieldSpecContext) OPTIONAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserOPTIONAL_LITERAL, 0)
}

func (s *FieldSpecContext) ValueSetOptionalitySpec() IValueSetOptionalitySpecContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueSetOptionalitySpecContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueSetOptionalitySpecContext)
}

func (s *FieldSpecContext) UNIQUE_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserUNIQUE_LITERAL, 0)
}

func (s *FieldSpecContext) ValueOptionalitySpec() IValueOptionalitySpecContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueOptionalitySpecContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueOptionalitySpecContext)
}

func (s *FieldSpecContext) DEFAULT_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserDEFAULT_LITERAL, 0)
}

func (s *FieldSpecContext) ValueSet() IValueSetContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueSetContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueSetContext)
}

func (s *FieldSpecContext) Value() IValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueContext)
}

func (s *FieldSpecContext) ObjectSet() IObjectSetContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObjectSetContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObjectSetContext)
}

func (s *FieldSpecContext) Object() IObjectContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObjectContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObjectContext)
}

func (s *FieldSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FieldSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FieldSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterFieldSpec(s)
	}
}

func (s *FieldSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitFieldSpec(s)
	}
}

func (p *ASN_3gppParser) FieldSpec() (localctx IFieldSpecContext) {
	localctx = NewFieldSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, ASN_3gppParserRULE_fieldSpec)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(647)
		p.Match(ASN_3gppParserAMPERSAND)
	}
	{
		p.SetState(648)
		p.Match(ASN_3gppParserIDENTIFIER)
	}
	p.SetState(682)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 63, p.GetParserRuleContext()) {
	case 1:
		p.SetState(650)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ASN_3gppParserOPTIONAL_LITERAL || _la == ASN_3gppParserDEFAULT_LITERAL {
			{
				p.SetState(649)
				p.TypeOptionalitySpec()
			}

		}

	case 2:
		{
			p.SetState(652)
			p.AsnType()
		}
		p.SetState(662)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 58, p.GetParserRuleContext()) {
		case 1:
			p.SetState(654)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == ASN_3gppParserOPTIONAL_LITERAL || _la == ASN_3gppParserDEFAULT_LITERAL {
				{
					p.SetState(653)
					p.ValueSetOptionalitySpec()
				}

			}

		case 2:
			p.SetState(657)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == ASN_3gppParserUNIQUE_LITERAL {
				{
					p.SetState(656)
					p.Match(ASN_3gppParserUNIQUE_LITERAL)
				}

			}
			p.SetState(660)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == ASN_3gppParserOPTIONAL_LITERAL || _la == ASN_3gppParserDEFAULT_LITERAL {
				{
					p.SetState(659)
					p.ValueOptionalitySpec()
				}

			}

		}

	case 3:
		{
			p.SetState(664)
			p.FieldName()
		}
		p.SetState(671)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case ASN_3gppParserOPTIONAL_LITERAL:
			{
				p.SetState(665)
				p.Match(ASN_3gppParserOPTIONAL_LITERAL)
			}

		case ASN_3gppParserDEFAULT_LITERAL:
			{
				p.SetState(666)
				p.Match(ASN_3gppParserDEFAULT_LITERAL)
			}
			p.SetState(669)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 59, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(667)
					p.ValueSet()
				}

			case 2:
				{
					p.SetState(668)
					p.Value()
				}

			}

		case ASN_3gppParserR_BRACE, ASN_3gppParserCOMMA:

		default:
		}

	case 4:
		{
			p.SetState(673)
			p.DefinedObjectClass()
		}
		p.SetState(680)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case ASN_3gppParserOPTIONAL_LITERAL:
			{
				p.SetState(674)
				p.Match(ASN_3gppParserOPTIONAL_LITERAL)
			}

		case ASN_3gppParserDEFAULT_LITERAL:
			{
				p.SetState(675)
				p.Match(ASN_3gppParserDEFAULT_LITERAL)
			}
			p.SetState(678)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case ASN_3gppParserL_BRACE:
				{
					p.SetState(676)
					p.ObjectSet()
				}

			case ASN_3gppParserIDENTIFIER:
				{
					p.SetState(677)
					p.Object()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

		case ASN_3gppParserR_BRACE, ASN_3gppParserCOMMA:

		default:
		}

	}

	return localctx
}

// ITypeFieldSpecContext is an interface to support dynamic dispatch.
type ITypeFieldSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeFieldSpecContext differentiates from other interfaces.
	IsTypeFieldSpecContext()
}

type TypeFieldSpecContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeFieldSpecContext() *TypeFieldSpecContext {
	var p = new(TypeFieldSpecContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_typeFieldSpec
	return p
}

func (*TypeFieldSpecContext) IsTypeFieldSpecContext() {}

func NewTypeFieldSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeFieldSpecContext {
	var p = new(TypeFieldSpecContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_typeFieldSpec

	return p
}

func (s *TypeFieldSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeFieldSpecContext) AMPERSAND() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserAMPERSAND, 0)
}

func (s *TypeFieldSpecContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserIDENTIFIER, 0)
}

func (s *TypeFieldSpecContext) TypeOptionalitySpec() ITypeOptionalitySpecContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeOptionalitySpecContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeOptionalitySpecContext)
}

func (s *TypeFieldSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeFieldSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeFieldSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterTypeFieldSpec(s)
	}
}

func (s *TypeFieldSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitTypeFieldSpec(s)
	}
}

func (p *ASN_3gppParser) TypeFieldSpec() (localctx ITypeFieldSpecContext) {
	localctx = NewTypeFieldSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, ASN_3gppParserRULE_typeFieldSpec)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(684)
		p.Match(ASN_3gppParserAMPERSAND)
	}
	{
		p.SetState(685)
		p.Match(ASN_3gppParserIDENTIFIER)
	}
	p.SetState(687)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ASN_3gppParserOPTIONAL_LITERAL || _la == ASN_3gppParserDEFAULT_LITERAL {
		{
			p.SetState(686)
			p.TypeOptionalitySpec()
		}

	}

	return localctx
}

// ITypeOptionalitySpecContext is an interface to support dynamic dispatch.
type ITypeOptionalitySpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeOptionalitySpecContext differentiates from other interfaces.
	IsTypeOptionalitySpecContext()
}

type TypeOptionalitySpecContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeOptionalitySpecContext() *TypeOptionalitySpecContext {
	var p = new(TypeOptionalitySpecContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_typeOptionalitySpec
	return p
}

func (*TypeOptionalitySpecContext) IsTypeOptionalitySpecContext() {}

func NewTypeOptionalitySpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeOptionalitySpecContext {
	var p = new(TypeOptionalitySpecContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_typeOptionalitySpec

	return p
}

func (s *TypeOptionalitySpecContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeOptionalitySpecContext) OPTIONAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserOPTIONAL_LITERAL, 0)
}

func (s *TypeOptionalitySpecContext) DEFAULT_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserDEFAULT_LITERAL, 0)
}

func (s *TypeOptionalitySpecContext) AsnType() IAsnTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAsnTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAsnTypeContext)
}

func (s *TypeOptionalitySpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeOptionalitySpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeOptionalitySpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterTypeOptionalitySpec(s)
	}
}

func (s *TypeOptionalitySpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitTypeOptionalitySpec(s)
	}
}

func (p *ASN_3gppParser) TypeOptionalitySpec() (localctx ITypeOptionalitySpecContext) {
	localctx = NewTypeOptionalitySpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, ASN_3gppParserRULE_typeOptionalitySpec)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(692)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ASN_3gppParserOPTIONAL_LITERAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(689)
			p.Match(ASN_3gppParserOPTIONAL_LITERAL)
		}

	case ASN_3gppParserDEFAULT_LITERAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(690)
			p.Match(ASN_3gppParserDEFAULT_LITERAL)
		}
		{
			p.SetState(691)
			p.AsnType()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IFixedTypeValueFieldSpecContext is an interface to support dynamic dispatch.
type IFixedTypeValueFieldSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFixedTypeValueFieldSpecContext differentiates from other interfaces.
	IsFixedTypeValueFieldSpecContext()
}

type FixedTypeValueFieldSpecContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFixedTypeValueFieldSpecContext() *FixedTypeValueFieldSpecContext {
	var p = new(FixedTypeValueFieldSpecContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_fixedTypeValueFieldSpec
	return p
}

func (*FixedTypeValueFieldSpecContext) IsFixedTypeValueFieldSpecContext() {}

func NewFixedTypeValueFieldSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FixedTypeValueFieldSpecContext {
	var p = new(FixedTypeValueFieldSpecContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_fixedTypeValueFieldSpec

	return p
}

func (s *FixedTypeValueFieldSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *FixedTypeValueFieldSpecContext) AMPERSAND() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserAMPERSAND, 0)
}

func (s *FixedTypeValueFieldSpecContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserIDENTIFIER, 0)
}

func (s *FixedTypeValueFieldSpecContext) AsnType() IAsnTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAsnTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAsnTypeContext)
}

func (s *FixedTypeValueFieldSpecContext) UNIQUE_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserUNIQUE_LITERAL, 0)
}

func (s *FixedTypeValueFieldSpecContext) ValueOptionalitySpec() IValueOptionalitySpecContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueOptionalitySpecContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueOptionalitySpecContext)
}

func (s *FixedTypeValueFieldSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FixedTypeValueFieldSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FixedTypeValueFieldSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterFixedTypeValueFieldSpec(s)
	}
}

func (s *FixedTypeValueFieldSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitFixedTypeValueFieldSpec(s)
	}
}

func (p *ASN_3gppParser) FixedTypeValueFieldSpec() (localctx IFixedTypeValueFieldSpecContext) {
	localctx = NewFixedTypeValueFieldSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, ASN_3gppParserRULE_fixedTypeValueFieldSpec)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(694)
		p.Match(ASN_3gppParserAMPERSAND)
	}
	{
		p.SetState(695)
		p.Match(ASN_3gppParserIDENTIFIER)
	}
	{
		p.SetState(696)
		p.AsnType()
	}
	p.SetState(698)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ASN_3gppParserUNIQUE_LITERAL {
		{
			p.SetState(697)
			p.Match(ASN_3gppParserUNIQUE_LITERAL)
		}

	}
	p.SetState(701)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ASN_3gppParserOPTIONAL_LITERAL || _la == ASN_3gppParserDEFAULT_LITERAL {
		{
			p.SetState(700)
			p.ValueOptionalitySpec()
		}

	}

	return localctx
}

// IValueOptionalitySpecContext is an interface to support dynamic dispatch.
type IValueOptionalitySpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsValueOptionalitySpecContext differentiates from other interfaces.
	IsValueOptionalitySpecContext()
}

type ValueOptionalitySpecContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValueOptionalitySpecContext() *ValueOptionalitySpecContext {
	var p = new(ValueOptionalitySpecContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_valueOptionalitySpec
	return p
}

func (*ValueOptionalitySpecContext) IsValueOptionalitySpecContext() {}

func NewValueOptionalitySpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValueOptionalitySpecContext {
	var p = new(ValueOptionalitySpecContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_valueOptionalitySpec

	return p
}

func (s *ValueOptionalitySpecContext) GetParser() antlr.Parser { return s.parser }

func (s *ValueOptionalitySpecContext) OPTIONAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserOPTIONAL_LITERAL, 0)
}

func (s *ValueOptionalitySpecContext) DEFAULT_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserDEFAULT_LITERAL, 0)
}

func (s *ValueOptionalitySpecContext) Value() IValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueContext)
}

func (s *ValueOptionalitySpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueOptionalitySpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ValueOptionalitySpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterValueOptionalitySpec(s)
	}
}

func (s *ValueOptionalitySpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitValueOptionalitySpec(s)
	}
}

func (p *ASN_3gppParser) ValueOptionalitySpec() (localctx IValueOptionalitySpecContext) {
	localctx = NewValueOptionalitySpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, ASN_3gppParserRULE_valueOptionalitySpec)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(706)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ASN_3gppParserOPTIONAL_LITERAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(703)
			p.Match(ASN_3gppParserOPTIONAL_LITERAL)
		}

	case ASN_3gppParserDEFAULT_LITERAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(704)
			p.Match(ASN_3gppParserDEFAULT_LITERAL)
		}
		{
			p.SetState(705)
			p.Value()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IVariableTypeValueFieldSpecContext is an interface to support dynamic dispatch.
type IVariableTypeValueFieldSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariableTypeValueFieldSpecContext differentiates from other interfaces.
	IsVariableTypeValueFieldSpecContext()
}

type VariableTypeValueFieldSpecContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableTypeValueFieldSpecContext() *VariableTypeValueFieldSpecContext {
	var p = new(VariableTypeValueFieldSpecContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_variableTypeValueFieldSpec
	return p
}

func (*VariableTypeValueFieldSpecContext) IsVariableTypeValueFieldSpecContext() {}

func NewVariableTypeValueFieldSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableTypeValueFieldSpecContext {
	var p = new(VariableTypeValueFieldSpecContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_variableTypeValueFieldSpec

	return p
}

func (s *VariableTypeValueFieldSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableTypeValueFieldSpecContext) AMPERSAND() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserAMPERSAND, 0)
}

func (s *VariableTypeValueFieldSpecContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserIDENTIFIER, 0)
}

func (s *VariableTypeValueFieldSpecContext) FieldName() IFieldNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFieldNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFieldNameContext)
}

func (s *VariableTypeValueFieldSpecContext) ValueOptionalitySpec() IValueOptionalitySpecContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueOptionalitySpecContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueOptionalitySpecContext)
}

func (s *VariableTypeValueFieldSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableTypeValueFieldSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableTypeValueFieldSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterVariableTypeValueFieldSpec(s)
	}
}

func (s *VariableTypeValueFieldSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitVariableTypeValueFieldSpec(s)
	}
}

func (p *ASN_3gppParser) VariableTypeValueFieldSpec() (localctx IVariableTypeValueFieldSpecContext) {
	localctx = NewVariableTypeValueFieldSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, ASN_3gppParserRULE_variableTypeValueFieldSpec)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(708)
		p.Match(ASN_3gppParserAMPERSAND)
	}
	{
		p.SetState(709)
		p.Match(ASN_3gppParserIDENTIFIER)
	}
	{
		p.SetState(710)
		p.FieldName()
	}
	p.SetState(712)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ASN_3gppParserOPTIONAL_LITERAL || _la == ASN_3gppParserDEFAULT_LITERAL {
		{
			p.SetState(711)
			p.ValueOptionalitySpec()
		}

	}

	return localctx
}

// IFixedTypeValueSetFieldSpecContext is an interface to support dynamic dispatch.
type IFixedTypeValueSetFieldSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFixedTypeValueSetFieldSpecContext differentiates from other interfaces.
	IsFixedTypeValueSetFieldSpecContext()
}

type FixedTypeValueSetFieldSpecContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFixedTypeValueSetFieldSpecContext() *FixedTypeValueSetFieldSpecContext {
	var p = new(FixedTypeValueSetFieldSpecContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_fixedTypeValueSetFieldSpec
	return p
}

func (*FixedTypeValueSetFieldSpecContext) IsFixedTypeValueSetFieldSpecContext() {}

func NewFixedTypeValueSetFieldSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FixedTypeValueSetFieldSpecContext {
	var p = new(FixedTypeValueSetFieldSpecContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_fixedTypeValueSetFieldSpec

	return p
}

func (s *FixedTypeValueSetFieldSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *FixedTypeValueSetFieldSpecContext) AMPERSAND() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserAMPERSAND, 0)
}

func (s *FixedTypeValueSetFieldSpecContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserIDENTIFIER, 0)
}

func (s *FixedTypeValueSetFieldSpecContext) AsnType() IAsnTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAsnTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAsnTypeContext)
}

func (s *FixedTypeValueSetFieldSpecContext) ValueSetOptionalitySpec() IValueSetOptionalitySpecContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueSetOptionalitySpecContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueSetOptionalitySpecContext)
}

func (s *FixedTypeValueSetFieldSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FixedTypeValueSetFieldSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FixedTypeValueSetFieldSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterFixedTypeValueSetFieldSpec(s)
	}
}

func (s *FixedTypeValueSetFieldSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitFixedTypeValueSetFieldSpec(s)
	}
}

func (p *ASN_3gppParser) FixedTypeValueSetFieldSpec() (localctx IFixedTypeValueSetFieldSpecContext) {
	localctx = NewFixedTypeValueSetFieldSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, ASN_3gppParserRULE_fixedTypeValueSetFieldSpec)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(714)
		p.Match(ASN_3gppParserAMPERSAND)
	}
	{
		p.SetState(715)
		p.Match(ASN_3gppParserIDENTIFIER)
	}
	{
		p.SetState(716)
		p.AsnType()
	}
	p.SetState(718)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ASN_3gppParserOPTIONAL_LITERAL || _la == ASN_3gppParserDEFAULT_LITERAL {
		{
			p.SetState(717)
			p.ValueSetOptionalitySpec()
		}

	}

	return localctx
}

// IValueSetOptionalitySpecContext is an interface to support dynamic dispatch.
type IValueSetOptionalitySpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsValueSetOptionalitySpecContext differentiates from other interfaces.
	IsValueSetOptionalitySpecContext()
}

type ValueSetOptionalitySpecContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValueSetOptionalitySpecContext() *ValueSetOptionalitySpecContext {
	var p = new(ValueSetOptionalitySpecContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_valueSetOptionalitySpec
	return p
}

func (*ValueSetOptionalitySpecContext) IsValueSetOptionalitySpecContext() {}

func NewValueSetOptionalitySpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValueSetOptionalitySpecContext {
	var p = new(ValueSetOptionalitySpecContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_valueSetOptionalitySpec

	return p
}

func (s *ValueSetOptionalitySpecContext) GetParser() antlr.Parser { return s.parser }

func (s *ValueSetOptionalitySpecContext) OPTIONAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserOPTIONAL_LITERAL, 0)
}

func (s *ValueSetOptionalitySpecContext) DEFAULT_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserDEFAULT_LITERAL, 0)
}

func (s *ValueSetOptionalitySpecContext) ValueSet() IValueSetContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueSetContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueSetContext)
}

func (s *ValueSetOptionalitySpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueSetOptionalitySpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ValueSetOptionalitySpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterValueSetOptionalitySpec(s)
	}
}

func (s *ValueSetOptionalitySpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitValueSetOptionalitySpec(s)
	}
}

func (p *ASN_3gppParser) ValueSetOptionalitySpec() (localctx IValueSetOptionalitySpecContext) {
	localctx = NewValueSetOptionalitySpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, ASN_3gppParserRULE_valueSetOptionalitySpec)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(723)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ASN_3gppParserOPTIONAL_LITERAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(720)
			p.Match(ASN_3gppParserOPTIONAL_LITERAL)
		}

	case ASN_3gppParserDEFAULT_LITERAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(721)
			p.Match(ASN_3gppParserDEFAULT_LITERAL)
		}
		{
			p.SetState(722)
			p.ValueSet()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IObjectContext is an interface to support dynamic dispatch.
type IObjectContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObjectContext differentiates from other interfaces.
	IsObjectContext()
}

type ObjectContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObjectContext() *ObjectContext {
	var p = new(ObjectContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_object
	return p
}

func (*ObjectContext) IsObjectContext() {}

func NewObjectContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjectContext {
	var p = new(ObjectContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_object

	return p
}

func (s *ObjectContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjectContext) DefinedObject() IDefinedObjectContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDefinedObjectContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDefinedObjectContext)
}

func (s *ObjectContext) ParameterizedObject() IParameterizedObjectContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameterizedObjectContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameterizedObjectContext)
}

func (s *ObjectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObjectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterObject(s)
	}
}

func (s *ObjectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitObject(s)
	}
}

func (p *ASN_3gppParser) Object() (localctx IObjectContext) {
	localctx = NewObjectContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, ASN_3gppParserRULE_object)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(727)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 72, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(725)
			p.DefinedObject()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(726)
			p.ParameterizedObject()
		}

	}

	return localctx
}

// IParameterizedObjectContext is an interface to support dynamic dispatch.
type IParameterizedObjectContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParameterizedObjectContext differentiates from other interfaces.
	IsParameterizedObjectContext()
}

type ParameterizedObjectContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameterizedObjectContext() *ParameterizedObjectContext {
	var p = new(ParameterizedObjectContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_parameterizedObject
	return p
}

func (*ParameterizedObjectContext) IsParameterizedObjectContext() {}

func NewParameterizedObjectContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParameterizedObjectContext {
	var p = new(ParameterizedObjectContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_parameterizedObject

	return p
}

func (s *ParameterizedObjectContext) GetParser() antlr.Parser { return s.parser }

func (s *ParameterizedObjectContext) DefinedObject() IDefinedObjectContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDefinedObjectContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDefinedObjectContext)
}

func (s *ParameterizedObjectContext) ActualParameterList() IActualParameterListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IActualParameterListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IActualParameterListContext)
}

func (s *ParameterizedObjectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParameterizedObjectContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParameterizedObjectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterParameterizedObject(s)
	}
}

func (s *ParameterizedObjectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitParameterizedObject(s)
	}
}

func (p *ASN_3gppParser) ParameterizedObject() (localctx IParameterizedObjectContext) {
	localctx = NewParameterizedObjectContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, ASN_3gppParserRULE_parameterizedObject)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(729)
		p.DefinedObject()
	}
	{
		p.SetState(730)
		p.ActualParameterList()
	}

	return localctx
}

// IDefinedObjectContext is an interface to support dynamic dispatch.
type IDefinedObjectContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDefinedObjectContext differentiates from other interfaces.
	IsDefinedObjectContext()
}

type DefinedObjectContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefinedObjectContext() *DefinedObjectContext {
	var p = new(DefinedObjectContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_definedObject
	return p
}

func (*DefinedObjectContext) IsDefinedObjectContext() {}

func NewDefinedObjectContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefinedObjectContext {
	var p = new(DefinedObjectContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_definedObject

	return p
}

func (s *DefinedObjectContext) GetParser() antlr.Parser { return s.parser }

func (s *DefinedObjectContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserIDENTIFIER, 0)
}

func (s *DefinedObjectContext) DOT() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserDOT, 0)
}

func (s *DefinedObjectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefinedObjectContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DefinedObjectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterDefinedObject(s)
	}
}

func (s *DefinedObjectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitDefinedObject(s)
	}
}

func (p *ASN_3gppParser) DefinedObject() (localctx IDefinedObjectContext) {
	localctx = NewDefinedObjectContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, ASN_3gppParserRULE_definedObject)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(732)
		p.Match(ASN_3gppParserIDENTIFIER)
	}
	p.SetState(734)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ASN_3gppParserDOT {
		{
			p.SetState(733)
			p.Match(ASN_3gppParserDOT)
		}

	}

	return localctx
}

// IObjectSetContext is an interface to support dynamic dispatch.
type IObjectSetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObjectSetContext differentiates from other interfaces.
	IsObjectSetContext()
}

type ObjectSetContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObjectSetContext() *ObjectSetContext {
	var p = new(ObjectSetContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_objectSet
	return p
}

func (*ObjectSetContext) IsObjectSetContext() {}

func NewObjectSetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjectSetContext {
	var p = new(ObjectSetContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_objectSet

	return p
}

func (s *ObjectSetContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjectSetContext) L_BRACE() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserL_BRACE, 0)
}

func (s *ObjectSetContext) ObjectSetSpec() IObjectSetSpecContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObjectSetSpecContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObjectSetSpecContext)
}

func (s *ObjectSetContext) R_BRACE() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserR_BRACE, 0)
}

func (s *ObjectSetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectSetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObjectSetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterObjectSet(s)
	}
}

func (s *ObjectSetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitObjectSet(s)
	}
}

func (p *ASN_3gppParser) ObjectSet() (localctx IObjectSetContext) {
	localctx = NewObjectSetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, ASN_3gppParserRULE_objectSet)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(736)
		p.Match(ASN_3gppParserL_BRACE)
	}
	{
		p.SetState(737)
		p.ObjectSetSpec()
	}
	{
		p.SetState(738)
		p.Match(ASN_3gppParserR_BRACE)
	}

	return localctx
}

// IObjectSetSpecContext is an interface to support dynamic dispatch.
type IObjectSetSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObjectSetSpecContext differentiates from other interfaces.
	IsObjectSetSpecContext()
}

type ObjectSetSpecContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObjectSetSpecContext() *ObjectSetSpecContext {
	var p = new(ObjectSetSpecContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_objectSetSpec
	return p
}

func (*ObjectSetSpecContext) IsObjectSetSpecContext() {}

func NewObjectSetSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjectSetSpecContext {
	var p = new(ObjectSetSpecContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_objectSetSpec

	return p
}

func (s *ObjectSetSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjectSetSpecContext) RootElementSetSpec() IRootElementSetSpecContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRootElementSetSpecContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRootElementSetSpecContext)
}

func (s *ObjectSetSpecContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ASN_3gppParserCOMMA)
}

func (s *ObjectSetSpecContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserCOMMA, i)
}

func (s *ObjectSetSpecContext) ELLIPSIS() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserELLIPSIS, 0)
}

func (s *ObjectSetSpecContext) AdditionalElementSetSpec() IAdditionalElementSetSpecContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAdditionalElementSetSpecContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAdditionalElementSetSpecContext)
}

func (s *ObjectSetSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectSetSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObjectSetSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterObjectSetSpec(s)
	}
}

func (s *ObjectSetSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitObjectSetSpec(s)
	}
}

func (p *ASN_3gppParser) ObjectSetSpec() (localctx IObjectSetSpecContext) {
	localctx = NewObjectSetSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, ASN_3gppParserRULE_objectSetSpec)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(754)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ASN_3gppParserTRUE_LITERAL, ASN_3gppParserFALSE_LITERAL, ASN_3gppParserTRUE_SMALL_LITERAL, ASN_3gppParserFALSE_SMALL_LITERAL, ASN_3gppParserL_BRACE, ASN_3gppParserMINUS, ASN_3gppParserALL_LITERAL, ASN_3gppParserMIN_LITERAL, ASN_3gppParserSIZE_LITERAL, ASN_3gppParserPATTERN_LITERAL, ASN_3gppParserNUMBER, ASN_3gppParserBSTRING, ASN_3gppParserCSTRING, ASN_3gppParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(740)
			p.RootElementSetSpec()
		}
		p.SetState(747)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ASN_3gppParserCOMMA {
			{
				p.SetState(741)
				p.Match(ASN_3gppParserCOMMA)
			}
			{
				p.SetState(742)
				p.Match(ASN_3gppParserELLIPSIS)
			}
			p.SetState(745)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == ASN_3gppParserCOMMA {
				{
					p.SetState(743)
					p.Match(ASN_3gppParserCOMMA)
				}
				{
					p.SetState(744)
					p.AdditionalElementSetSpec()
				}

			}

		}

	case ASN_3gppParserELLIPSIS:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(749)
			p.Match(ASN_3gppParserELLIPSIS)
		}
		p.SetState(752)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ASN_3gppParserCOMMA {
			{
				p.SetState(750)
				p.Match(ASN_3gppParserCOMMA)
			}
			{
				p.SetState(751)
				p.AdditionalElementSetSpec()
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IFieldNameContext is an interface to support dynamic dispatch.
type IFieldNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFieldNameContext differentiates from other interfaces.
	IsFieldNameContext()
}

type FieldNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFieldNameContext() *FieldNameContext {
	var p = new(FieldNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_fieldName
	return p
}

func (*FieldNameContext) IsFieldNameContext() {}

func NewFieldNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FieldNameContext {
	var p = new(FieldNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_fieldName

	return p
}

func (s *FieldNameContext) GetParser() antlr.Parser { return s.parser }

func (s *FieldNameContext) AllAMPERSAND() []antlr.TerminalNode {
	return s.GetTokens(ASN_3gppParserAMPERSAND)
}

func (s *FieldNameContext) AMPERSAND(i int) antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserAMPERSAND, i)
}

func (s *FieldNameContext) AllIDENTIFIER() []antlr.TerminalNode {
	return s.GetTokens(ASN_3gppParserIDENTIFIER)
}

func (s *FieldNameContext) IDENTIFIER(i int) antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserIDENTIFIER, i)
}

func (s *FieldNameContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(ASN_3gppParserDOT)
}

func (s *FieldNameContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserDOT, i)
}

func (s *FieldNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FieldNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FieldNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterFieldName(s)
	}
}

func (s *FieldNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitFieldName(s)
	}
}

func (p *ASN_3gppParser) FieldName() (localctx IFieldNameContext) {
	localctx = NewFieldNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, ASN_3gppParserRULE_fieldName)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(756)
		p.Match(ASN_3gppParserAMPERSAND)
	}
	{
		p.SetState(757)
		p.Match(ASN_3gppParserIDENTIFIER)
	}

	p.SetState(764)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ASN_3gppParserAMPERSAND {
		{
			p.SetState(759)
			p.Match(ASN_3gppParserAMPERSAND)
		}
		{
			p.SetState(760)
			p.Match(ASN_3gppParserIDENTIFIER)
		}
		{
			p.SetState(761)
			p.Match(ASN_3gppParserDOT)
		}

		p.SetState(766)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IValueSetContext is an interface to support dynamic dispatch.
type IValueSetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsValueSetContext differentiates from other interfaces.
	IsValueSetContext()
}

type ValueSetContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValueSetContext() *ValueSetContext {
	var p = new(ValueSetContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_valueSet
	return p
}

func (*ValueSetContext) IsValueSetContext() {}

func NewValueSetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValueSetContext {
	var p = new(ValueSetContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_valueSet

	return p
}

func (s *ValueSetContext) GetParser() antlr.Parser { return s.parser }

func (s *ValueSetContext) L_BRACE() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserL_BRACE, 0)
}

func (s *ValueSetContext) ElementSetSpecs() IElementSetSpecsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IElementSetSpecsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IElementSetSpecsContext)
}

func (s *ValueSetContext) R_BRACE() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserR_BRACE, 0)
}

func (s *ValueSetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueSetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ValueSetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterValueSet(s)
	}
}

func (s *ValueSetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitValueSet(s)
	}
}

func (p *ASN_3gppParser) ValueSet() (localctx IValueSetContext) {
	localctx = NewValueSetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, ASN_3gppParserRULE_valueSet)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(767)
		p.Match(ASN_3gppParserL_BRACE)
	}
	{
		p.SetState(768)
		p.ElementSetSpecs()
	}
	{
		p.SetState(769)
		p.Match(ASN_3gppParserR_BRACE)
	}

	return localctx
}

// IElementSetSpecsContext is an interface to support dynamic dispatch.
type IElementSetSpecsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsElementSetSpecsContext differentiates from other interfaces.
	IsElementSetSpecsContext()
}

type ElementSetSpecsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElementSetSpecsContext() *ElementSetSpecsContext {
	var p = new(ElementSetSpecsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_elementSetSpecs
	return p
}

func (*ElementSetSpecsContext) IsElementSetSpecsContext() {}

func NewElementSetSpecsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElementSetSpecsContext {
	var p = new(ElementSetSpecsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_elementSetSpecs

	return p
}

func (s *ElementSetSpecsContext) GetParser() antlr.Parser { return s.parser }

func (s *ElementSetSpecsContext) RootElementSetSpec() IRootElementSetSpecContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRootElementSetSpecContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRootElementSetSpecContext)
}

func (s *ElementSetSpecsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ASN_3gppParserCOMMA)
}

func (s *ElementSetSpecsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserCOMMA, i)
}

func (s *ElementSetSpecsContext) ELLIPSIS() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserELLIPSIS, 0)
}

func (s *ElementSetSpecsContext) AdditionalElementSetSpec() IAdditionalElementSetSpecContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAdditionalElementSetSpecContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAdditionalElementSetSpecContext)
}

func (s *ElementSetSpecsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementSetSpecsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElementSetSpecsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterElementSetSpecs(s)
	}
}

func (s *ElementSetSpecsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitElementSetSpecs(s)
	}
}

func (p *ASN_3gppParser) ElementSetSpecs() (localctx IElementSetSpecsContext) {
	localctx = NewElementSetSpecsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, ASN_3gppParserRULE_elementSetSpecs)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(771)
		p.RootElementSetSpec()
	}
	p.SetState(778)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ASN_3gppParserCOMMA {
		{
			p.SetState(772)
			p.Match(ASN_3gppParserCOMMA)
		}
		{
			p.SetState(773)
			p.Match(ASN_3gppParserELLIPSIS)
		}
		p.SetState(776)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ASN_3gppParserCOMMA {
			{
				p.SetState(774)
				p.Match(ASN_3gppParserCOMMA)
			}
			{
				p.SetState(775)
				p.AdditionalElementSetSpec()
			}

		}

	}

	return localctx
}

// IRootElementSetSpecContext is an interface to support dynamic dispatch.
type IRootElementSetSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRootElementSetSpecContext differentiates from other interfaces.
	IsRootElementSetSpecContext()
}

type RootElementSetSpecContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRootElementSetSpecContext() *RootElementSetSpecContext {
	var p = new(RootElementSetSpecContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_rootElementSetSpec
	return p
}

func (*RootElementSetSpecContext) IsRootElementSetSpecContext() {}

func NewRootElementSetSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RootElementSetSpecContext {
	var p = new(RootElementSetSpecContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_rootElementSetSpec

	return p
}

func (s *RootElementSetSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *RootElementSetSpecContext) ElementSetSpec() IElementSetSpecContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IElementSetSpecContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IElementSetSpecContext)
}

func (s *RootElementSetSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RootElementSetSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RootElementSetSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterRootElementSetSpec(s)
	}
}

func (s *RootElementSetSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitRootElementSetSpec(s)
	}
}

func (p *ASN_3gppParser) RootElementSetSpec() (localctx IRootElementSetSpecContext) {
	localctx = NewRootElementSetSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, ASN_3gppParserRULE_rootElementSetSpec)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(780)
		p.ElementSetSpec()
	}

	return localctx
}

// IAdditionalElementSetSpecContext is an interface to support dynamic dispatch.
type IAdditionalElementSetSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAdditionalElementSetSpecContext differentiates from other interfaces.
	IsAdditionalElementSetSpecContext()
}

type AdditionalElementSetSpecContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAdditionalElementSetSpecContext() *AdditionalElementSetSpecContext {
	var p = new(AdditionalElementSetSpecContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_additionalElementSetSpec
	return p
}

func (*AdditionalElementSetSpecContext) IsAdditionalElementSetSpecContext() {}

func NewAdditionalElementSetSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AdditionalElementSetSpecContext {
	var p = new(AdditionalElementSetSpecContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_additionalElementSetSpec

	return p
}

func (s *AdditionalElementSetSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *AdditionalElementSetSpecContext) ElementSetSpec() IElementSetSpecContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IElementSetSpecContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IElementSetSpecContext)
}

func (s *AdditionalElementSetSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdditionalElementSetSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AdditionalElementSetSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterAdditionalElementSetSpec(s)
	}
}

func (s *AdditionalElementSetSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitAdditionalElementSetSpec(s)
	}
}

func (p *ASN_3gppParser) AdditionalElementSetSpec() (localctx IAdditionalElementSetSpecContext) {
	localctx = NewAdditionalElementSetSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, ASN_3gppParserRULE_additionalElementSetSpec)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(782)
		p.ElementSetSpec()
	}

	return localctx
}

// IElementSetSpecContext is an interface to support dynamic dispatch.
type IElementSetSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsElementSetSpecContext differentiates from other interfaces.
	IsElementSetSpecContext()
}

type ElementSetSpecContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElementSetSpecContext() *ElementSetSpecContext {
	var p = new(ElementSetSpecContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_elementSetSpec
	return p
}

func (*ElementSetSpecContext) IsElementSetSpecContext() {}

func NewElementSetSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElementSetSpecContext {
	var p = new(ElementSetSpecContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_elementSetSpec

	return p
}

func (s *ElementSetSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *ElementSetSpecContext) Unions() IUnionsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnionsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnionsContext)
}

func (s *ElementSetSpecContext) ALL_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserALL_LITERAL, 0)
}

func (s *ElementSetSpecContext) Exclusions() IExclusionsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExclusionsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExclusionsContext)
}

func (s *ElementSetSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementSetSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElementSetSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterElementSetSpec(s)
	}
}

func (s *ElementSetSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitElementSetSpec(s)
	}
}

func (p *ASN_3gppParser) ElementSetSpec() (localctx IElementSetSpecContext) {
	localctx = NewElementSetSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, ASN_3gppParserRULE_elementSetSpec)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(787)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ASN_3gppParserTRUE_LITERAL, ASN_3gppParserFALSE_LITERAL, ASN_3gppParserTRUE_SMALL_LITERAL, ASN_3gppParserFALSE_SMALL_LITERAL, ASN_3gppParserL_BRACE, ASN_3gppParserMINUS, ASN_3gppParserMIN_LITERAL, ASN_3gppParserSIZE_LITERAL, ASN_3gppParserPATTERN_LITERAL, ASN_3gppParserNUMBER, ASN_3gppParserBSTRING, ASN_3gppParserCSTRING, ASN_3gppParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(784)
			p.Unions()
		}

	case ASN_3gppParserALL_LITERAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(785)
			p.Match(ASN_3gppParserALL_LITERAL)
		}
		{
			p.SetState(786)
			p.Exclusions()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IUnionsContext is an interface to support dynamic dispatch.
type IUnionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnionsContext differentiates from other interfaces.
	IsUnionsContext()
}

type UnionsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnionsContext() *UnionsContext {
	var p = new(UnionsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_unions
	return p
}

func (*UnionsContext) IsUnionsContext() {}

func NewUnionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnionsContext {
	var p = new(UnionsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_unions

	return p
}

func (s *UnionsContext) GetParser() antlr.Parser { return s.parser }

func (s *UnionsContext) AllIntersections() []IIntersectionsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIntersectionsContext)(nil)).Elem())
	var tst = make([]IIntersectionsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIntersectionsContext)
		}
	}

	return tst
}

func (s *UnionsContext) Intersections(i int) IIntersectionsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntersectionsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIntersectionsContext)
}

func (s *UnionsContext) AllUnionMark() []IUnionMarkContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IUnionMarkContext)(nil)).Elem())
	var tst = make([]IUnionMarkContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IUnionMarkContext)
		}
	}

	return tst
}

func (s *UnionsContext) UnionMark(i int) IUnionMarkContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnionMarkContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IUnionMarkContext)
}

func (s *UnionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterUnions(s)
	}
}

func (s *UnionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitUnions(s)
	}
}

func (p *ASN_3gppParser) Unions() (localctx IUnionsContext) {
	localctx = NewUnionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, ASN_3gppParserRULE_unions)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(789)
		p.Intersections()
	}

	p.SetState(795)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ASN_3gppParserPIPE || _la == ASN_3gppParserUNION_LITERAL {
		{
			p.SetState(790)
			p.UnionMark()
		}
		{
			p.SetState(791)
			p.Intersections()
		}

		p.SetState(797)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IExclusionsContext is an interface to support dynamic dispatch.
type IExclusionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExclusionsContext differentiates from other interfaces.
	IsExclusionsContext()
}

type ExclusionsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExclusionsContext() *ExclusionsContext {
	var p = new(ExclusionsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_exclusions
	return p
}

func (*ExclusionsContext) IsExclusionsContext() {}

func NewExclusionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExclusionsContext {
	var p = new(ExclusionsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_exclusions

	return p
}

func (s *ExclusionsContext) GetParser() antlr.Parser { return s.parser }

func (s *ExclusionsContext) EXCEPT_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserEXCEPT_LITERAL, 0)
}

func (s *ExclusionsContext) Elements() IElementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IElementsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IElementsContext)
}

func (s *ExclusionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExclusionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExclusionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterExclusions(s)
	}
}

func (s *ExclusionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitExclusions(s)
	}
}

func (p *ASN_3gppParser) Exclusions() (localctx IExclusionsContext) {
	localctx = NewExclusionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, ASN_3gppParserRULE_exclusions)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(798)
		p.Match(ASN_3gppParserEXCEPT_LITERAL)
	}
	{
		p.SetState(799)
		p.Elements()
	}

	return localctx
}

// IIntersectionsContext is an interface to support dynamic dispatch.
type IIntersectionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIntersectionsContext differentiates from other interfaces.
	IsIntersectionsContext()
}

type IntersectionsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIntersectionsContext() *IntersectionsContext {
	var p = new(IntersectionsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_intersections
	return p
}

func (*IntersectionsContext) IsIntersectionsContext() {}

func NewIntersectionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntersectionsContext {
	var p = new(IntersectionsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_intersections

	return p
}

func (s *IntersectionsContext) GetParser() antlr.Parser { return s.parser }

func (s *IntersectionsContext) AllIntersectionElements() []IIntersectionElementsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIntersectionElementsContext)(nil)).Elem())
	var tst = make([]IIntersectionElementsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIntersectionElementsContext)
		}
	}

	return tst
}

func (s *IntersectionsContext) IntersectionElements(i int) IIntersectionElementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntersectionElementsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIntersectionElementsContext)
}

func (s *IntersectionsContext) AllIntersectionMark() []IIntersectionMarkContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIntersectionMarkContext)(nil)).Elem())
	var tst = make([]IIntersectionMarkContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIntersectionMarkContext)
		}
	}

	return tst
}

func (s *IntersectionsContext) IntersectionMark(i int) IIntersectionMarkContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntersectionMarkContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIntersectionMarkContext)
}

func (s *IntersectionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntersectionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IntersectionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterIntersections(s)
	}
}

func (s *IntersectionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitIntersections(s)
	}
}

func (p *ASN_3gppParser) Intersections() (localctx IIntersectionsContext) {
	localctx = NewIntersectionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, ASN_3gppParserRULE_intersections)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(801)
		p.IntersectionElements()
	}

	p.SetState(807)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ASN_3gppParserPOWER || _la == ASN_3gppParserINTERSECTION_LITERAL {
		{
			p.SetState(802)
			p.IntersectionMark()
		}
		{
			p.SetState(803)
			p.IntersectionElements()
		}

		p.SetState(809)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IUnionMarkContext is an interface to support dynamic dispatch.
type IUnionMarkContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnionMarkContext differentiates from other interfaces.
	IsUnionMarkContext()
}

type UnionMarkContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnionMarkContext() *UnionMarkContext {
	var p = new(UnionMarkContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_unionMark
	return p
}

func (*UnionMarkContext) IsUnionMarkContext() {}

func NewUnionMarkContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnionMarkContext {
	var p = new(UnionMarkContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_unionMark

	return p
}

func (s *UnionMarkContext) GetParser() antlr.Parser { return s.parser }

func (s *UnionMarkContext) PIPE() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserPIPE, 0)
}

func (s *UnionMarkContext) UNION_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserUNION_LITERAL, 0)
}

func (s *UnionMarkContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnionMarkContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnionMarkContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterUnionMark(s)
	}
}

func (s *UnionMarkContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitUnionMark(s)
	}
}

func (p *ASN_3gppParser) UnionMark() (localctx IUnionMarkContext) {
	localctx = NewUnionMarkContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, ASN_3gppParserRULE_unionMark)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(810)
		_la = p.GetTokenStream().LA(1)

		if !(_la == ASN_3gppParserPIPE || _la == ASN_3gppParserUNION_LITERAL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IIntersectionMarkContext is an interface to support dynamic dispatch.
type IIntersectionMarkContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIntersectionMarkContext differentiates from other interfaces.
	IsIntersectionMarkContext()
}

type IntersectionMarkContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIntersectionMarkContext() *IntersectionMarkContext {
	var p = new(IntersectionMarkContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_intersectionMark
	return p
}

func (*IntersectionMarkContext) IsIntersectionMarkContext() {}

func NewIntersectionMarkContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntersectionMarkContext {
	var p = new(IntersectionMarkContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_intersectionMark

	return p
}

func (s *IntersectionMarkContext) GetParser() antlr.Parser { return s.parser }

func (s *IntersectionMarkContext) POWER() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserPOWER, 0)
}

func (s *IntersectionMarkContext) INTERSECTION_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserINTERSECTION_LITERAL, 0)
}

func (s *IntersectionMarkContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntersectionMarkContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IntersectionMarkContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterIntersectionMark(s)
	}
}

func (s *IntersectionMarkContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitIntersectionMark(s)
	}
}

func (p *ASN_3gppParser) IntersectionMark() (localctx IIntersectionMarkContext) {
	localctx = NewIntersectionMarkContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, ASN_3gppParserRULE_intersectionMark)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(812)
		_la = p.GetTokenStream().LA(1)

		if !(_la == ASN_3gppParserPOWER || _la == ASN_3gppParserINTERSECTION_LITERAL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IElementsContext is an interface to support dynamic dispatch.
type IElementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsElementsContext differentiates from other interfaces.
	IsElementsContext()
}

type ElementsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElementsContext() *ElementsContext {
	var p = new(ElementsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_elements
	return p
}

func (*ElementsContext) IsElementsContext() {}

func NewElementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElementsContext {
	var p = new(ElementsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_elements

	return p
}

func (s *ElementsContext) GetParser() antlr.Parser { return s.parser }

func (s *ElementsContext) SubtypeElements() ISubtypeElementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubtypeElementsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubtypeElementsContext)
}

func (s *ElementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElementsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterElements(s)
	}
}

func (s *ElementsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitElements(s)
	}
}

func (p *ASN_3gppParser) Elements() (localctx IElementsContext) {
	localctx = NewElementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, ASN_3gppParserRULE_elements)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(814)
		p.SubtypeElements()
	}

	return localctx
}

// IObjectSetElementsContext is an interface to support dynamic dispatch.
type IObjectSetElementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObjectSetElementsContext differentiates from other interfaces.
	IsObjectSetElementsContext()
}

type ObjectSetElementsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObjectSetElementsContext() *ObjectSetElementsContext {
	var p = new(ObjectSetElementsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_objectSetElements
	return p
}

func (*ObjectSetElementsContext) IsObjectSetElementsContext() {}

func NewObjectSetElementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjectSetElementsContext {
	var p = new(ObjectSetElementsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_objectSetElements

	return p
}

func (s *ObjectSetElementsContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjectSetElementsContext) Object() IObjectContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObjectContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObjectContext)
}

func (s *ObjectSetElementsContext) DefinedObject() IDefinedObjectContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDefinedObjectContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDefinedObjectContext)
}

func (s *ObjectSetElementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectSetElementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObjectSetElementsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterObjectSetElements(s)
	}
}

func (s *ObjectSetElementsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitObjectSetElements(s)
	}
}

func (p *ASN_3gppParser) ObjectSetElements() (localctx IObjectSetElementsContext) {
	localctx = NewObjectSetElementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, ASN_3gppParserRULE_objectSetElements)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(818)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 84, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(816)
			p.Object()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(817)
			p.DefinedObject()
		}

	}

	return localctx
}

// IIntersectionElementsContext is an interface to support dynamic dispatch.
type IIntersectionElementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIntersectionElementsContext differentiates from other interfaces.
	IsIntersectionElementsContext()
}

type IntersectionElementsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIntersectionElementsContext() *IntersectionElementsContext {
	var p = new(IntersectionElementsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_intersectionElements
	return p
}

func (*IntersectionElementsContext) IsIntersectionElementsContext() {}

func NewIntersectionElementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntersectionElementsContext {
	var p = new(IntersectionElementsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_intersectionElements

	return p
}

func (s *IntersectionElementsContext) GetParser() antlr.Parser { return s.parser }

func (s *IntersectionElementsContext) Elements() IElementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IElementsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IElementsContext)
}

func (s *IntersectionElementsContext) Exclusions() IExclusionsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExclusionsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExclusionsContext)
}

func (s *IntersectionElementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntersectionElementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IntersectionElementsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterIntersectionElements(s)
	}
}

func (s *IntersectionElementsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitIntersectionElements(s)
	}
}

func (p *ASN_3gppParser) IntersectionElements() (localctx IIntersectionElementsContext) {
	localctx = NewIntersectionElementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, ASN_3gppParserRULE_intersectionElements)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(820)
		p.Elements()
	}
	p.SetState(822)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ASN_3gppParserEXCEPT_LITERAL {
		{
			p.SetState(821)
			p.Exclusions()
		}

	}

	return localctx
}

// ISubtypeElementsContext is an interface to support dynamic dispatch.
type ISubtypeElementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSubtypeElementsContext differentiates from other interfaces.
	IsSubtypeElementsContext()
}

type SubtypeElementsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubtypeElementsContext() *SubtypeElementsContext {
	var p = new(SubtypeElementsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_subtypeElements
	return p
}

func (*SubtypeElementsContext) IsSubtypeElementsContext() {}

func NewSubtypeElementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubtypeElementsContext {
	var p = new(SubtypeElementsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_subtypeElements

	return p
}

func (s *SubtypeElementsContext) GetParser() antlr.Parser { return s.parser }

func (s *SubtypeElementsContext) DOUBLE_DOT() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserDOUBLE_DOT, 0)
}

func (s *SubtypeElementsContext) AllValue() []IValueContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IValueContext)(nil)).Elem())
	var tst = make([]IValueContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IValueContext)
		}
	}

	return tst
}

func (s *SubtypeElementsContext) Value(i int) IValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IValueContext)
}

func (s *SubtypeElementsContext) MIN_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserMIN_LITERAL, 0)
}

func (s *SubtypeElementsContext) MAX_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserMAX_LITERAL, 0)
}

func (s *SubtypeElementsContext) AllLESS_THAN() []antlr.TerminalNode {
	return s.GetTokens(ASN_3gppParserLESS_THAN)
}

func (s *SubtypeElementsContext) LESS_THAN(i int) antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserLESS_THAN, i)
}

func (s *SubtypeElementsContext) SizeConstraint() ISizeConstraintContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISizeConstraintContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISizeConstraintContext)
}

func (s *SubtypeElementsContext) PATTERN_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserPATTERN_LITERAL, 0)
}

func (s *SubtypeElementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubtypeElementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubtypeElementsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterSubtypeElements(s)
	}
}

func (s *SubtypeElementsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitSubtypeElements(s)
	}
}

func (p *ASN_3gppParser) SubtypeElements() (localctx ISubtypeElementsContext) {
	localctx = NewSubtypeElementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, ASN_3gppParserRULE_subtypeElements)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(843)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 90, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(826)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case ASN_3gppParserTRUE_LITERAL, ASN_3gppParserFALSE_LITERAL, ASN_3gppParserTRUE_SMALL_LITERAL, ASN_3gppParserFALSE_SMALL_LITERAL, ASN_3gppParserL_BRACE, ASN_3gppParserMINUS, ASN_3gppParserNUMBER, ASN_3gppParserBSTRING, ASN_3gppParserCSTRING, ASN_3gppParserIDENTIFIER:
			{
				p.SetState(824)
				p.Value()
			}

		case ASN_3gppParserMIN_LITERAL:
			{
				p.SetState(825)
				p.Match(ASN_3gppParserMIN_LITERAL)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		p.SetState(829)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ASN_3gppParserLESS_THAN {
			{
				p.SetState(828)
				p.Match(ASN_3gppParserLESS_THAN)
			}

		}
		{
			p.SetState(831)
			p.Match(ASN_3gppParserDOUBLE_DOT)
		}
		p.SetState(833)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ASN_3gppParserLESS_THAN {
			{
				p.SetState(832)
				p.Match(ASN_3gppParserLESS_THAN)
			}

		}
		p.SetState(837)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case ASN_3gppParserTRUE_LITERAL, ASN_3gppParserFALSE_LITERAL, ASN_3gppParserTRUE_SMALL_LITERAL, ASN_3gppParserFALSE_SMALL_LITERAL, ASN_3gppParserL_BRACE, ASN_3gppParserMINUS, ASN_3gppParserNUMBER, ASN_3gppParserBSTRING, ASN_3gppParserCSTRING, ASN_3gppParserIDENTIFIER:
			{
				p.SetState(835)
				p.Value()
			}

		case ASN_3gppParserMAX_LITERAL:
			{
				p.SetState(836)
				p.Match(ASN_3gppParserMAX_LITERAL)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(839)
			p.SizeConstraint()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(840)
			p.Match(ASN_3gppParserPATTERN_LITERAL)
		}
		{
			p.SetState(841)
			p.Value()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(842)
			p.Value()
		}

	}

	return localctx
}

// IVariableTypeValueSetFieldSpecContext is an interface to support dynamic dispatch.
type IVariableTypeValueSetFieldSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariableTypeValueSetFieldSpecContext differentiates from other interfaces.
	IsVariableTypeValueSetFieldSpecContext()
}

type VariableTypeValueSetFieldSpecContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableTypeValueSetFieldSpecContext() *VariableTypeValueSetFieldSpecContext {
	var p = new(VariableTypeValueSetFieldSpecContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_variableTypeValueSetFieldSpec
	return p
}

func (*VariableTypeValueSetFieldSpecContext) IsVariableTypeValueSetFieldSpecContext() {}

func NewVariableTypeValueSetFieldSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableTypeValueSetFieldSpecContext {
	var p = new(VariableTypeValueSetFieldSpecContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_variableTypeValueSetFieldSpec

	return p
}

func (s *VariableTypeValueSetFieldSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableTypeValueSetFieldSpecContext) AMPERSAND() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserAMPERSAND, 0)
}

func (s *VariableTypeValueSetFieldSpecContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserIDENTIFIER, 0)
}

func (s *VariableTypeValueSetFieldSpecContext) FieldName() IFieldNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFieldNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFieldNameContext)
}

func (s *VariableTypeValueSetFieldSpecContext) ValueSetOptionalitySpec() IValueSetOptionalitySpecContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueSetOptionalitySpecContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueSetOptionalitySpecContext)
}

func (s *VariableTypeValueSetFieldSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableTypeValueSetFieldSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableTypeValueSetFieldSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterVariableTypeValueSetFieldSpec(s)
	}
}

func (s *VariableTypeValueSetFieldSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitVariableTypeValueSetFieldSpec(s)
	}
}

func (p *ASN_3gppParser) VariableTypeValueSetFieldSpec() (localctx IVariableTypeValueSetFieldSpecContext) {
	localctx = NewVariableTypeValueSetFieldSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, ASN_3gppParserRULE_variableTypeValueSetFieldSpec)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(845)
		p.Match(ASN_3gppParserAMPERSAND)
	}
	{
		p.SetState(846)
		p.Match(ASN_3gppParserIDENTIFIER)
	}
	{
		p.SetState(847)
		p.FieldName()
	}
	p.SetState(849)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ASN_3gppParserOPTIONAL_LITERAL || _la == ASN_3gppParserDEFAULT_LITERAL {
		{
			p.SetState(848)
			p.ValueSetOptionalitySpec()
		}

	}

	return localctx
}

// IObjectFieldSpecContext is an interface to support dynamic dispatch.
type IObjectFieldSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObjectFieldSpecContext differentiates from other interfaces.
	IsObjectFieldSpecContext()
}

type ObjectFieldSpecContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObjectFieldSpecContext() *ObjectFieldSpecContext {
	var p = new(ObjectFieldSpecContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_objectFieldSpec
	return p
}

func (*ObjectFieldSpecContext) IsObjectFieldSpecContext() {}

func NewObjectFieldSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjectFieldSpecContext {
	var p = new(ObjectFieldSpecContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_objectFieldSpec

	return p
}

func (s *ObjectFieldSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjectFieldSpecContext) AMPERSAND() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserAMPERSAND, 0)
}

func (s *ObjectFieldSpecContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserIDENTIFIER, 0)
}

func (s *ObjectFieldSpecContext) DefinedObjectClass() IDefinedObjectClassContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDefinedObjectClassContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDefinedObjectClassContext)
}

func (s *ObjectFieldSpecContext) ObjectOptionalitySpec() IObjectOptionalitySpecContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObjectOptionalitySpecContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObjectOptionalitySpecContext)
}

func (s *ObjectFieldSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectFieldSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObjectFieldSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterObjectFieldSpec(s)
	}
}

func (s *ObjectFieldSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitObjectFieldSpec(s)
	}
}

func (p *ASN_3gppParser) ObjectFieldSpec() (localctx IObjectFieldSpecContext) {
	localctx = NewObjectFieldSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, ASN_3gppParserRULE_objectFieldSpec)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(851)
		p.Match(ASN_3gppParserAMPERSAND)
	}
	{
		p.SetState(852)
		p.Match(ASN_3gppParserIDENTIFIER)
	}
	{
		p.SetState(853)
		p.DefinedObjectClass()
	}
	p.SetState(855)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ASN_3gppParserOPTIONAL_LITERAL || _la == ASN_3gppParserDEFAULT_LITERAL {
		{
			p.SetState(854)
			p.ObjectOptionalitySpec()
		}

	}

	return localctx
}

// IObjectOptionalitySpecContext is an interface to support dynamic dispatch.
type IObjectOptionalitySpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObjectOptionalitySpecContext differentiates from other interfaces.
	IsObjectOptionalitySpecContext()
}

type ObjectOptionalitySpecContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObjectOptionalitySpecContext() *ObjectOptionalitySpecContext {
	var p = new(ObjectOptionalitySpecContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_objectOptionalitySpec
	return p
}

func (*ObjectOptionalitySpecContext) IsObjectOptionalitySpecContext() {}

func NewObjectOptionalitySpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjectOptionalitySpecContext {
	var p = new(ObjectOptionalitySpecContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_objectOptionalitySpec

	return p
}

func (s *ObjectOptionalitySpecContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjectOptionalitySpecContext) OPTIONAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserOPTIONAL_LITERAL, 0)
}

func (s *ObjectOptionalitySpecContext) DEFAULT_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserDEFAULT_LITERAL, 0)
}

func (s *ObjectOptionalitySpecContext) Object() IObjectContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObjectContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObjectContext)
}

func (s *ObjectOptionalitySpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectOptionalitySpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObjectOptionalitySpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterObjectOptionalitySpec(s)
	}
}

func (s *ObjectOptionalitySpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitObjectOptionalitySpec(s)
	}
}

func (p *ASN_3gppParser) ObjectOptionalitySpec() (localctx IObjectOptionalitySpecContext) {
	localctx = NewObjectOptionalitySpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, ASN_3gppParserRULE_objectOptionalitySpec)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(860)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ASN_3gppParserOPTIONAL_LITERAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(857)
			p.Match(ASN_3gppParserOPTIONAL_LITERAL)
		}

	case ASN_3gppParserDEFAULT_LITERAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(858)
			p.Match(ASN_3gppParserDEFAULT_LITERAL)
		}
		{
			p.SetState(859)
			p.Object()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IObjectSetFieldSpecContext is an interface to support dynamic dispatch.
type IObjectSetFieldSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObjectSetFieldSpecContext differentiates from other interfaces.
	IsObjectSetFieldSpecContext()
}

type ObjectSetFieldSpecContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObjectSetFieldSpecContext() *ObjectSetFieldSpecContext {
	var p = new(ObjectSetFieldSpecContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_objectSetFieldSpec
	return p
}

func (*ObjectSetFieldSpecContext) IsObjectSetFieldSpecContext() {}

func NewObjectSetFieldSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjectSetFieldSpecContext {
	var p = new(ObjectSetFieldSpecContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_objectSetFieldSpec

	return p
}

func (s *ObjectSetFieldSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjectSetFieldSpecContext) AMPERSAND() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserAMPERSAND, 0)
}

func (s *ObjectSetFieldSpecContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserIDENTIFIER, 0)
}

func (s *ObjectSetFieldSpecContext) DefinedObjectClass() IDefinedObjectClassContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDefinedObjectClassContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDefinedObjectClassContext)
}

func (s *ObjectSetFieldSpecContext) ObjectSetOptionalitySpec() IObjectSetOptionalitySpecContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObjectSetOptionalitySpecContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObjectSetOptionalitySpecContext)
}

func (s *ObjectSetFieldSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectSetFieldSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObjectSetFieldSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterObjectSetFieldSpec(s)
	}
}

func (s *ObjectSetFieldSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitObjectSetFieldSpec(s)
	}
}

func (p *ASN_3gppParser) ObjectSetFieldSpec() (localctx IObjectSetFieldSpecContext) {
	localctx = NewObjectSetFieldSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, ASN_3gppParserRULE_objectSetFieldSpec)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(862)
		p.Match(ASN_3gppParserAMPERSAND)
	}
	{
		p.SetState(863)
		p.Match(ASN_3gppParserIDENTIFIER)
	}
	{
		p.SetState(864)
		p.DefinedObjectClass()
	}
	p.SetState(866)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ASN_3gppParserOPTIONAL_LITERAL || _la == ASN_3gppParserDEFAULT_LITERAL {
		{
			p.SetState(865)
			p.ObjectSetOptionalitySpec()
		}

	}

	return localctx
}

// IObjectSetOptionalitySpecContext is an interface to support dynamic dispatch.
type IObjectSetOptionalitySpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObjectSetOptionalitySpecContext differentiates from other interfaces.
	IsObjectSetOptionalitySpecContext()
}

type ObjectSetOptionalitySpecContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObjectSetOptionalitySpecContext() *ObjectSetOptionalitySpecContext {
	var p = new(ObjectSetOptionalitySpecContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_objectSetOptionalitySpec
	return p
}

func (*ObjectSetOptionalitySpecContext) IsObjectSetOptionalitySpecContext() {}

func NewObjectSetOptionalitySpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjectSetOptionalitySpecContext {
	var p = new(ObjectSetOptionalitySpecContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_objectSetOptionalitySpec

	return p
}

func (s *ObjectSetOptionalitySpecContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjectSetOptionalitySpecContext) OPTIONAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserOPTIONAL_LITERAL, 0)
}

func (s *ObjectSetOptionalitySpecContext) DEFAULT_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserDEFAULT_LITERAL, 0)
}

func (s *ObjectSetOptionalitySpecContext) ObjectSet() IObjectSetContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObjectSetContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObjectSetContext)
}

func (s *ObjectSetOptionalitySpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectSetOptionalitySpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObjectSetOptionalitySpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterObjectSetOptionalitySpec(s)
	}
}

func (s *ObjectSetOptionalitySpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitObjectSetOptionalitySpec(s)
	}
}

func (p *ASN_3gppParser) ObjectSetOptionalitySpec() (localctx IObjectSetOptionalitySpecContext) {
	localctx = NewObjectSetOptionalitySpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, ASN_3gppParserRULE_objectSetOptionalitySpec)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(871)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ASN_3gppParserOPTIONAL_LITERAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(868)
			p.Match(ASN_3gppParserOPTIONAL_LITERAL)
		}

	case ASN_3gppParserDEFAULT_LITERAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(869)
			p.Match(ASN_3gppParserDEFAULT_LITERAL)
		}
		{
			p.SetState(870)
			p.ObjectSet()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ITypeAssignmentContext is an interface to support dynamic dispatch.
type ITypeAssignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeAssignmentContext differentiates from other interfaces.
	IsTypeAssignmentContext()
}

type TypeAssignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeAssignmentContext() *TypeAssignmentContext {
	var p = new(TypeAssignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_typeAssignment
	return p
}

func (*TypeAssignmentContext) IsTypeAssignmentContext() {}

func NewTypeAssignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeAssignmentContext {
	var p = new(TypeAssignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_typeAssignment

	return p
}

func (s *TypeAssignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeAssignmentContext) ASSIGN_OP() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserASSIGN_OP, 0)
}

func (s *TypeAssignmentContext) AsnType() IAsnTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAsnTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAsnTypeContext)
}

func (s *TypeAssignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeAssignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeAssignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterTypeAssignment(s)
	}
}

func (s *TypeAssignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitTypeAssignment(s)
	}
}

func (p *ASN_3gppParser) TypeAssignment() (localctx ITypeAssignmentContext) {
	localctx = NewTypeAssignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, ASN_3gppParserRULE_typeAssignment)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(873)
		p.Match(ASN_3gppParserASSIGN_OP)
	}
	{
		p.SetState(874)
		p.AsnType()
	}

	return localctx
}

// IValueAssignmentContext is an interface to support dynamic dispatch.
type IValueAssignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsValueAssignmentContext differentiates from other interfaces.
	IsValueAssignmentContext()
}

type ValueAssignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValueAssignmentContext() *ValueAssignmentContext {
	var p = new(ValueAssignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_valueAssignment
	return p
}

func (*ValueAssignmentContext) IsValueAssignmentContext() {}

func NewValueAssignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValueAssignmentContext {
	var p = new(ValueAssignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_valueAssignment

	return p
}

func (s *ValueAssignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *ValueAssignmentContext) AsnType() IAsnTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAsnTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAsnTypeContext)
}

func (s *ValueAssignmentContext) ASSIGN_OP() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserASSIGN_OP, 0)
}

func (s *ValueAssignmentContext) Value() IValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueContext)
}

func (s *ValueAssignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueAssignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ValueAssignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterValueAssignment(s)
	}
}

func (s *ValueAssignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitValueAssignment(s)
	}
}

func (p *ASN_3gppParser) ValueAssignment() (localctx IValueAssignmentContext) {
	localctx = NewValueAssignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, ASN_3gppParserRULE_valueAssignment)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(876)
		p.AsnType()
	}
	{
		p.SetState(877)
		p.Match(ASN_3gppParserASSIGN_OP)
	}
	{
		p.SetState(878)
		p.Value()
	}

	return localctx
}

// IAsnTypeContext is an interface to support dynamic dispatch.
type IAsnTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAsnTypeContext differentiates from other interfaces.
	IsAsnTypeContext()
}

type AsnTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAsnTypeContext() *AsnTypeContext {
	var p = new(AsnTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_asnType
	return p
}

func (*AsnTypeContext) IsAsnTypeContext() {}

func NewAsnTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AsnTypeContext {
	var p = new(AsnTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_asnType

	return p
}

func (s *AsnTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *AsnTypeContext) BuiltinType() IBuiltinTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBuiltinTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBuiltinTypeContext)
}

func (s *AsnTypeContext) ReferencedType() IReferencedTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReferencedTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReferencedTypeContext)
}

func (s *AsnTypeContext) AllConstraint() []IConstraintContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IConstraintContext)(nil)).Elem())
	var tst = make([]IConstraintContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IConstraintContext)
		}
	}

	return tst
}

func (s *AsnTypeContext) Constraint(i int) IConstraintContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstraintContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IConstraintContext)
}

func (s *AsnTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AsnTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AsnTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterAsnType(s)
	}
}

func (s *AsnTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitAsnType(s)
	}
}

func (p *ASN_3gppParser) AsnType() (localctx IAsnTypeContext) {
	localctx = NewAsnTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, ASN_3gppParserRULE_asnType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(882)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 96, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(880)
			p.BuiltinType()
		}

	case 2:
		{
			p.SetState(881)
			p.ReferencedType()
		}

	}
	p.SetState(887)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 97, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(884)
				p.Constraint()
			}

		}
		p.SetState(889)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 97, p.GetParserRuleContext())
	}

	return localctx
}

// IBuiltinTypeContext is an interface to support dynamic dispatch.
type IBuiltinTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBuiltinTypeContext differentiates from other interfaces.
	IsBuiltinTypeContext()
}

type BuiltinTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBuiltinTypeContext() *BuiltinTypeContext {
	var p = new(BuiltinTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_builtinType
	return p
}

func (*BuiltinTypeContext) IsBuiltinTypeContext() {}

func NewBuiltinTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BuiltinTypeContext {
	var p = new(BuiltinTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_builtinType

	return p
}

func (s *BuiltinTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *BuiltinTypeContext) OctetStringType() IOctetStringTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOctetStringTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOctetStringTypeContext)
}

func (s *BuiltinTypeContext) BitStringType() IBitStringTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBitStringTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBitStringTypeContext)
}

func (s *BuiltinTypeContext) ChoiceType() IChoiceTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IChoiceTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IChoiceTypeContext)
}

func (s *BuiltinTypeContext) EnumeratedType() IEnumeratedTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnumeratedTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnumeratedTypeContext)
}

func (s *BuiltinTypeContext) IntegerType() IIntegerTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerTypeContext)
}

func (s *BuiltinTypeContext) SequenceType() ISequenceTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISequenceTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISequenceTypeContext)
}

func (s *BuiltinTypeContext) SequenceOfType() ISequenceOfTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISequenceOfTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISequenceOfTypeContext)
}

func (s *BuiltinTypeContext) SetType() ISetTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISetTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISetTypeContext)
}

func (s *BuiltinTypeContext) SetOfType() ISetOfTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISetOfTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISetOfTypeContext)
}

func (s *BuiltinTypeContext) Objectidentifiertype() IObjectidentifiertypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObjectidentifiertypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObjectidentifiertypeContext)
}

func (s *BuiltinTypeContext) ObjectClassFieldType() IObjectClassFieldTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObjectClassFieldTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObjectClassFieldTypeContext)
}

func (s *BuiltinTypeContext) BOOLEAN_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserBOOLEAN_LITERAL, 0)
}

func (s *BuiltinTypeContext) NULL_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserNULL_LITERAL, 0)
}

func (s *BuiltinTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BuiltinTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BuiltinTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterBuiltinType(s)
	}
}

func (s *BuiltinTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitBuiltinType(s)
	}
}

func (p *ASN_3gppParser) BuiltinType() (localctx IBuiltinTypeContext) {
	localctx = NewBuiltinTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, ASN_3gppParserRULE_builtinType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(903)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 98, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(890)
			p.OctetStringType()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(891)
			p.BitStringType()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(892)
			p.ChoiceType()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(893)
			p.EnumeratedType()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(894)
			p.IntegerType()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(895)
			p.SequenceType()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(896)
			p.SequenceOfType()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(897)
			p.SetType()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(898)
			p.SetOfType()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(899)
			p.Objectidentifiertype()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(900)
			p.ObjectClassFieldType()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(901)
			p.Match(ASN_3gppParserBOOLEAN_LITERAL)
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(902)
			p.Match(ASN_3gppParserNULL_LITERAL)
		}

	}

	return localctx
}

// IObjectClassFieldTypeContext is an interface to support dynamic dispatch.
type IObjectClassFieldTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObjectClassFieldTypeContext differentiates from other interfaces.
	IsObjectClassFieldTypeContext()
}

type ObjectClassFieldTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObjectClassFieldTypeContext() *ObjectClassFieldTypeContext {
	var p = new(ObjectClassFieldTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_objectClassFieldType
	return p
}

func (*ObjectClassFieldTypeContext) IsObjectClassFieldTypeContext() {}

func NewObjectClassFieldTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjectClassFieldTypeContext {
	var p = new(ObjectClassFieldTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_objectClassFieldType

	return p
}

func (s *ObjectClassFieldTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjectClassFieldTypeContext) DefinedObjectClass() IDefinedObjectClassContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDefinedObjectClassContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDefinedObjectClassContext)
}

func (s *ObjectClassFieldTypeContext) DOT() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserDOT, 0)
}

func (s *ObjectClassFieldTypeContext) FieldName() IFieldNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFieldNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFieldNameContext)
}

func (s *ObjectClassFieldTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectClassFieldTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObjectClassFieldTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterObjectClassFieldType(s)
	}
}

func (s *ObjectClassFieldTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitObjectClassFieldType(s)
	}
}

func (p *ASN_3gppParser) ObjectClassFieldType() (localctx IObjectClassFieldTypeContext) {
	localctx = NewObjectClassFieldTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, ASN_3gppParserRULE_objectClassFieldType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(905)
		p.DefinedObjectClass()
	}
	{
		p.SetState(906)
		p.Match(ASN_3gppParserDOT)
	}
	{
		p.SetState(907)
		p.FieldName()
	}

	return localctx
}

// ISetTypeContext is an interface to support dynamic dispatch.
type ISetTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSetTypeContext differentiates from other interfaces.
	IsSetTypeContext()
}

type SetTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetTypeContext() *SetTypeContext {
	var p = new(SetTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_setType
	return p
}

func (*SetTypeContext) IsSetTypeContext() {}

func NewSetTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetTypeContext {
	var p = new(SetTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_setType

	return p
}

func (s *SetTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *SetTypeContext) SET_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserSET_LITERAL, 0)
}

func (s *SetTypeContext) L_BRACE() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserL_BRACE, 0)
}

func (s *SetTypeContext) R_BRACE() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserR_BRACE, 0)
}

func (s *SetTypeContext) ExtensionAndException() IExtensionAndExceptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExtensionAndExceptionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExtensionAndExceptionContext)
}

func (s *SetTypeContext) OptionalExtensionMarker() IOptionalExtensionMarkerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOptionalExtensionMarkerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOptionalExtensionMarkerContext)
}

func (s *SetTypeContext) ComponentTypeLists() IComponentTypeListsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComponentTypeListsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComponentTypeListsContext)
}

func (s *SetTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterSetType(s)
	}
}

func (s *SetTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitSetType(s)
	}
}

func (p *ASN_3gppParser) SetType() (localctx ISetTypeContext) {
	localctx = NewSetTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, ASN_3gppParserRULE_setType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(909)
		p.Match(ASN_3gppParserSET_LITERAL)
	}
	{
		p.SetState(910)
		p.Match(ASN_3gppParserL_BRACE)
	}
	p.SetState(915)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 99, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(911)
			p.ExtensionAndException()
		}
		{
			p.SetState(912)
			p.OptionalExtensionMarker()
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 99, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(914)
			p.ComponentTypeLists()
		}

	}
	{
		p.SetState(917)
		p.Match(ASN_3gppParserR_BRACE)
	}

	return localctx
}

// ISetOfTypeContext is an interface to support dynamic dispatch.
type ISetOfTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSetOfTypeContext differentiates from other interfaces.
	IsSetOfTypeContext()
}

type SetOfTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetOfTypeContext() *SetOfTypeContext {
	var p = new(SetOfTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_setOfType
	return p
}

func (*SetOfTypeContext) IsSetOfTypeContext() {}

func NewSetOfTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetOfTypeContext {
	var p = new(SetOfTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_setOfType

	return p
}

func (s *SetOfTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *SetOfTypeContext) SET_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserSET_LITERAL, 0)
}

func (s *SetOfTypeContext) OF_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserOF_LITERAL, 0)
}

func (s *SetOfTypeContext) AsnType() IAsnTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAsnTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAsnTypeContext)
}

func (s *SetOfTypeContext) NamedType() INamedTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INamedTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INamedTypeContext)
}

func (s *SetOfTypeContext) Constraint() IConstraintContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstraintContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstraintContext)
}

func (s *SetOfTypeContext) SizeConstraint() ISizeConstraintContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISizeConstraintContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISizeConstraintContext)
}

func (s *SetOfTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetOfTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetOfTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterSetOfType(s)
	}
}

func (s *SetOfTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitSetOfType(s)
	}
}

func (p *ASN_3gppParser) SetOfType() (localctx ISetOfTypeContext) {
	localctx = NewSetOfTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, ASN_3gppParserRULE_setOfType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(919)
		p.Match(ASN_3gppParserSET_LITERAL)
	}
	p.SetState(922)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ASN_3gppParserL_PARAN:
		{
			p.SetState(920)
			p.Constraint()
		}

	case ASN_3gppParserSIZE_LITERAL:
		{
			p.SetState(921)
			p.SizeConstraint()
		}

	case ASN_3gppParserOF_LITERAL:

	default:
	}
	{
		p.SetState(924)
		p.Match(ASN_3gppParserOF_LITERAL)
	}
	p.SetState(927)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 101, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(925)
			p.AsnType()
		}

	case 2:
		{
			p.SetState(926)
			p.NamedType()
		}

	}

	return localctx
}

// IReferencedTypeContext is an interface to support dynamic dispatch.
type IReferencedTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReferencedTypeContext differentiates from other interfaces.
	IsReferencedTypeContext()
}

type ReferencedTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReferencedTypeContext() *ReferencedTypeContext {
	var p = new(ReferencedTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_referencedType
	return p
}

func (*ReferencedTypeContext) IsReferencedTypeContext() {}

func NewReferencedTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReferencedTypeContext {
	var p = new(ReferencedTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_referencedType

	return p
}

func (s *ReferencedTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ReferencedTypeContext) DefinedType() IDefinedTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDefinedTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDefinedTypeContext)
}

func (s *ReferencedTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReferencedTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReferencedTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterReferencedType(s)
	}
}

func (s *ReferencedTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitReferencedType(s)
	}
}

func (p *ASN_3gppParser) ReferencedType() (localctx IReferencedTypeContext) {
	localctx = NewReferencedTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, ASN_3gppParserRULE_referencedType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(929)
		p.DefinedType()
	}

	return localctx
}

// IDefinedTypeContext is an interface to support dynamic dispatch.
type IDefinedTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDefinedTypeContext differentiates from other interfaces.
	IsDefinedTypeContext()
}

type DefinedTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefinedTypeContext() *DefinedTypeContext {
	var p = new(DefinedTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_definedType
	return p
}

func (*DefinedTypeContext) IsDefinedTypeContext() {}

func NewDefinedTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefinedTypeContext {
	var p = new(DefinedTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_definedType

	return p
}

func (s *DefinedTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *DefinedTypeContext) AllIDENTIFIER() []antlr.TerminalNode {
	return s.GetTokens(ASN_3gppParserIDENTIFIER)
}

func (s *DefinedTypeContext) IDENTIFIER(i int) antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserIDENTIFIER, i)
}

func (s *DefinedTypeContext) DOT() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserDOT, 0)
}

func (s *DefinedTypeContext) ActualParameterList() IActualParameterListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IActualParameterListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IActualParameterListContext)
}

func (s *DefinedTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefinedTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DefinedTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterDefinedType(s)
	}
}

func (s *DefinedTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitDefinedType(s)
	}
}

func (p *ASN_3gppParser) DefinedType() (localctx IDefinedTypeContext) {
	localctx = NewDefinedTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, ASN_3gppParserRULE_definedType)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(931)
		p.Match(ASN_3gppParserIDENTIFIER)
	}
	p.SetState(934)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ASN_3gppParserDOT {
		{
			p.SetState(932)
			p.Match(ASN_3gppParserDOT)
		}
		{
			p.SetState(933)
			p.Match(ASN_3gppParserIDENTIFIER)
		}

	}
	p.SetState(937)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 103, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(936)
			p.ActualParameterList()
		}

	}

	return localctx
}

// IConstraintContext is an interface to support dynamic dispatch.
type IConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstraintContext differentiates from other interfaces.
	IsConstraintContext()
}

type ConstraintContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstraintContext() *ConstraintContext {
	var p = new(ConstraintContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_constraint
	return p
}

func (*ConstraintContext) IsConstraintContext() {}

func NewConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstraintContext {
	var p = new(ConstraintContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_constraint

	return p
}

func (s *ConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstraintContext) L_PARAN() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserL_PARAN, 0)
}

func (s *ConstraintContext) ConstraintSpec() IConstraintSpecContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstraintSpecContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstraintSpecContext)
}

func (s *ConstraintContext) R_PARAN() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserR_PARAN, 0)
}

func (s *ConstraintContext) ExceptionSpec() IExceptionSpecContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExceptionSpecContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExceptionSpecContext)
}

func (s *ConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterConstraint(s)
	}
}

func (s *ConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitConstraint(s)
	}
}

func (p *ASN_3gppParser) Constraint() (localctx IConstraintContext) {
	localctx = NewConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, ASN_3gppParserRULE_constraint)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(939)
		p.Match(ASN_3gppParserL_PARAN)
	}
	{
		p.SetState(940)
		p.ConstraintSpec()
	}
	p.SetState(942)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ASN_3gppParserEXCLAM {
		{
			p.SetState(941)
			p.ExceptionSpec()
		}

	}
	{
		p.SetState(944)
		p.Match(ASN_3gppParserR_PARAN)
	}

	return localctx
}

// IConstraintSpecContext is an interface to support dynamic dispatch.
type IConstraintSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstraintSpecContext differentiates from other interfaces.
	IsConstraintSpecContext()
}

type ConstraintSpecContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstraintSpecContext() *ConstraintSpecContext {
	var p = new(ConstraintSpecContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_constraintSpec
	return p
}

func (*ConstraintSpecContext) IsConstraintSpecContext() {}

func NewConstraintSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstraintSpecContext {
	var p = new(ConstraintSpecContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_constraintSpec

	return p
}

func (s *ConstraintSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstraintSpecContext) GeneralConstraint() IGeneralConstraintContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGeneralConstraintContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGeneralConstraintContext)
}

func (s *ConstraintSpecContext) SubtypeConstraint() ISubtypeConstraintContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubtypeConstraintContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubtypeConstraintContext)
}

func (s *ConstraintSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstraintSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstraintSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterConstraintSpec(s)
	}
}

func (s *ConstraintSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitConstraintSpec(s)
	}
}

func (p *ASN_3gppParser) ConstraintSpec() (localctx IConstraintSpecContext) {
	localctx = NewConstraintSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, ASN_3gppParserRULE_constraintSpec)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(948)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 105, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(946)
			p.GeneralConstraint()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(947)
			p.SubtypeConstraint()
		}

	}

	return localctx
}

// IUserDefinedConstraintContext is an interface to support dynamic dispatch.
type IUserDefinedConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUserDefinedConstraintContext differentiates from other interfaces.
	IsUserDefinedConstraintContext()
}

type UserDefinedConstraintContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUserDefinedConstraintContext() *UserDefinedConstraintContext {
	var p = new(UserDefinedConstraintContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_userDefinedConstraint
	return p
}

func (*UserDefinedConstraintContext) IsUserDefinedConstraintContext() {}

func NewUserDefinedConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UserDefinedConstraintContext {
	var p = new(UserDefinedConstraintContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_userDefinedConstraint

	return p
}

func (s *UserDefinedConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *UserDefinedConstraintContext) CONSTRAINED_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserCONSTRAINED_LITERAL, 0)
}

func (s *UserDefinedConstraintContext) BY_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserBY_LITERAL, 0)
}

func (s *UserDefinedConstraintContext) L_BRACE() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserL_BRACE, 0)
}

func (s *UserDefinedConstraintContext) AllUserDefinedConstraintParameter() []IUserDefinedConstraintParameterContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IUserDefinedConstraintParameterContext)(nil)).Elem())
	var tst = make([]IUserDefinedConstraintParameterContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IUserDefinedConstraintParameterContext)
		}
	}

	return tst
}

func (s *UserDefinedConstraintContext) UserDefinedConstraintParameter(i int) IUserDefinedConstraintParameterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUserDefinedConstraintParameterContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IUserDefinedConstraintParameterContext)
}

func (s *UserDefinedConstraintContext) R_BRACE() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserR_BRACE, 0)
}

func (s *UserDefinedConstraintContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ASN_3gppParserCOMMA)
}

func (s *UserDefinedConstraintContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserCOMMA, i)
}

func (s *UserDefinedConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UserDefinedConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UserDefinedConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterUserDefinedConstraint(s)
	}
}

func (s *UserDefinedConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitUserDefinedConstraint(s)
	}
}

func (p *ASN_3gppParser) UserDefinedConstraint() (localctx IUserDefinedConstraintContext) {
	localctx = NewUserDefinedConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, ASN_3gppParserRULE_userDefinedConstraint)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(950)
		p.Match(ASN_3gppParserCONSTRAINED_LITERAL)
	}
	{
		p.SetState(951)
		p.Match(ASN_3gppParserBY_LITERAL)
	}
	{
		p.SetState(952)
		p.Match(ASN_3gppParserL_BRACE)
	}
	{
		p.SetState(953)
		p.UserDefinedConstraintParameter()
	}
	p.SetState(958)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ASN_3gppParserCOMMA {
		{
			p.SetState(954)
			p.Match(ASN_3gppParserCOMMA)
		}
		{
			p.SetState(955)
			p.UserDefinedConstraintParameter()
		}

		p.SetState(960)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(961)
		p.Match(ASN_3gppParserR_BRACE)
	}

	return localctx
}

// IGeneralConstraintContext is an interface to support dynamic dispatch.
type IGeneralConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGeneralConstraintContext differentiates from other interfaces.
	IsGeneralConstraintContext()
}

type GeneralConstraintContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGeneralConstraintContext() *GeneralConstraintContext {
	var p = new(GeneralConstraintContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_generalConstraint
	return p
}

func (*GeneralConstraintContext) IsGeneralConstraintContext() {}

func NewGeneralConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GeneralConstraintContext {
	var p = new(GeneralConstraintContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_generalConstraint

	return p
}

func (s *GeneralConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *GeneralConstraintContext) UserDefinedConstraint() IUserDefinedConstraintContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUserDefinedConstraintContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUserDefinedConstraintContext)
}

func (s *GeneralConstraintContext) TableConstraint() ITableConstraintContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableConstraintContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableConstraintContext)
}

func (s *GeneralConstraintContext) ContentsConstraint() IContentsConstraintContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IContentsConstraintContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IContentsConstraintContext)
}

func (s *GeneralConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GeneralConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GeneralConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterGeneralConstraint(s)
	}
}

func (s *GeneralConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitGeneralConstraint(s)
	}
}

func (p *ASN_3gppParser) GeneralConstraint() (localctx IGeneralConstraintContext) {
	localctx = NewGeneralConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, ASN_3gppParserRULE_generalConstraint)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(966)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ASN_3gppParserCONSTRAINED_LITERAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(963)
			p.UserDefinedConstraint()
		}

	case ASN_3gppParserL_BRACE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(964)
			p.TableConstraint()
		}

	case ASN_3gppParserCONTAINING_LITERAL, ASN_3gppParserWITH_LITERAL, ASN_3gppParserENCODED_LITERAL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(965)
			p.ContentsConstraint()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IUserDefinedConstraintParameterContext is an interface to support dynamic dispatch.
type IUserDefinedConstraintParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUserDefinedConstraintParameterContext differentiates from other interfaces.
	IsUserDefinedConstraintParameterContext()
}

type UserDefinedConstraintParameterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUserDefinedConstraintParameterContext() *UserDefinedConstraintParameterContext {
	var p = new(UserDefinedConstraintParameterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_userDefinedConstraintParameter
	return p
}

func (*UserDefinedConstraintParameterContext) IsUserDefinedConstraintParameterContext() {}

func NewUserDefinedConstraintParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UserDefinedConstraintParameterContext {
	var p = new(UserDefinedConstraintParameterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_userDefinedConstraintParameter

	return p
}

func (s *UserDefinedConstraintParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *UserDefinedConstraintParameterContext) Governor() IGovernorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGovernorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGovernorContext)
}

func (s *UserDefinedConstraintParameterContext) COLON() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserCOLON, 0)
}

func (s *UserDefinedConstraintParameterContext) Value() IValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueContext)
}

func (s *UserDefinedConstraintParameterContext) ValueSet() IValueSetContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueSetContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueSetContext)
}

func (s *UserDefinedConstraintParameterContext) Object() IObjectContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObjectContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObjectContext)
}

func (s *UserDefinedConstraintParameterContext) ObjectSet() IObjectSetContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObjectSetContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObjectSetContext)
}

func (s *UserDefinedConstraintParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UserDefinedConstraintParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UserDefinedConstraintParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterUserDefinedConstraintParameter(s)
	}
}

func (s *UserDefinedConstraintParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitUserDefinedConstraintParameter(s)
	}
}

func (p *ASN_3gppParser) UserDefinedConstraintParameter() (localctx IUserDefinedConstraintParameterContext) {
	localctx = NewUserDefinedConstraintParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, ASN_3gppParserRULE_userDefinedConstraintParameter)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(968)
		p.Governor()
	}
	p.SetState(974)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 108, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(969)
			p.Match(ASN_3gppParserCOLON)
		}
		{
			p.SetState(970)
			p.Value()
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 108, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(971)
			p.ValueSet()
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 108, p.GetParserRuleContext()) == 3 {
		{
			p.SetState(972)
			p.Object()
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 108, p.GetParserRuleContext()) == 4 {
		{
			p.SetState(973)
			p.ObjectSet()
		}

	}

	return localctx
}

// ITableConstraintContext is an interface to support dynamic dispatch.
type ITableConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTableConstraintContext differentiates from other interfaces.
	IsTableConstraintContext()
}

type TableConstraintContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableConstraintContext() *TableConstraintContext {
	var p = new(TableConstraintContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_tableConstraint
	return p
}

func (*TableConstraintContext) IsTableConstraintContext() {}

func NewTableConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableConstraintContext {
	var p = new(TableConstraintContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_tableConstraint

	return p
}

func (s *TableConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *TableConstraintContext) ComponentRelationConstraint() IComponentRelationConstraintContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComponentRelationConstraintContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComponentRelationConstraintContext)
}

func (s *TableConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterTableConstraint(s)
	}
}

func (s *TableConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitTableConstraint(s)
	}
}

func (p *ASN_3gppParser) TableConstraint() (localctx ITableConstraintContext) {
	localctx = NewTableConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 198, ASN_3gppParserRULE_tableConstraint)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(976)
		p.ComponentRelationConstraint()
	}

	return localctx
}

// ISimpleTableConstraintContext is an interface to support dynamic dispatch.
type ISimpleTableConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSimpleTableConstraintContext differentiates from other interfaces.
	IsSimpleTableConstraintContext()
}

type SimpleTableConstraintContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleTableConstraintContext() *SimpleTableConstraintContext {
	var p = new(SimpleTableConstraintContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_simpleTableConstraint
	return p
}

func (*SimpleTableConstraintContext) IsSimpleTableConstraintContext() {}

func NewSimpleTableConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleTableConstraintContext {
	var p = new(SimpleTableConstraintContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_simpleTableConstraint

	return p
}

func (s *SimpleTableConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleTableConstraintContext) ObjectSet() IObjectSetContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObjectSetContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObjectSetContext)
}

func (s *SimpleTableConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleTableConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleTableConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterSimpleTableConstraint(s)
	}
}

func (s *SimpleTableConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitSimpleTableConstraint(s)
	}
}

func (p *ASN_3gppParser) SimpleTableConstraint() (localctx ISimpleTableConstraintContext) {
	localctx = NewSimpleTableConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 200, ASN_3gppParserRULE_simpleTableConstraint)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(978)
		p.ObjectSet()
	}

	return localctx
}

// IContentsConstraintContext is an interface to support dynamic dispatch.
type IContentsConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsContentsConstraintContext differentiates from other interfaces.
	IsContentsConstraintContext()
}

type ContentsConstraintContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyContentsConstraintContext() *ContentsConstraintContext {
	var p = new(ContentsConstraintContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_contentsConstraint
	return p
}

func (*ContentsConstraintContext) IsContentsConstraintContext() {}

func NewContentsConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ContentsConstraintContext {
	var p = new(ContentsConstraintContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_contentsConstraint

	return p
}

func (s *ContentsConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *ContentsConstraintContext) CONTAINING_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserCONTAINING_LITERAL, 0)
}

func (s *ContentsConstraintContext) AsnType() IAsnTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAsnTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAsnTypeContext)
}

func (s *ContentsConstraintContext) ENCODED_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserENCODED_LITERAL, 0)
}

func (s *ContentsConstraintContext) BY_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserBY_LITERAL, 0)
}

func (s *ContentsConstraintContext) Value() IValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueContext)
}

func (s *ContentsConstraintContext) WITH_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserWITH_LITERAL, 0)
}

func (s *ContentsConstraintContext) COMPONENTS_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserCOMPONENTS_LITERAL, 0)
}

func (s *ContentsConstraintContext) L_BRACE() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserL_BRACE, 0)
}

func (s *ContentsConstraintContext) ComponentPresenceLists() IComponentPresenceListsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComponentPresenceListsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComponentPresenceListsContext)
}

func (s *ContentsConstraintContext) R_BRACE() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserR_BRACE, 0)
}

func (s *ContentsConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ContentsConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ContentsConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterContentsConstraint(s)
	}
}

func (s *ContentsConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitContentsConstraint(s)
	}
}

func (p *ASN_3gppParser) ContentsConstraint() (localctx IContentsConstraintContext) {
	localctx = NewContentsConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 202, ASN_3gppParserRULE_contentsConstraint)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(997)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 109, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(980)
			p.Match(ASN_3gppParserCONTAINING_LITERAL)
		}
		{
			p.SetState(981)
			p.AsnType()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(982)
			p.Match(ASN_3gppParserENCODED_LITERAL)
		}
		{
			p.SetState(983)
			p.Match(ASN_3gppParserBY_LITERAL)
		}
		{
			p.SetState(984)
			p.Value()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(985)
			p.Match(ASN_3gppParserCONTAINING_LITERAL)
		}
		{
			p.SetState(986)
			p.AsnType()
		}
		{
			p.SetState(987)
			p.Match(ASN_3gppParserENCODED_LITERAL)
		}
		{
			p.SetState(988)
			p.Match(ASN_3gppParserBY_LITERAL)
		}
		{
			p.SetState(989)
			p.Value()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(991)
			p.Match(ASN_3gppParserWITH_LITERAL)
		}
		{
			p.SetState(992)
			p.Match(ASN_3gppParserCOMPONENTS_LITERAL)
		}
		{
			p.SetState(993)
			p.Match(ASN_3gppParserL_BRACE)
		}
		{
			p.SetState(994)
			p.ComponentPresenceLists()
		}
		{
			p.SetState(995)
			p.Match(ASN_3gppParserR_BRACE)
		}

	}

	return localctx
}

// IComponentPresenceListsContext is an interface to support dynamic dispatch.
type IComponentPresenceListsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComponentPresenceListsContext differentiates from other interfaces.
	IsComponentPresenceListsContext()
}

type ComponentPresenceListsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComponentPresenceListsContext() *ComponentPresenceListsContext {
	var p = new(ComponentPresenceListsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_componentPresenceLists
	return p
}

func (*ComponentPresenceListsContext) IsComponentPresenceListsContext() {}

func NewComponentPresenceListsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComponentPresenceListsContext {
	var p = new(ComponentPresenceListsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_componentPresenceLists

	return p
}

func (s *ComponentPresenceListsContext) GetParser() antlr.Parser { return s.parser }

func (s *ComponentPresenceListsContext) AllComponentPresenceList() []IComponentPresenceListContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IComponentPresenceListContext)(nil)).Elem())
	var tst = make([]IComponentPresenceListContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IComponentPresenceListContext)
		}
	}

	return tst
}

func (s *ComponentPresenceListsContext) ComponentPresenceList(i int) IComponentPresenceListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComponentPresenceListContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IComponentPresenceListContext)
}

func (s *ComponentPresenceListsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ASN_3gppParserCOMMA)
}

func (s *ComponentPresenceListsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserCOMMA, i)
}

func (s *ComponentPresenceListsContext) ELLIPSIS() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserELLIPSIS, 0)
}

func (s *ComponentPresenceListsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComponentPresenceListsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComponentPresenceListsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterComponentPresenceLists(s)
	}
}

func (s *ComponentPresenceListsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitComponentPresenceLists(s)
	}
}

func (p *ASN_3gppParser) ComponentPresenceLists() (localctx IComponentPresenceListsContext) {
	localctx = NewComponentPresenceListsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 204, ASN_3gppParserRULE_componentPresenceLists)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1015)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ASN_3gppParserR_BRACE, ASN_3gppParserCOMMA, ASN_3gppParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1000)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ASN_3gppParserIDENTIFIER {
			{
				p.SetState(999)
				p.ComponentPresenceList()
			}

		}
		p.SetState(1008)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ASN_3gppParserCOMMA {
			{
				p.SetState(1002)
				p.Match(ASN_3gppParserCOMMA)
			}
			{
				p.SetState(1003)
				p.Match(ASN_3gppParserELLIPSIS)
			}
			p.SetState(1006)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == ASN_3gppParserCOMMA {
				{
					p.SetState(1004)
					p.Match(ASN_3gppParserCOMMA)
				}
				{
					p.SetState(1005)
					p.ComponentPresenceList()
				}

			}

		}

	case ASN_3gppParserELLIPSIS:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1010)
			p.Match(ASN_3gppParserELLIPSIS)
		}
		p.SetState(1013)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ASN_3gppParserCOMMA {
			{
				p.SetState(1011)
				p.Match(ASN_3gppParserCOMMA)
			}
			{
				p.SetState(1012)
				p.ComponentPresenceList()
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IComponentPresenceListContext is an interface to support dynamic dispatch.
type IComponentPresenceListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComponentPresenceListContext differentiates from other interfaces.
	IsComponentPresenceListContext()
}

type ComponentPresenceListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComponentPresenceListContext() *ComponentPresenceListContext {
	var p = new(ComponentPresenceListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_componentPresenceList
	return p
}

func (*ComponentPresenceListContext) IsComponentPresenceListContext() {}

func NewComponentPresenceListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComponentPresenceListContext {
	var p = new(ComponentPresenceListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_componentPresenceList

	return p
}

func (s *ComponentPresenceListContext) GetParser() antlr.Parser { return s.parser }

func (s *ComponentPresenceListContext) AllComponentPresence() []IComponentPresenceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IComponentPresenceContext)(nil)).Elem())
	var tst = make([]IComponentPresenceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IComponentPresenceContext)
		}
	}

	return tst
}

func (s *ComponentPresenceListContext) ComponentPresence(i int) IComponentPresenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComponentPresenceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IComponentPresenceContext)
}

func (s *ComponentPresenceListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ASN_3gppParserCOMMA)
}

func (s *ComponentPresenceListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserCOMMA, i)
}

func (s *ComponentPresenceListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComponentPresenceListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComponentPresenceListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterComponentPresenceList(s)
	}
}

func (s *ComponentPresenceListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitComponentPresenceList(s)
	}
}

func (p *ASN_3gppParser) ComponentPresenceList() (localctx IComponentPresenceListContext) {
	localctx = NewComponentPresenceListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 206, ASN_3gppParserRULE_componentPresenceList)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1017)
		p.ComponentPresence()
	}

	p.SetState(1022)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 115, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1018)
				p.Match(ASN_3gppParserCOMMA)
			}
			{
				p.SetState(1019)
				p.ComponentPresence()
			}

		}
		p.SetState(1024)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 115, p.GetParserRuleContext())
	}

	return localctx
}

// IComponentPresenceContext is an interface to support dynamic dispatch.
type IComponentPresenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComponentPresenceContext differentiates from other interfaces.
	IsComponentPresenceContext()
}

type ComponentPresenceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComponentPresenceContext() *ComponentPresenceContext {
	var p = new(ComponentPresenceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_componentPresence
	return p
}

func (*ComponentPresenceContext) IsComponentPresenceContext() {}

func NewComponentPresenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComponentPresenceContext {
	var p = new(ComponentPresenceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_componentPresence

	return p
}

func (s *ComponentPresenceContext) GetParser() antlr.Parser { return s.parser }

func (s *ComponentPresenceContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserIDENTIFIER, 0)
}

func (s *ComponentPresenceContext) ABSENT_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserABSENT_LITERAL, 0)
}

func (s *ComponentPresenceContext) PRESENT_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserPRESENT_LITERAL, 0)
}

func (s *ComponentPresenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComponentPresenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComponentPresenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterComponentPresence(s)
	}
}

func (s *ComponentPresenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitComponentPresence(s)
	}
}

func (p *ASN_3gppParser) ComponentPresence() (localctx IComponentPresenceContext) {
	localctx = NewComponentPresenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 208, ASN_3gppParserRULE_componentPresence)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1025)
		p.Match(ASN_3gppParserIDENTIFIER)
	}
	{
		p.SetState(1026)
		_la = p.GetTokenStream().LA(1)

		if !(_la == ASN_3gppParserPRESENT_LITERAL || _la == ASN_3gppParserABSENT_LITERAL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// ISubtypeConstraintContext is an interface to support dynamic dispatch.
type ISubtypeConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSubtypeConstraintContext differentiates from other interfaces.
	IsSubtypeConstraintContext()
}

type SubtypeConstraintContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubtypeConstraintContext() *SubtypeConstraintContext {
	var p = new(SubtypeConstraintContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_subtypeConstraint
	return p
}

func (*SubtypeConstraintContext) IsSubtypeConstraintContext() {}

func NewSubtypeConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubtypeConstraintContext {
	var p = new(SubtypeConstraintContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_subtypeConstraint

	return p
}

func (s *SubtypeConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *SubtypeConstraintContext) ElementSetSpecs() IElementSetSpecsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IElementSetSpecsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IElementSetSpecsContext)
}

func (s *SubtypeConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubtypeConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubtypeConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterSubtypeConstraint(s)
	}
}

func (s *SubtypeConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitSubtypeConstraint(s)
	}
}

func (p *ASN_3gppParser) SubtypeConstraint() (localctx ISubtypeConstraintContext) {
	localctx = NewSubtypeConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 210, ASN_3gppParserRULE_subtypeConstraint)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1028)
		p.ElementSetSpecs()
	}

	return localctx
}

// IValueContext is an interface to support dynamic dispatch.
type IValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsValueContext differentiates from other interfaces.
	IsValueContext()
}

type ValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValueContext() *ValueContext {
	var p = new(ValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_value
	return p
}

func (*ValueContext) IsValueContext() {}

func NewValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValueContext {
	var p = new(ValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_value

	return p
}

func (s *ValueContext) GetParser() antlr.Parser { return s.parser }

func (s *ValueContext) BuiltinValue() IBuiltinValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBuiltinValueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBuiltinValueContext)
}

func (s *ValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterValue(s)
	}
}

func (s *ValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitValue(s)
	}
}

func (p *ASN_3gppParser) Value() (localctx IValueContext) {
	localctx = NewValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 212, ASN_3gppParserRULE_value)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1030)
		p.BuiltinValue()
	}

	return localctx
}

// IBuiltinValueContext is an interface to support dynamic dispatch.
type IBuiltinValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBuiltinValueContext differentiates from other interfaces.
	IsBuiltinValueContext()
}

type BuiltinValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBuiltinValueContext() *BuiltinValueContext {
	var p = new(BuiltinValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_builtinValue
	return p
}

func (*BuiltinValueContext) IsBuiltinValueContext() {}

func NewBuiltinValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BuiltinValueContext {
	var p = new(BuiltinValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_builtinValue

	return p
}

func (s *BuiltinValueContext) GetParser() antlr.Parser { return s.parser }

func (s *BuiltinValueContext) EnumeratedValue() IEnumeratedValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnumeratedValueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnumeratedValueContext)
}

func (s *BuiltinValueContext) IntegerValue() IIntegerValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerValueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerValueContext)
}

func (s *BuiltinValueContext) ChoiceValue() IChoiceValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IChoiceValueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IChoiceValueContext)
}

func (s *BuiltinValueContext) ObjectIdentifierValue() IObjectIdentifierValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObjectIdentifierValueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObjectIdentifierValueContext)
}

func (s *BuiltinValueContext) BooleanValue() IBooleanValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBooleanValueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBooleanValueContext)
}

func (s *BuiltinValueContext) CSTRING() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserCSTRING, 0)
}

func (s *BuiltinValueContext) BSTRING() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserBSTRING, 0)
}

func (s *BuiltinValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BuiltinValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BuiltinValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterBuiltinValue(s)
	}
}

func (s *BuiltinValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitBuiltinValue(s)
	}
}

func (p *ASN_3gppParser) BuiltinValue() (localctx IBuiltinValueContext) {
	localctx = NewBuiltinValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 214, ASN_3gppParserRULE_builtinValue)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1039)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 116, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1032)
			p.EnumeratedValue()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1033)
			p.IntegerValue()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1034)
			p.ChoiceValue()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1035)
			p.ObjectIdentifierValue()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1036)
			p.BooleanValue()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1037)
			p.Match(ASN_3gppParserCSTRING)
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1038)
			p.Match(ASN_3gppParserBSTRING)
		}

	}

	return localctx
}

// IObjectIdentifierValueContext is an interface to support dynamic dispatch.
type IObjectIdentifierValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObjectIdentifierValueContext differentiates from other interfaces.
	IsObjectIdentifierValueContext()
}

type ObjectIdentifierValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObjectIdentifierValueContext() *ObjectIdentifierValueContext {
	var p = new(ObjectIdentifierValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_objectIdentifierValue
	return p
}

func (*ObjectIdentifierValueContext) IsObjectIdentifierValueContext() {}

func NewObjectIdentifierValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjectIdentifierValueContext {
	var p = new(ObjectIdentifierValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_objectIdentifierValue

	return p
}

func (s *ObjectIdentifierValueContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjectIdentifierValueContext) L_BRACE() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserL_BRACE, 0)
}

func (s *ObjectIdentifierValueContext) ObjIdComponentsList() IObjIdComponentsListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObjIdComponentsListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObjIdComponentsListContext)
}

func (s *ObjectIdentifierValueContext) R_BRACE() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserR_BRACE, 0)
}

func (s *ObjectIdentifierValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectIdentifierValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObjectIdentifierValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterObjectIdentifierValue(s)
	}
}

func (s *ObjectIdentifierValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitObjectIdentifierValue(s)
	}
}

func (p *ASN_3gppParser) ObjectIdentifierValue() (localctx IObjectIdentifierValueContext) {
	localctx = NewObjectIdentifierValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 216, ASN_3gppParserRULE_objectIdentifierValue)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1041)
		p.Match(ASN_3gppParserL_BRACE)
	}
	{
		p.SetState(1042)
		p.ObjIdComponentsList()
	}
	{
		p.SetState(1043)
		p.Match(ASN_3gppParserR_BRACE)
	}

	return localctx
}

// IObjIdComponentsListContext is an interface to support dynamic dispatch.
type IObjIdComponentsListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObjIdComponentsListContext differentiates from other interfaces.
	IsObjIdComponentsListContext()
}

type ObjIdComponentsListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObjIdComponentsListContext() *ObjIdComponentsListContext {
	var p = new(ObjIdComponentsListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_objIdComponentsList
	return p
}

func (*ObjIdComponentsListContext) IsObjIdComponentsListContext() {}

func NewObjIdComponentsListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjIdComponentsListContext {
	var p = new(ObjIdComponentsListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_objIdComponentsList

	return p
}

func (s *ObjIdComponentsListContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjIdComponentsListContext) AllObjIdComponents() []IObjIdComponentsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IObjIdComponentsContext)(nil)).Elem())
	var tst = make([]IObjIdComponentsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IObjIdComponentsContext)
		}
	}

	return tst
}

func (s *ObjIdComponentsListContext) ObjIdComponents(i int) IObjIdComponentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObjIdComponentsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IObjIdComponentsContext)
}

func (s *ObjIdComponentsListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjIdComponentsListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObjIdComponentsListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterObjIdComponentsList(s)
	}
}

func (s *ObjIdComponentsListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitObjIdComponentsList(s)
	}
}

func (p *ASN_3gppParser) ObjIdComponentsList() (localctx IObjIdComponentsListContext) {
	localctx = NewObjIdComponentsListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 218, ASN_3gppParserRULE_objIdComponentsList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1045)
		p.ObjIdComponents()
	}

	p.SetState(1049)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ASN_3gppParserNUMBER || _la == ASN_3gppParserIDENTIFIER {
		{
			p.SetState(1046)
			p.ObjIdComponents()
		}

		p.SetState(1051)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IObjIdComponentsContext is an interface to support dynamic dispatch.
type IObjIdComponentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObjIdComponentsContext differentiates from other interfaces.
	IsObjIdComponentsContext()
}

type ObjIdComponentsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObjIdComponentsContext() *ObjIdComponentsContext {
	var p = new(ObjIdComponentsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_objIdComponents
	return p
}

func (*ObjIdComponentsContext) IsObjIdComponentsContext() {}

func NewObjIdComponentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjIdComponentsContext {
	var p = new(ObjIdComponentsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_objIdComponents

	return p
}

func (s *ObjIdComponentsContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjIdComponentsContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserNUMBER, 0)
}

func (s *ObjIdComponentsContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserIDENTIFIER, 0)
}

func (s *ObjIdComponentsContext) L_PARAN() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserL_PARAN, 0)
}

func (s *ObjIdComponentsContext) R_PARAN() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserR_PARAN, 0)
}

func (s *ObjIdComponentsContext) DefinedValue() IDefinedValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDefinedValueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDefinedValueContext)
}

func (s *ObjIdComponentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjIdComponentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObjIdComponentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterObjIdComponents(s)
	}
}

func (s *ObjIdComponentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitObjIdComponents(s)
	}
}

func (p *ASN_3gppParser) ObjIdComponents() (localctx IObjIdComponentsContext) {
	localctx = NewObjIdComponentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 220, ASN_3gppParserRULE_objIdComponents)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1063)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 120, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1052)
			p.Match(ASN_3gppParserNUMBER)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1053)
			p.Match(ASN_3gppParserIDENTIFIER)
		}
		p.SetState(1060)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ASN_3gppParserL_PARAN {
			{
				p.SetState(1054)
				p.Match(ASN_3gppParserL_PARAN)
			}
			p.SetState(1057)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case ASN_3gppParserNUMBER:
				{
					p.SetState(1055)
					p.Match(ASN_3gppParserNUMBER)
				}

			case ASN_3gppParserIDENTIFIER:
				{
					p.SetState(1056)
					p.DefinedValue()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}
			{
				p.SetState(1059)
				p.Match(ASN_3gppParserR_PARAN)
			}

		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1062)
			p.DefinedValue()
		}

	}

	return localctx
}

// IIntegerValueContext is an interface to support dynamic dispatch.
type IIntegerValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIntegerValueContext differentiates from other interfaces.
	IsIntegerValueContext()
}

type IntegerValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIntegerValueContext() *IntegerValueContext {
	var p = new(IntegerValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_integerValue
	return p
}

func (*IntegerValueContext) IsIntegerValueContext() {}

func NewIntegerValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntegerValueContext {
	var p = new(IntegerValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_integerValue

	return p
}

func (s *IntegerValueContext) GetParser() antlr.Parser { return s.parser }

func (s *IntegerValueContext) SignedNumber() ISignedNumberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISignedNumberContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISignedNumberContext)
}

func (s *IntegerValueContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserIDENTIFIER, 0)
}

func (s *IntegerValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntegerValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IntegerValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterIntegerValue(s)
	}
}

func (s *IntegerValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitIntegerValue(s)
	}
}

func (p *ASN_3gppParser) IntegerValue() (localctx IIntegerValueContext) {
	localctx = NewIntegerValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 222, ASN_3gppParserRULE_integerValue)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1067)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ASN_3gppParserMINUS, ASN_3gppParserNUMBER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1065)
			p.SignedNumber()
		}

	case ASN_3gppParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1066)
			p.Match(ASN_3gppParserIDENTIFIER)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IChoiceValueContext is an interface to support dynamic dispatch.
type IChoiceValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsChoiceValueContext differentiates from other interfaces.
	IsChoiceValueContext()
}

type ChoiceValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyChoiceValueContext() *ChoiceValueContext {
	var p = new(ChoiceValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_choiceValue
	return p
}

func (*ChoiceValueContext) IsChoiceValueContext() {}

func NewChoiceValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ChoiceValueContext {
	var p = new(ChoiceValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_choiceValue

	return p
}

func (s *ChoiceValueContext) GetParser() antlr.Parser { return s.parser }

func (s *ChoiceValueContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserIDENTIFIER, 0)
}

func (s *ChoiceValueContext) COLON() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserCOLON, 0)
}

func (s *ChoiceValueContext) Value() IValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueContext)
}

func (s *ChoiceValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ChoiceValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ChoiceValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterChoiceValue(s)
	}
}

func (s *ChoiceValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitChoiceValue(s)
	}
}

func (p *ASN_3gppParser) ChoiceValue() (localctx IChoiceValueContext) {
	localctx = NewChoiceValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 224, ASN_3gppParserRULE_choiceValue)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1069)
		p.Match(ASN_3gppParserIDENTIFIER)
	}
	{
		p.SetState(1070)
		p.Match(ASN_3gppParserCOLON)
	}
	{
		p.SetState(1071)
		p.Value()
	}

	return localctx
}

// IEnumeratedValueContext is an interface to support dynamic dispatch.
type IEnumeratedValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnumeratedValueContext differentiates from other interfaces.
	IsEnumeratedValueContext()
}

type EnumeratedValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumeratedValueContext() *EnumeratedValueContext {
	var p = new(EnumeratedValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_enumeratedValue
	return p
}

func (*EnumeratedValueContext) IsEnumeratedValueContext() {}

func NewEnumeratedValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumeratedValueContext {
	var p = new(EnumeratedValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_enumeratedValue

	return p
}

func (s *EnumeratedValueContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumeratedValueContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserIDENTIFIER, 0)
}

func (s *EnumeratedValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumeratedValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumeratedValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterEnumeratedValue(s)
	}
}

func (s *EnumeratedValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitEnumeratedValue(s)
	}
}

func (p *ASN_3gppParser) EnumeratedValue() (localctx IEnumeratedValueContext) {
	localctx = NewEnumeratedValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 226, ASN_3gppParserRULE_enumeratedValue)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1073)
		p.Match(ASN_3gppParserIDENTIFIER)
	}

	return localctx
}

// ISignedNumberContext is an interface to support dynamic dispatch.
type ISignedNumberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSignedNumberContext differentiates from other interfaces.
	IsSignedNumberContext()
}

type SignedNumberContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySignedNumberContext() *SignedNumberContext {
	var p = new(SignedNumberContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_signedNumber
	return p
}

func (*SignedNumberContext) IsSignedNumberContext() {}

func NewSignedNumberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SignedNumberContext {
	var p = new(SignedNumberContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_signedNumber

	return p
}

func (s *SignedNumberContext) GetParser() antlr.Parser { return s.parser }

func (s *SignedNumberContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserNUMBER, 0)
}

func (s *SignedNumberContext) MINUS() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserMINUS, 0)
}

func (s *SignedNumberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SignedNumberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SignedNumberContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterSignedNumber(s)
	}
}

func (s *SignedNumberContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitSignedNumber(s)
	}
}

func (p *ASN_3gppParser) SignedNumber() (localctx ISignedNumberContext) {
	localctx = NewSignedNumberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 228, ASN_3gppParserRULE_signedNumber)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1076)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ASN_3gppParserMINUS {
		{
			p.SetState(1075)
			p.Match(ASN_3gppParserMINUS)
		}

	}
	{
		p.SetState(1078)
		p.Match(ASN_3gppParserNUMBER)
	}

	return localctx
}

// IChoiceTypeContext is an interface to support dynamic dispatch.
type IChoiceTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsChoiceTypeContext differentiates from other interfaces.
	IsChoiceTypeContext()
}

type ChoiceTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyChoiceTypeContext() *ChoiceTypeContext {
	var p = new(ChoiceTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_choiceType
	return p
}

func (*ChoiceTypeContext) IsChoiceTypeContext() {}

func NewChoiceTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ChoiceTypeContext {
	var p = new(ChoiceTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_choiceType

	return p
}

func (s *ChoiceTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ChoiceTypeContext) CHOICE_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserCHOICE_LITERAL, 0)
}

func (s *ChoiceTypeContext) L_BRACE() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserL_BRACE, 0)
}

func (s *ChoiceTypeContext) AlternativeTypeLists() IAlternativeTypeListsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlternativeTypeListsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlternativeTypeListsContext)
}

func (s *ChoiceTypeContext) R_BRACE() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserR_BRACE, 0)
}

func (s *ChoiceTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ChoiceTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ChoiceTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterChoiceType(s)
	}
}

func (s *ChoiceTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitChoiceType(s)
	}
}

func (p *ASN_3gppParser) ChoiceType() (localctx IChoiceTypeContext) {
	localctx = NewChoiceTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 230, ASN_3gppParserRULE_choiceType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1080)
		p.Match(ASN_3gppParserCHOICE_LITERAL)
	}
	{
		p.SetState(1081)
		p.Match(ASN_3gppParserL_BRACE)
	}
	{
		p.SetState(1082)
		p.AlternativeTypeLists()
	}
	{
		p.SetState(1083)
		p.Match(ASN_3gppParserR_BRACE)
	}

	return localctx
}

// IAlternativeTypeListsContext is an interface to support dynamic dispatch.
type IAlternativeTypeListsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAlternativeTypeListsContext differentiates from other interfaces.
	IsAlternativeTypeListsContext()
}

type AlternativeTypeListsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlternativeTypeListsContext() *AlternativeTypeListsContext {
	var p = new(AlternativeTypeListsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_alternativeTypeLists
	return p
}

func (*AlternativeTypeListsContext) IsAlternativeTypeListsContext() {}

func NewAlternativeTypeListsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlternativeTypeListsContext {
	var p = new(AlternativeTypeListsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_alternativeTypeLists

	return p
}

func (s *AlternativeTypeListsContext) GetParser() antlr.Parser { return s.parser }

func (s *AlternativeTypeListsContext) RootAlternativeTypeList() IRootAlternativeTypeListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRootAlternativeTypeListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRootAlternativeTypeListContext)
}

func (s *AlternativeTypeListsContext) COMMA() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserCOMMA, 0)
}

func (s *AlternativeTypeListsContext) ExtensionAndException() IExtensionAndExceptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExtensionAndExceptionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExtensionAndExceptionContext)
}

func (s *AlternativeTypeListsContext) ExtensionAdditionAlternatives() IExtensionAdditionAlternativesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExtensionAdditionAlternativesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExtensionAdditionAlternativesContext)
}

func (s *AlternativeTypeListsContext) OptionalExtensionMarker() IOptionalExtensionMarkerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOptionalExtensionMarkerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOptionalExtensionMarkerContext)
}

func (s *AlternativeTypeListsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlternativeTypeListsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlternativeTypeListsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterAlternativeTypeLists(s)
	}
}

func (s *AlternativeTypeListsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitAlternativeTypeLists(s)
	}
}

func (p *ASN_3gppParser) AlternativeTypeLists() (localctx IAlternativeTypeListsContext) {
	localctx = NewAlternativeTypeListsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 232, ASN_3gppParserRULE_alternativeTypeLists)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1085)
		p.RootAlternativeTypeList()
	}
	p.SetState(1091)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ASN_3gppParserCOMMA {
		{
			p.SetState(1086)
			p.Match(ASN_3gppParserCOMMA)
		}
		{
			p.SetState(1087)
			p.ExtensionAndException()
		}
		{
			p.SetState(1088)
			p.ExtensionAdditionAlternatives()
		}
		{
			p.SetState(1089)
			p.OptionalExtensionMarker()
		}

	}

	return localctx
}

// IExtensionAdditionAlternativesContext is an interface to support dynamic dispatch.
type IExtensionAdditionAlternativesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExtensionAdditionAlternativesContext differentiates from other interfaces.
	IsExtensionAdditionAlternativesContext()
}

type ExtensionAdditionAlternativesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExtensionAdditionAlternativesContext() *ExtensionAdditionAlternativesContext {
	var p = new(ExtensionAdditionAlternativesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_extensionAdditionAlternatives
	return p
}

func (*ExtensionAdditionAlternativesContext) IsExtensionAdditionAlternativesContext() {}

func NewExtensionAdditionAlternativesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExtensionAdditionAlternativesContext {
	var p = new(ExtensionAdditionAlternativesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_extensionAdditionAlternatives

	return p
}

func (s *ExtensionAdditionAlternativesContext) GetParser() antlr.Parser { return s.parser }

func (s *ExtensionAdditionAlternativesContext) COMMA() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserCOMMA, 0)
}

func (s *ExtensionAdditionAlternativesContext) ExtensionAdditionAlternativesList() IExtensionAdditionAlternativesListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExtensionAdditionAlternativesListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExtensionAdditionAlternativesListContext)
}

func (s *ExtensionAdditionAlternativesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExtensionAdditionAlternativesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExtensionAdditionAlternativesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterExtensionAdditionAlternatives(s)
	}
}

func (s *ExtensionAdditionAlternativesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitExtensionAdditionAlternatives(s)
	}
}

func (p *ASN_3gppParser) ExtensionAdditionAlternatives() (localctx IExtensionAdditionAlternativesContext) {
	localctx = NewExtensionAdditionAlternativesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 234, ASN_3gppParserRULE_extensionAdditionAlternatives)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1095)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 124, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1093)
			p.Match(ASN_3gppParserCOMMA)
		}
		{
			p.SetState(1094)
			p.ExtensionAdditionAlternativesList()
		}

	}

	return localctx
}

// IExtensionAdditionAlternativesListContext is an interface to support dynamic dispatch.
type IExtensionAdditionAlternativesListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExtensionAdditionAlternativesListContext differentiates from other interfaces.
	IsExtensionAdditionAlternativesListContext()
}

type ExtensionAdditionAlternativesListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExtensionAdditionAlternativesListContext() *ExtensionAdditionAlternativesListContext {
	var p = new(ExtensionAdditionAlternativesListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_extensionAdditionAlternativesList
	return p
}

func (*ExtensionAdditionAlternativesListContext) IsExtensionAdditionAlternativesListContext() {}

func NewExtensionAdditionAlternativesListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExtensionAdditionAlternativesListContext {
	var p = new(ExtensionAdditionAlternativesListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_extensionAdditionAlternativesList

	return p
}

func (s *ExtensionAdditionAlternativesListContext) GetParser() antlr.Parser { return s.parser }

func (s *ExtensionAdditionAlternativesListContext) AllExtensionAdditionAlternative() []IExtensionAdditionAlternativeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExtensionAdditionAlternativeContext)(nil)).Elem())
	var tst = make([]IExtensionAdditionAlternativeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExtensionAdditionAlternativeContext)
		}
	}

	return tst
}

func (s *ExtensionAdditionAlternativesListContext) ExtensionAdditionAlternative(i int) IExtensionAdditionAlternativeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExtensionAdditionAlternativeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExtensionAdditionAlternativeContext)
}

func (s *ExtensionAdditionAlternativesListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ASN_3gppParserCOMMA)
}

func (s *ExtensionAdditionAlternativesListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserCOMMA, i)
}

func (s *ExtensionAdditionAlternativesListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExtensionAdditionAlternativesListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExtensionAdditionAlternativesListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterExtensionAdditionAlternativesList(s)
	}
}

func (s *ExtensionAdditionAlternativesListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitExtensionAdditionAlternativesList(s)
	}
}

func (p *ASN_3gppParser) ExtensionAdditionAlternativesList() (localctx IExtensionAdditionAlternativesListContext) {
	localctx = NewExtensionAdditionAlternativesListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 236, ASN_3gppParserRULE_extensionAdditionAlternativesList)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1097)
		p.ExtensionAdditionAlternative()
	}

	p.SetState(1102)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 125, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1098)
				p.Match(ASN_3gppParserCOMMA)
			}
			{
				p.SetState(1099)
				p.ExtensionAdditionAlternative()
			}

		}
		p.SetState(1104)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 125, p.GetParserRuleContext())
	}

	return localctx
}

// IExtensionAdditionAlternativeContext is an interface to support dynamic dispatch.
type IExtensionAdditionAlternativeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExtensionAdditionAlternativeContext differentiates from other interfaces.
	IsExtensionAdditionAlternativeContext()
}

type ExtensionAdditionAlternativeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExtensionAdditionAlternativeContext() *ExtensionAdditionAlternativeContext {
	var p = new(ExtensionAdditionAlternativeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_extensionAdditionAlternative
	return p
}

func (*ExtensionAdditionAlternativeContext) IsExtensionAdditionAlternativeContext() {}

func NewExtensionAdditionAlternativeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExtensionAdditionAlternativeContext {
	var p = new(ExtensionAdditionAlternativeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_extensionAdditionAlternative

	return p
}

func (s *ExtensionAdditionAlternativeContext) GetParser() antlr.Parser { return s.parser }

func (s *ExtensionAdditionAlternativeContext) ExtensionAdditionAlternativesGroup() IExtensionAdditionAlternativesGroupContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExtensionAdditionAlternativesGroupContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExtensionAdditionAlternativesGroupContext)
}

func (s *ExtensionAdditionAlternativeContext) NamedType() INamedTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INamedTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INamedTypeContext)
}

func (s *ExtensionAdditionAlternativeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExtensionAdditionAlternativeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExtensionAdditionAlternativeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterExtensionAdditionAlternative(s)
	}
}

func (s *ExtensionAdditionAlternativeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitExtensionAdditionAlternative(s)
	}
}

func (p *ASN_3gppParser) ExtensionAdditionAlternative() (localctx IExtensionAdditionAlternativeContext) {
	localctx = NewExtensionAdditionAlternativeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 238, ASN_3gppParserRULE_extensionAdditionAlternative)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1107)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ASN_3gppParserDOUBLE_L_BRACKET:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1105)
			p.ExtensionAdditionAlternativesGroup()
		}

	case ASN_3gppParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1106)
			p.NamedType()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IExtensionAdditionAlternativesGroupContext is an interface to support dynamic dispatch.
type IExtensionAdditionAlternativesGroupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExtensionAdditionAlternativesGroupContext differentiates from other interfaces.
	IsExtensionAdditionAlternativesGroupContext()
}

type ExtensionAdditionAlternativesGroupContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExtensionAdditionAlternativesGroupContext() *ExtensionAdditionAlternativesGroupContext {
	var p = new(ExtensionAdditionAlternativesGroupContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_extensionAdditionAlternativesGroup
	return p
}

func (*ExtensionAdditionAlternativesGroupContext) IsExtensionAdditionAlternativesGroupContext() {}

func NewExtensionAdditionAlternativesGroupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExtensionAdditionAlternativesGroupContext {
	var p = new(ExtensionAdditionAlternativesGroupContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_extensionAdditionAlternativesGroup

	return p
}

func (s *ExtensionAdditionAlternativesGroupContext) GetParser() antlr.Parser { return s.parser }

func (s *ExtensionAdditionAlternativesGroupContext) DOUBLE_L_BRACKET() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserDOUBLE_L_BRACKET, 0)
}

func (s *ExtensionAdditionAlternativesGroupContext) VersionNumber() IVersionNumberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVersionNumberContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVersionNumberContext)
}

func (s *ExtensionAdditionAlternativesGroupContext) AlternativeTypeList() IAlternativeTypeListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlternativeTypeListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlternativeTypeListContext)
}

func (s *ExtensionAdditionAlternativesGroupContext) DOUBLE_R_BRACKET() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserDOUBLE_R_BRACKET, 0)
}

func (s *ExtensionAdditionAlternativesGroupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExtensionAdditionAlternativesGroupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExtensionAdditionAlternativesGroupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterExtensionAdditionAlternativesGroup(s)
	}
}

func (s *ExtensionAdditionAlternativesGroupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitExtensionAdditionAlternativesGroup(s)
	}
}

func (p *ASN_3gppParser) ExtensionAdditionAlternativesGroup() (localctx IExtensionAdditionAlternativesGroupContext) {
	localctx = NewExtensionAdditionAlternativesGroupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 240, ASN_3gppParserRULE_extensionAdditionAlternativesGroup)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1109)
		p.Match(ASN_3gppParserDOUBLE_L_BRACKET)
	}
	{
		p.SetState(1110)
		p.VersionNumber()
	}
	{
		p.SetState(1111)
		p.AlternativeTypeList()
	}
	{
		p.SetState(1112)
		p.Match(ASN_3gppParserDOUBLE_R_BRACKET)
	}

	return localctx
}

// IRootAlternativeTypeListContext is an interface to support dynamic dispatch.
type IRootAlternativeTypeListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRootAlternativeTypeListContext differentiates from other interfaces.
	IsRootAlternativeTypeListContext()
}

type RootAlternativeTypeListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRootAlternativeTypeListContext() *RootAlternativeTypeListContext {
	var p = new(RootAlternativeTypeListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_rootAlternativeTypeList
	return p
}

func (*RootAlternativeTypeListContext) IsRootAlternativeTypeListContext() {}

func NewRootAlternativeTypeListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RootAlternativeTypeListContext {
	var p = new(RootAlternativeTypeListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_rootAlternativeTypeList

	return p
}

func (s *RootAlternativeTypeListContext) GetParser() antlr.Parser { return s.parser }

func (s *RootAlternativeTypeListContext) AlternativeTypeList() IAlternativeTypeListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlternativeTypeListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlternativeTypeListContext)
}

func (s *RootAlternativeTypeListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RootAlternativeTypeListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RootAlternativeTypeListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterRootAlternativeTypeList(s)
	}
}

func (s *RootAlternativeTypeListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitRootAlternativeTypeList(s)
	}
}

func (p *ASN_3gppParser) RootAlternativeTypeList() (localctx IRootAlternativeTypeListContext) {
	localctx = NewRootAlternativeTypeListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 242, ASN_3gppParserRULE_rootAlternativeTypeList)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1114)
		p.AlternativeTypeList()
	}

	return localctx
}

// IAlternativeTypeListContext is an interface to support dynamic dispatch.
type IAlternativeTypeListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAlternativeTypeListContext differentiates from other interfaces.
	IsAlternativeTypeListContext()
}

type AlternativeTypeListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlternativeTypeListContext() *AlternativeTypeListContext {
	var p = new(AlternativeTypeListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_alternativeTypeList
	return p
}

func (*AlternativeTypeListContext) IsAlternativeTypeListContext() {}

func NewAlternativeTypeListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlternativeTypeListContext {
	var p = new(AlternativeTypeListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_alternativeTypeList

	return p
}

func (s *AlternativeTypeListContext) GetParser() antlr.Parser { return s.parser }

func (s *AlternativeTypeListContext) AllNamedType() []INamedTypeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INamedTypeContext)(nil)).Elem())
	var tst = make([]INamedTypeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INamedTypeContext)
		}
	}

	return tst
}

func (s *AlternativeTypeListContext) NamedType(i int) INamedTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INamedTypeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INamedTypeContext)
}

func (s *AlternativeTypeListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ASN_3gppParserCOMMA)
}

func (s *AlternativeTypeListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserCOMMA, i)
}

func (s *AlternativeTypeListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlternativeTypeListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlternativeTypeListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterAlternativeTypeList(s)
	}
}

func (s *AlternativeTypeListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitAlternativeTypeList(s)
	}
}

func (p *ASN_3gppParser) AlternativeTypeList() (localctx IAlternativeTypeListContext) {
	localctx = NewAlternativeTypeListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 244, ASN_3gppParserRULE_alternativeTypeList)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1116)
		p.NamedType()
	}

	p.SetState(1121)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 127, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1117)
				p.Match(ASN_3gppParserCOMMA)
			}
			{
				p.SetState(1118)
				p.NamedType()
			}

		}
		p.SetState(1123)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 127, p.GetParserRuleContext())
	}

	return localctx
}

// INamedTypeContext is an interface to support dynamic dispatch.
type INamedTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNamedTypeContext differentiates from other interfaces.
	IsNamedTypeContext()
}

type NamedTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamedTypeContext() *NamedTypeContext {
	var p = new(NamedTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_namedType
	return p
}

func (*NamedTypeContext) IsNamedTypeContext() {}

func NewNamedTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NamedTypeContext {
	var p = new(NamedTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_namedType

	return p
}

func (s *NamedTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *NamedTypeContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserIDENTIFIER, 0)
}

func (s *NamedTypeContext) AsnType() IAsnTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAsnTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAsnTypeContext)
}

func (s *NamedTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamedTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NamedTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterNamedType(s)
	}
}

func (s *NamedTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitNamedType(s)
	}
}

func (p *ASN_3gppParser) NamedType() (localctx INamedTypeContext) {
	localctx = NewNamedTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 246, ASN_3gppParserRULE_namedType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1124)
		p.Match(ASN_3gppParserIDENTIFIER)
	}
	{
		p.SetState(1125)
		p.AsnType()
	}

	return localctx
}

// IEnumeratedTypeContext is an interface to support dynamic dispatch.
type IEnumeratedTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnumeratedTypeContext differentiates from other interfaces.
	IsEnumeratedTypeContext()
}

type EnumeratedTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumeratedTypeContext() *EnumeratedTypeContext {
	var p = new(EnumeratedTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_enumeratedType
	return p
}

func (*EnumeratedTypeContext) IsEnumeratedTypeContext() {}

func NewEnumeratedTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumeratedTypeContext {
	var p = new(EnumeratedTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_enumeratedType

	return p
}

func (s *EnumeratedTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumeratedTypeContext) ENUMERATED_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserENUMERATED_LITERAL, 0)
}

func (s *EnumeratedTypeContext) L_BRACE() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserL_BRACE, 0)
}

func (s *EnumeratedTypeContext) Enumerations() IEnumerationsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnumerationsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnumerationsContext)
}

func (s *EnumeratedTypeContext) R_BRACE() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserR_BRACE, 0)
}

func (s *EnumeratedTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumeratedTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumeratedTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterEnumeratedType(s)
	}
}

func (s *EnumeratedTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitEnumeratedType(s)
	}
}

func (p *ASN_3gppParser) EnumeratedType() (localctx IEnumeratedTypeContext) {
	localctx = NewEnumeratedTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 248, ASN_3gppParserRULE_enumeratedType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1127)
		p.Match(ASN_3gppParserENUMERATED_LITERAL)
	}
	{
		p.SetState(1128)
		p.Match(ASN_3gppParserL_BRACE)
	}
	{
		p.SetState(1129)
		p.Enumerations()
	}
	{
		p.SetState(1130)
		p.Match(ASN_3gppParserR_BRACE)
	}

	return localctx
}

// IEnumerationsContext is an interface to support dynamic dispatch.
type IEnumerationsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnumerationsContext differentiates from other interfaces.
	IsEnumerationsContext()
}

type EnumerationsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumerationsContext() *EnumerationsContext {
	var p = new(EnumerationsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_enumerations
	return p
}

func (*EnumerationsContext) IsEnumerationsContext() {}

func NewEnumerationsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumerationsContext {
	var p = new(EnumerationsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_enumerations

	return p
}

func (s *EnumerationsContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumerationsContext) RootEnumeration() IRootEnumerationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRootEnumerationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRootEnumerationContext)
}

func (s *EnumerationsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ASN_3gppParserCOMMA)
}

func (s *EnumerationsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserCOMMA, i)
}

func (s *EnumerationsContext) ELLIPSIS() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserELLIPSIS, 0)
}

func (s *EnumerationsContext) ExceptionSpec() IExceptionSpecContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExceptionSpecContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExceptionSpecContext)
}

func (s *EnumerationsContext) AdditionalEnumeration() IAdditionalEnumerationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAdditionalEnumerationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAdditionalEnumerationContext)
}

func (s *EnumerationsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumerationsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumerationsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterEnumerations(s)
	}
}

func (s *EnumerationsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitEnumerations(s)
	}
}

func (p *ASN_3gppParser) Enumerations() (localctx IEnumerationsContext) {
	localctx = NewEnumerationsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 250, ASN_3gppParserRULE_enumerations)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1132)
		p.RootEnumeration()
	}
	p.SetState(1142)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ASN_3gppParserCOMMA {
		{
			p.SetState(1133)
			p.Match(ASN_3gppParserCOMMA)
		}
		{
			p.SetState(1134)
			p.Match(ASN_3gppParserELLIPSIS)
		}
		p.SetState(1136)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ASN_3gppParserEXCLAM {
			{
				p.SetState(1135)
				p.ExceptionSpec()
			}

		}
		p.SetState(1140)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == ASN_3gppParserCOMMA {
			{
				p.SetState(1138)
				p.Match(ASN_3gppParserCOMMA)
			}
			{
				p.SetState(1139)
				p.AdditionalEnumeration()
			}

		}

	}

	return localctx
}

// IRootEnumerationContext is an interface to support dynamic dispatch.
type IRootEnumerationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRootEnumerationContext differentiates from other interfaces.
	IsRootEnumerationContext()
}

type RootEnumerationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRootEnumerationContext() *RootEnumerationContext {
	var p = new(RootEnumerationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_rootEnumeration
	return p
}

func (*RootEnumerationContext) IsRootEnumerationContext() {}

func NewRootEnumerationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RootEnumerationContext {
	var p = new(RootEnumerationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_rootEnumeration

	return p
}

func (s *RootEnumerationContext) GetParser() antlr.Parser { return s.parser }

func (s *RootEnumerationContext) Enumeration() IEnumerationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnumerationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnumerationContext)
}

func (s *RootEnumerationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RootEnumerationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RootEnumerationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterRootEnumeration(s)
	}
}

func (s *RootEnumerationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitRootEnumeration(s)
	}
}

func (p *ASN_3gppParser) RootEnumeration() (localctx IRootEnumerationContext) {
	localctx = NewRootEnumerationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 252, ASN_3gppParserRULE_rootEnumeration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1144)
		p.Enumeration()
	}

	return localctx
}

// IEnumerationContext is an interface to support dynamic dispatch.
type IEnumerationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnumerationContext differentiates from other interfaces.
	IsEnumerationContext()
}

type EnumerationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumerationContext() *EnumerationContext {
	var p = new(EnumerationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_enumeration
	return p
}

func (*EnumerationContext) IsEnumerationContext() {}

func NewEnumerationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumerationContext {
	var p = new(EnumerationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_enumeration

	return p
}

func (s *EnumerationContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumerationContext) AllEnumerationItem() []IEnumerationItemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEnumerationItemContext)(nil)).Elem())
	var tst = make([]IEnumerationItemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEnumerationItemContext)
		}
	}

	return tst
}

func (s *EnumerationContext) EnumerationItem(i int) IEnumerationItemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnumerationItemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEnumerationItemContext)
}

func (s *EnumerationContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ASN_3gppParserCOMMA)
}

func (s *EnumerationContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserCOMMA, i)
}

func (s *EnumerationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumerationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumerationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterEnumeration(s)
	}
}

func (s *EnumerationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitEnumeration(s)
	}
}

func (p *ASN_3gppParser) Enumeration() (localctx IEnumerationContext) {
	localctx = NewEnumerationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 254, ASN_3gppParserRULE_enumeration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1146)
		p.EnumerationItem()
	}
	p.SetState(1151)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 131, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1147)
				p.Match(ASN_3gppParserCOMMA)
			}
			{
				p.SetState(1148)
				p.EnumerationItem()
			}

		}
		p.SetState(1153)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 131, p.GetParserRuleContext())
	}

	return localctx
}

// IEnumerationItemContext is an interface to support dynamic dispatch.
type IEnumerationItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnumerationItemContext differentiates from other interfaces.
	IsEnumerationItemContext()
}

type EnumerationItemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumerationItemContext() *EnumerationItemContext {
	var p = new(EnumerationItemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_enumerationItem
	return p
}

func (*EnumerationItemContext) IsEnumerationItemContext() {}

func NewEnumerationItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumerationItemContext {
	var p = new(EnumerationItemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_enumerationItem

	return p
}

func (s *EnumerationItemContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumerationItemContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserIDENTIFIER, 0)
}

func (s *EnumerationItemContext) NamedNumber() INamedNumberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INamedNumberContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INamedNumberContext)
}

func (s *EnumerationItemContext) Value() IValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueContext)
}

func (s *EnumerationItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumerationItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumerationItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterEnumerationItem(s)
	}
}

func (s *EnumerationItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitEnumerationItem(s)
	}
}

func (p *ASN_3gppParser) EnumerationItem() (localctx IEnumerationItemContext) {
	localctx = NewEnumerationItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 256, ASN_3gppParserRULE_enumerationItem)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1157)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 132, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1154)
			p.Match(ASN_3gppParserIDENTIFIER)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1155)
			p.NamedNumber()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1156)
			p.Value()
		}

	}

	return localctx
}

// INamedNumberContext is an interface to support dynamic dispatch.
type INamedNumberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNamedNumberContext differentiates from other interfaces.
	IsNamedNumberContext()
}

type NamedNumberContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamedNumberContext() *NamedNumberContext {
	var p = new(NamedNumberContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_namedNumber
	return p
}

func (*NamedNumberContext) IsNamedNumberContext() {}

func NewNamedNumberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NamedNumberContext {
	var p = new(NamedNumberContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_namedNumber

	return p
}

func (s *NamedNumberContext) GetParser() antlr.Parser { return s.parser }

func (s *NamedNumberContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserIDENTIFIER, 0)
}

func (s *NamedNumberContext) L_PARAN() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserL_PARAN, 0)
}

func (s *NamedNumberContext) R_PARAN() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserR_PARAN, 0)
}

func (s *NamedNumberContext) SignedNumber() ISignedNumberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISignedNumberContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISignedNumberContext)
}

func (s *NamedNumberContext) DefinedValue() IDefinedValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDefinedValueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDefinedValueContext)
}

func (s *NamedNumberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamedNumberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NamedNumberContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterNamedNumber(s)
	}
}

func (s *NamedNumberContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitNamedNumber(s)
	}
}

func (p *ASN_3gppParser) NamedNumber() (localctx INamedNumberContext) {
	localctx = NewNamedNumberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 258, ASN_3gppParserRULE_namedNumber)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1159)
		p.Match(ASN_3gppParserIDENTIFIER)
	}
	{
		p.SetState(1160)
		p.Match(ASN_3gppParserL_PARAN)
	}
	p.SetState(1163)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ASN_3gppParserMINUS, ASN_3gppParserNUMBER:
		{
			p.SetState(1161)
			p.SignedNumber()
		}

	case ASN_3gppParserIDENTIFIER:
		{
			p.SetState(1162)
			p.DefinedValue()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	{
		p.SetState(1165)
		p.Match(ASN_3gppParserR_PARAN)
	}

	return localctx
}

// IDefinedValueContext is an interface to support dynamic dispatch.
type IDefinedValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDefinedValueContext differentiates from other interfaces.
	IsDefinedValueContext()
}

type DefinedValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefinedValueContext() *DefinedValueContext {
	var p = new(DefinedValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_definedValue
	return p
}

func (*DefinedValueContext) IsDefinedValueContext() {}

func NewDefinedValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefinedValueContext {
	var p = new(DefinedValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_definedValue

	return p
}

func (s *DefinedValueContext) GetParser() antlr.Parser { return s.parser }

func (s *DefinedValueContext) ParameterizedValue() IParameterizedValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameterizedValueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameterizedValueContext)
}

func (s *DefinedValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefinedValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DefinedValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterDefinedValue(s)
	}
}

func (s *DefinedValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitDefinedValue(s)
	}
}

func (p *ASN_3gppParser) DefinedValue() (localctx IDefinedValueContext) {
	localctx = NewDefinedValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 260, ASN_3gppParserRULE_definedValue)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1167)
		p.ParameterizedValue()
	}

	return localctx
}

// IParameterizedValueContext is an interface to support dynamic dispatch.
type IParameterizedValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParameterizedValueContext differentiates from other interfaces.
	IsParameterizedValueContext()
}

type ParameterizedValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameterizedValueContext() *ParameterizedValueContext {
	var p = new(ParameterizedValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_parameterizedValue
	return p
}

func (*ParameterizedValueContext) IsParameterizedValueContext() {}

func NewParameterizedValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParameterizedValueContext {
	var p = new(ParameterizedValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_parameterizedValue

	return p
}

func (s *ParameterizedValueContext) GetParser() antlr.Parser { return s.parser }

func (s *ParameterizedValueContext) SimpleDefinedValue() ISimpleDefinedValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimpleDefinedValueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimpleDefinedValueContext)
}

func (s *ParameterizedValueContext) ActualParameterList() IActualParameterListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IActualParameterListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IActualParameterListContext)
}

func (s *ParameterizedValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParameterizedValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParameterizedValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterParameterizedValue(s)
	}
}

func (s *ParameterizedValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitParameterizedValue(s)
	}
}

func (p *ASN_3gppParser) ParameterizedValue() (localctx IParameterizedValueContext) {
	localctx = NewParameterizedValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 262, ASN_3gppParserRULE_parameterizedValue)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1169)
		p.SimpleDefinedValue()
	}
	p.SetState(1171)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ASN_3gppParserL_BRACE {
		{
			p.SetState(1170)
			p.ActualParameterList()
		}

	}

	return localctx
}

// ISimpleDefinedValueContext is an interface to support dynamic dispatch.
type ISimpleDefinedValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSimpleDefinedValueContext differentiates from other interfaces.
	IsSimpleDefinedValueContext()
}

type SimpleDefinedValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleDefinedValueContext() *SimpleDefinedValueContext {
	var p = new(SimpleDefinedValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_simpleDefinedValue
	return p
}

func (*SimpleDefinedValueContext) IsSimpleDefinedValueContext() {}

func NewSimpleDefinedValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleDefinedValueContext {
	var p = new(SimpleDefinedValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_simpleDefinedValue

	return p
}

func (s *SimpleDefinedValueContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleDefinedValueContext) AllIDENTIFIER() []antlr.TerminalNode {
	return s.GetTokens(ASN_3gppParserIDENTIFIER)
}

func (s *SimpleDefinedValueContext) IDENTIFIER(i int) antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserIDENTIFIER, i)
}

func (s *SimpleDefinedValueContext) DOT() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserDOT, 0)
}

func (s *SimpleDefinedValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleDefinedValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleDefinedValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterSimpleDefinedValue(s)
	}
}

func (s *SimpleDefinedValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitSimpleDefinedValue(s)
	}
}

func (p *ASN_3gppParser) SimpleDefinedValue() (localctx ISimpleDefinedValueContext) {
	localctx = NewSimpleDefinedValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 264, ASN_3gppParserRULE_simpleDefinedValue)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1173)
		p.Match(ASN_3gppParserIDENTIFIER)
	}
	p.SetState(1176)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ASN_3gppParserDOT {
		{
			p.SetState(1174)
			p.Match(ASN_3gppParserDOT)
		}
		{
			p.SetState(1175)
			p.Match(ASN_3gppParserIDENTIFIER)
		}

	}

	return localctx
}

// IActualParameterListContext is an interface to support dynamic dispatch.
type IActualParameterListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsActualParameterListContext differentiates from other interfaces.
	IsActualParameterListContext()
}

type ActualParameterListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyActualParameterListContext() *ActualParameterListContext {
	var p = new(ActualParameterListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_actualParameterList
	return p
}

func (*ActualParameterListContext) IsActualParameterListContext() {}

func NewActualParameterListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ActualParameterListContext {
	var p = new(ActualParameterListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_actualParameterList

	return p
}

func (s *ActualParameterListContext) GetParser() antlr.Parser { return s.parser }

func (s *ActualParameterListContext) L_BRACE() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserL_BRACE, 0)
}

func (s *ActualParameterListContext) AllActualParameter() []IActualParameterContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IActualParameterContext)(nil)).Elem())
	var tst = make([]IActualParameterContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IActualParameterContext)
		}
	}

	return tst
}

func (s *ActualParameterListContext) ActualParameter(i int) IActualParameterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IActualParameterContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IActualParameterContext)
}

func (s *ActualParameterListContext) R_BRACE() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserR_BRACE, 0)
}

func (s *ActualParameterListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ASN_3gppParserCOMMA)
}

func (s *ActualParameterListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserCOMMA, i)
}

func (s *ActualParameterListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ActualParameterListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ActualParameterListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterActualParameterList(s)
	}
}

func (s *ActualParameterListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitActualParameterList(s)
	}
}

func (p *ASN_3gppParser) ActualParameterList() (localctx IActualParameterListContext) {
	localctx = NewActualParameterListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 266, ASN_3gppParserRULE_actualParameterList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1178)
		p.Match(ASN_3gppParserL_BRACE)
	}
	{
		p.SetState(1179)
		p.ActualParameter()
	}
	p.SetState(1184)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ASN_3gppParserCOMMA {
		{
			p.SetState(1180)
			p.Match(ASN_3gppParserCOMMA)
		}
		{
			p.SetState(1181)
			p.ActualParameter()
		}

		p.SetState(1186)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1187)
		p.Match(ASN_3gppParserR_BRACE)
	}

	return localctx
}

// IActualParameterContext is an interface to support dynamic dispatch.
type IActualParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsActualParameterContext differentiates from other interfaces.
	IsActualParameterContext()
}

type ActualParameterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyActualParameterContext() *ActualParameterContext {
	var p = new(ActualParameterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_actualParameter
	return p
}

func (*ActualParameterContext) IsActualParameterContext() {}

func NewActualParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ActualParameterContext {
	var p = new(ActualParameterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_actualParameter

	return p
}

func (s *ActualParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *ActualParameterContext) AsnType() IAsnTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAsnTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAsnTypeContext)
}

func (s *ActualParameterContext) Value() IValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueContext)
}

func (s *ActualParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ActualParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ActualParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterActualParameter(s)
	}
}

func (s *ActualParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitActualParameter(s)
	}
}

func (p *ASN_3gppParser) ActualParameter() (localctx IActualParameterContext) {
	localctx = NewActualParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 268, ASN_3gppParserRULE_actualParameter)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1191)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 137, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1189)
			p.AsnType()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1190)
			p.Value()
		}

	}

	return localctx
}

// IExceptionSpecContext is an interface to support dynamic dispatch.
type IExceptionSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExceptionSpecContext differentiates from other interfaces.
	IsExceptionSpecContext()
}

type ExceptionSpecContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExceptionSpecContext() *ExceptionSpecContext {
	var p = new(ExceptionSpecContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_exceptionSpec
	return p
}

func (*ExceptionSpecContext) IsExceptionSpecContext() {}

func NewExceptionSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExceptionSpecContext {
	var p = new(ExceptionSpecContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_exceptionSpec

	return p
}

func (s *ExceptionSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *ExceptionSpecContext) EXCLAM() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserEXCLAM, 0)
}

func (s *ExceptionSpecContext) ExceptionIdentification() IExceptionIdentificationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExceptionIdentificationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExceptionIdentificationContext)
}

func (s *ExceptionSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExceptionSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExceptionSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterExceptionSpec(s)
	}
}

func (s *ExceptionSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitExceptionSpec(s)
	}
}

func (p *ASN_3gppParser) ExceptionSpec() (localctx IExceptionSpecContext) {
	localctx = NewExceptionSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 270, ASN_3gppParserRULE_exceptionSpec)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1193)
		p.Match(ASN_3gppParserEXCLAM)
	}
	{
		p.SetState(1194)
		p.ExceptionIdentification()
	}

	return localctx
}

// IExceptionIdentificationContext is an interface to support dynamic dispatch.
type IExceptionIdentificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExceptionIdentificationContext differentiates from other interfaces.
	IsExceptionIdentificationContext()
}

type ExceptionIdentificationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExceptionIdentificationContext() *ExceptionIdentificationContext {
	var p = new(ExceptionIdentificationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_exceptionIdentification
	return p
}

func (*ExceptionIdentificationContext) IsExceptionIdentificationContext() {}

func NewExceptionIdentificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExceptionIdentificationContext {
	var p = new(ExceptionIdentificationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_exceptionIdentification

	return p
}

func (s *ExceptionIdentificationContext) GetParser() antlr.Parser { return s.parser }

func (s *ExceptionIdentificationContext) SignedNumber() ISignedNumberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISignedNumberContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISignedNumberContext)
}

func (s *ExceptionIdentificationContext) DefinedValue() IDefinedValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDefinedValueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDefinedValueContext)
}

func (s *ExceptionIdentificationContext) AsnType() IAsnTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAsnTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAsnTypeContext)
}

func (s *ExceptionIdentificationContext) COLON() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserCOLON, 0)
}

func (s *ExceptionIdentificationContext) Value() IValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueContext)
}

func (s *ExceptionIdentificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExceptionIdentificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExceptionIdentificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterExceptionIdentification(s)
	}
}

func (s *ExceptionIdentificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitExceptionIdentification(s)
	}
}

func (p *ASN_3gppParser) ExceptionIdentification() (localctx IExceptionIdentificationContext) {
	localctx = NewExceptionIdentificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 272, ASN_3gppParserRULE_exceptionIdentification)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1202)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 138, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1196)
			p.SignedNumber()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1197)
			p.DefinedValue()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1198)
			p.AsnType()
		}
		{
			p.SetState(1199)
			p.Match(ASN_3gppParserCOLON)
		}
		{
			p.SetState(1200)
			p.Value()
		}

	}

	return localctx
}

// IAdditionalEnumerationContext is an interface to support dynamic dispatch.
type IAdditionalEnumerationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAdditionalEnumerationContext differentiates from other interfaces.
	IsAdditionalEnumerationContext()
}

type AdditionalEnumerationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAdditionalEnumerationContext() *AdditionalEnumerationContext {
	var p = new(AdditionalEnumerationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_additionalEnumeration
	return p
}

func (*AdditionalEnumerationContext) IsAdditionalEnumerationContext() {}

func NewAdditionalEnumerationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AdditionalEnumerationContext {
	var p = new(AdditionalEnumerationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_additionalEnumeration

	return p
}

func (s *AdditionalEnumerationContext) GetParser() antlr.Parser { return s.parser }

func (s *AdditionalEnumerationContext) Enumeration() IEnumerationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnumerationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnumerationContext)
}

func (s *AdditionalEnumerationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdditionalEnumerationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AdditionalEnumerationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterAdditionalEnumeration(s)
	}
}

func (s *AdditionalEnumerationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitAdditionalEnumeration(s)
	}
}

func (p *ASN_3gppParser) AdditionalEnumeration() (localctx IAdditionalEnumerationContext) {
	localctx = NewAdditionalEnumerationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 274, ASN_3gppParserRULE_additionalEnumeration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1204)
		p.Enumeration()
	}

	return localctx
}

// IIntegerTypeContext is an interface to support dynamic dispatch.
type IIntegerTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIntegerTypeContext differentiates from other interfaces.
	IsIntegerTypeContext()
}

type IntegerTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIntegerTypeContext() *IntegerTypeContext {
	var p = new(IntegerTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_integerType
	return p
}

func (*IntegerTypeContext) IsIntegerTypeContext() {}

func NewIntegerTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntegerTypeContext {
	var p = new(IntegerTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_integerType

	return p
}

func (s *IntegerTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *IntegerTypeContext) INTEGER_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserINTEGER_LITERAL, 0)
}

func (s *IntegerTypeContext) L_BRACE() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserL_BRACE, 0)
}

func (s *IntegerTypeContext) NamedNumberList() INamedNumberListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INamedNumberListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INamedNumberListContext)
}

func (s *IntegerTypeContext) R_BRACE() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserR_BRACE, 0)
}

func (s *IntegerTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntegerTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IntegerTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterIntegerType(s)
	}
}

func (s *IntegerTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitIntegerType(s)
	}
}

func (p *ASN_3gppParser) IntegerType() (localctx IIntegerTypeContext) {
	localctx = NewIntegerTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 276, ASN_3gppParserRULE_integerType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1206)
		p.Match(ASN_3gppParserINTEGER_LITERAL)
	}
	p.SetState(1211)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 139, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1207)
			p.Match(ASN_3gppParserL_BRACE)
		}
		{
			p.SetState(1208)
			p.NamedNumberList()
		}
		{
			p.SetState(1209)
			p.Match(ASN_3gppParserR_BRACE)
		}

	}

	return localctx
}

// INamedNumberListContext is an interface to support dynamic dispatch.
type INamedNumberListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNamedNumberListContext differentiates from other interfaces.
	IsNamedNumberListContext()
}

type NamedNumberListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamedNumberListContext() *NamedNumberListContext {
	var p = new(NamedNumberListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_namedNumberList
	return p
}

func (*NamedNumberListContext) IsNamedNumberListContext() {}

func NewNamedNumberListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NamedNumberListContext {
	var p = new(NamedNumberListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_namedNumberList

	return p
}

func (s *NamedNumberListContext) GetParser() antlr.Parser { return s.parser }

func (s *NamedNumberListContext) AllNamedNumber() []INamedNumberContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INamedNumberContext)(nil)).Elem())
	var tst = make([]INamedNumberContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INamedNumberContext)
		}
	}

	return tst
}

func (s *NamedNumberListContext) NamedNumber(i int) INamedNumberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INamedNumberContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INamedNumberContext)
}

func (s *NamedNumberListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ASN_3gppParserCOMMA)
}

func (s *NamedNumberListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserCOMMA, i)
}

func (s *NamedNumberListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamedNumberListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NamedNumberListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterNamedNumberList(s)
	}
}

func (s *NamedNumberListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitNamedNumberList(s)
	}
}

func (p *ASN_3gppParser) NamedNumberList() (localctx INamedNumberListContext) {
	localctx = NewNamedNumberListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 278, ASN_3gppParserRULE_namedNumberList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1213)
		p.NamedNumber()
	}

	p.SetState(1218)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ASN_3gppParserCOMMA {
		{
			p.SetState(1214)
			p.Match(ASN_3gppParserCOMMA)
		}
		{
			p.SetState(1215)
			p.NamedNumber()
		}

		p.SetState(1220)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IObjectidentifiertypeContext is an interface to support dynamic dispatch.
type IObjectidentifiertypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObjectidentifiertypeContext differentiates from other interfaces.
	IsObjectidentifiertypeContext()
}

type ObjectidentifiertypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObjectidentifiertypeContext() *ObjectidentifiertypeContext {
	var p = new(ObjectidentifiertypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_objectidentifiertype
	return p
}

func (*ObjectidentifiertypeContext) IsObjectidentifiertypeContext() {}

func NewObjectidentifiertypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjectidentifiertypeContext {
	var p = new(ObjectidentifiertypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_objectidentifiertype

	return p
}

func (s *ObjectidentifiertypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjectidentifiertypeContext) OBJECT_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserOBJECT_LITERAL, 0)
}

func (s *ObjectidentifiertypeContext) IDENTIFIER_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserIDENTIFIER_LITERAL, 0)
}

func (s *ObjectidentifiertypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectidentifiertypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObjectidentifiertypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterObjectidentifiertype(s)
	}
}

func (s *ObjectidentifiertypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitObjectidentifiertype(s)
	}
}

func (p *ASN_3gppParser) Objectidentifiertype() (localctx IObjectidentifiertypeContext) {
	localctx = NewObjectidentifiertypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 280, ASN_3gppParserRULE_objectidentifiertype)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1221)
		p.Match(ASN_3gppParserOBJECT_LITERAL)
	}
	{
		p.SetState(1222)
		p.Match(ASN_3gppParserIDENTIFIER_LITERAL)
	}

	return localctx
}

// IComponentRelationConstraintContext is an interface to support dynamic dispatch.
type IComponentRelationConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComponentRelationConstraintContext differentiates from other interfaces.
	IsComponentRelationConstraintContext()
}

type ComponentRelationConstraintContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComponentRelationConstraintContext() *ComponentRelationConstraintContext {
	var p = new(ComponentRelationConstraintContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_componentRelationConstraint
	return p
}

func (*ComponentRelationConstraintContext) IsComponentRelationConstraintContext() {}

func NewComponentRelationConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComponentRelationConstraintContext {
	var p = new(ComponentRelationConstraintContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_componentRelationConstraint

	return p
}

func (s *ComponentRelationConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *ComponentRelationConstraintContext) AllL_BRACE() []antlr.TerminalNode {
	return s.GetTokens(ASN_3gppParserL_BRACE)
}

func (s *ComponentRelationConstraintContext) L_BRACE(i int) antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserL_BRACE, i)
}

func (s *ComponentRelationConstraintContext) AllR_BRACE() []antlr.TerminalNode {
	return s.GetTokens(ASN_3gppParserR_BRACE)
}

func (s *ComponentRelationConstraintContext) R_BRACE(i int) antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserR_BRACE, i)
}

func (s *ComponentRelationConstraintContext) AllIDENTIFIER() []antlr.TerminalNode {
	return s.GetTokens(ASN_3gppParserIDENTIFIER)
}

func (s *ComponentRelationConstraintContext) IDENTIFIER(i int) antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserIDENTIFIER, i)
}

func (s *ComponentRelationConstraintContext) AllAtNotation() []IAtNotationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAtNotationContext)(nil)).Elem())
	var tst = make([]IAtNotationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAtNotationContext)
		}
	}

	return tst
}

func (s *ComponentRelationConstraintContext) AtNotation(i int) IAtNotationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtNotationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAtNotationContext)
}

func (s *ComponentRelationConstraintContext) DOT() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserDOT, 0)
}

func (s *ComponentRelationConstraintContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ASN_3gppParserCOMMA)
}

func (s *ComponentRelationConstraintContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserCOMMA, i)
}

func (s *ComponentRelationConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComponentRelationConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComponentRelationConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterComponentRelationConstraint(s)
	}
}

func (s *ComponentRelationConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitComponentRelationConstraint(s)
	}
}

func (p *ASN_3gppParser) ComponentRelationConstraint() (localctx IComponentRelationConstraintContext) {
	localctx = NewComponentRelationConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 282, ASN_3gppParserRULE_componentRelationConstraint)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1224)
		p.Match(ASN_3gppParserL_BRACE)
	}

	{
		p.SetState(1225)
		p.Match(ASN_3gppParserIDENTIFIER)
	}
	p.SetState(1228)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ASN_3gppParserDOT {
		{
			p.SetState(1226)
			p.Match(ASN_3gppParserDOT)
		}
		{
			p.SetState(1227)
			p.Match(ASN_3gppParserIDENTIFIER)
		}

	}

	{
		p.SetState(1230)
		p.Match(ASN_3gppParserR_BRACE)
	}
	p.SetState(1242)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ASN_3gppParserL_BRACE {
		{
			p.SetState(1231)
			p.Match(ASN_3gppParserL_BRACE)
		}
		{
			p.SetState(1232)
			p.AtNotation()
		}
		p.SetState(1237)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == ASN_3gppParserCOMMA {
			{
				p.SetState(1233)
				p.Match(ASN_3gppParserCOMMA)
			}
			{
				p.SetState(1234)
				p.AtNotation()
			}

			p.SetState(1239)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1240)
			p.Match(ASN_3gppParserR_BRACE)
		}

	}

	return localctx
}

// IAtNotationContext is an interface to support dynamic dispatch.
type IAtNotationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAtNotationContext differentiates from other interfaces.
	IsAtNotationContext()
}

type AtNotationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAtNotationContext() *AtNotationContext {
	var p = new(AtNotationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_atNotation
	return p
}

func (*AtNotationContext) IsAtNotationContext() {}

func NewAtNotationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AtNotationContext {
	var p = new(AtNotationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_atNotation

	return p
}

func (s *AtNotationContext) GetParser() antlr.Parser { return s.parser }

func (s *AtNotationContext) ComponentIdList() IComponentIdListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComponentIdListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComponentIdListContext)
}

func (s *AtNotationContext) A_ROND() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserA_ROND, 0)
}

func (s *AtNotationContext) A_ROND_DOT() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserA_ROND_DOT, 0)
}

func (s *AtNotationContext) Level() ILevelContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILevelContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILevelContext)
}

func (s *AtNotationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AtNotationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AtNotationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterAtNotation(s)
	}
}

func (s *AtNotationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitAtNotation(s)
	}
}

func (p *ASN_3gppParser) AtNotation() (localctx IAtNotationContext) {
	localctx = NewAtNotationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 284, ASN_3gppParserRULE_atNotation)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1247)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ASN_3gppParserA_ROND:
		{
			p.SetState(1244)
			p.Match(ASN_3gppParserA_ROND)
		}

	case ASN_3gppParserA_ROND_DOT:
		{
			p.SetState(1245)
			p.Match(ASN_3gppParserA_ROND_DOT)
		}
		{
			p.SetState(1246)
			p.Level()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	{
		p.SetState(1249)
		p.ComponentIdList()
	}

	return localctx
}

// ILevelContext is an interface to support dynamic dispatch.
type ILevelContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLevelContext differentiates from other interfaces.
	IsLevelContext()
}

type LevelContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLevelContext() *LevelContext {
	var p = new(LevelContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_level
	return p
}

func (*LevelContext) IsLevelContext() {}

func NewLevelContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LevelContext {
	var p = new(LevelContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_level

	return p
}

func (s *LevelContext) GetParser() antlr.Parser { return s.parser }

func (s *LevelContext) DOT() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserDOT, 0)
}

func (s *LevelContext) Level() ILevelContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILevelContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILevelContext)
}

func (s *LevelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LevelContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LevelContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterLevel(s)
	}
}

func (s *LevelContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitLevel(s)
	}
}

func (p *ASN_3gppParser) Level() (localctx ILevelContext) {
	localctx = NewLevelContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 286, ASN_3gppParserRULE_level)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1253)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ASN_3gppParserDOT {
		{
			p.SetState(1251)
			p.Match(ASN_3gppParserDOT)
		}
		{
			p.SetState(1252)
			p.Level()
		}

	}

	return localctx
}

// IComponentIdListContext is an interface to support dynamic dispatch.
type IComponentIdListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComponentIdListContext differentiates from other interfaces.
	IsComponentIdListContext()
}

type ComponentIdListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComponentIdListContext() *ComponentIdListContext {
	var p = new(ComponentIdListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_componentIdList
	return p
}

func (*ComponentIdListContext) IsComponentIdListContext() {}

func NewComponentIdListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComponentIdListContext {
	var p = new(ComponentIdListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_componentIdList

	return p
}

func (s *ComponentIdListContext) GetParser() antlr.Parser { return s.parser }

func (s *ComponentIdListContext) AllIDENTIFIER() []antlr.TerminalNode {
	return s.GetTokens(ASN_3gppParserIDENTIFIER)
}

func (s *ComponentIdListContext) IDENTIFIER(i int) antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserIDENTIFIER, i)
}

func (s *ComponentIdListContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(ASN_3gppParserDOT)
}

func (s *ComponentIdListContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserDOT, i)
}

func (s *ComponentIdListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComponentIdListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComponentIdListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterComponentIdList(s)
	}
}

func (s *ComponentIdListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitComponentIdList(s)
	}
}

func (p *ASN_3gppParser) ComponentIdList() (localctx IComponentIdListContext) {
	localctx = NewComponentIdListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 288, ASN_3gppParserRULE_componentIdList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1255)
		p.Match(ASN_3gppParserIDENTIFIER)
	}
	p.SetState(1260)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ASN_3gppParserDOT {
		{
			p.SetState(1256)
			p.Match(ASN_3gppParserDOT)
		}
		{
			p.SetState(1257)
			p.Match(ASN_3gppParserIDENTIFIER)
		}

		p.SetState(1262)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IOctetStringTypeContext is an interface to support dynamic dispatch.
type IOctetStringTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOctetStringTypeContext differentiates from other interfaces.
	IsOctetStringTypeContext()
}

type OctetStringTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOctetStringTypeContext() *OctetStringTypeContext {
	var p = new(OctetStringTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_octetStringType
	return p
}

func (*OctetStringTypeContext) IsOctetStringTypeContext() {}

func NewOctetStringTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OctetStringTypeContext {
	var p = new(OctetStringTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_octetStringType

	return p
}

func (s *OctetStringTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *OctetStringTypeContext) OCTET_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserOCTET_LITERAL, 0)
}

func (s *OctetStringTypeContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserSTRING_LITERAL, 0)
}

func (s *OctetStringTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OctetStringTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OctetStringTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterOctetStringType(s)
	}
}

func (s *OctetStringTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitOctetStringType(s)
	}
}

func (p *ASN_3gppParser) OctetStringType() (localctx IOctetStringTypeContext) {
	localctx = NewOctetStringTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 290, ASN_3gppParserRULE_octetStringType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1263)
		p.Match(ASN_3gppParserOCTET_LITERAL)
	}
	{
		p.SetState(1264)
		p.Match(ASN_3gppParserSTRING_LITERAL)
	}

	return localctx
}

// IBitStringTypeContext is an interface to support dynamic dispatch.
type IBitStringTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBitStringTypeContext differentiates from other interfaces.
	IsBitStringTypeContext()
}

type BitStringTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBitStringTypeContext() *BitStringTypeContext {
	var p = new(BitStringTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_bitStringType
	return p
}

func (*BitStringTypeContext) IsBitStringTypeContext() {}

func NewBitStringTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BitStringTypeContext {
	var p = new(BitStringTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_bitStringType

	return p
}

func (s *BitStringTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *BitStringTypeContext) BIT_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserBIT_LITERAL, 0)
}

func (s *BitStringTypeContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserSTRING_LITERAL, 0)
}

func (s *BitStringTypeContext) L_BRACE() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserL_BRACE, 0)
}

func (s *BitStringTypeContext) NamedBitList() INamedBitListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INamedBitListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INamedBitListContext)
}

func (s *BitStringTypeContext) R_BRACE() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserR_BRACE, 0)
}

func (s *BitStringTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BitStringTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BitStringTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterBitStringType(s)
	}
}

func (s *BitStringTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitBitStringType(s)
	}
}

func (p *ASN_3gppParser) BitStringType() (localctx IBitStringTypeContext) {
	localctx = NewBitStringTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 292, ASN_3gppParserRULE_bitStringType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1266)
		p.Match(ASN_3gppParserBIT_LITERAL)
	}
	{
		p.SetState(1267)
		p.Match(ASN_3gppParserSTRING_LITERAL)
	}

	p.SetState(1273)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 147, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1269)
			p.Match(ASN_3gppParserL_BRACE)
		}
		{
			p.SetState(1270)
			p.NamedBitList()
		}
		{
			p.SetState(1271)
			p.Match(ASN_3gppParserR_BRACE)
		}

	}

	return localctx
}

// INamedBitListContext is an interface to support dynamic dispatch.
type INamedBitListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNamedBitListContext differentiates from other interfaces.
	IsNamedBitListContext()
}

type NamedBitListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamedBitListContext() *NamedBitListContext {
	var p = new(NamedBitListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_namedBitList
	return p
}

func (*NamedBitListContext) IsNamedBitListContext() {}

func NewNamedBitListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NamedBitListContext {
	var p = new(NamedBitListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_namedBitList

	return p
}

func (s *NamedBitListContext) GetParser() antlr.Parser { return s.parser }

func (s *NamedBitListContext) AllNamedBit() []INamedBitContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INamedBitContext)(nil)).Elem())
	var tst = make([]INamedBitContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INamedBitContext)
		}
	}

	return tst
}

func (s *NamedBitListContext) NamedBit(i int) INamedBitContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INamedBitContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INamedBitContext)
}

func (s *NamedBitListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ASN_3gppParserCOMMA)
}

func (s *NamedBitListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserCOMMA, i)
}

func (s *NamedBitListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamedBitListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NamedBitListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterNamedBitList(s)
	}
}

func (s *NamedBitListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitNamedBitList(s)
	}
}

func (p *ASN_3gppParser) NamedBitList() (localctx INamedBitListContext) {
	localctx = NewNamedBitListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 294, ASN_3gppParserRULE_namedBitList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1275)
		p.NamedBit()
	}

	p.SetState(1280)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == ASN_3gppParserCOMMA {
		{
			p.SetState(1276)
			p.Match(ASN_3gppParserCOMMA)
		}
		{
			p.SetState(1277)
			p.NamedBit()
		}

		p.SetState(1282)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// INamedBitContext is an interface to support dynamic dispatch.
type INamedBitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNamedBitContext differentiates from other interfaces.
	IsNamedBitContext()
}

type NamedBitContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamedBitContext() *NamedBitContext {
	var p = new(NamedBitContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_namedBit
	return p
}

func (*NamedBitContext) IsNamedBitContext() {}

func NewNamedBitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NamedBitContext {
	var p = new(NamedBitContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_namedBit

	return p
}

func (s *NamedBitContext) GetParser() antlr.Parser { return s.parser }

func (s *NamedBitContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserIDENTIFIER, 0)
}

func (s *NamedBitContext) L_PARAN() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserL_PARAN, 0)
}

func (s *NamedBitContext) R_PARAN() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserR_PARAN, 0)
}

func (s *NamedBitContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserNUMBER, 0)
}

func (s *NamedBitContext) DefinedValue() IDefinedValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDefinedValueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDefinedValueContext)
}

func (s *NamedBitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamedBitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NamedBitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterNamedBit(s)
	}
}

func (s *NamedBitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitNamedBit(s)
	}
}

func (p *ASN_3gppParser) NamedBit() (localctx INamedBitContext) {
	localctx = NewNamedBitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 296, ASN_3gppParserRULE_namedBit)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1283)
		p.Match(ASN_3gppParserIDENTIFIER)
	}
	{
		p.SetState(1284)
		p.Match(ASN_3gppParserL_PARAN)
	}
	p.SetState(1287)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ASN_3gppParserNUMBER:
		{
			p.SetState(1285)
			p.Match(ASN_3gppParserNUMBER)
		}

	case ASN_3gppParserIDENTIFIER:
		{
			p.SetState(1286)
			p.DefinedValue()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	{
		p.SetState(1289)
		p.Match(ASN_3gppParserR_PARAN)
	}

	return localctx
}

// IBooleanValueContext is an interface to support dynamic dispatch.
type IBooleanValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBooleanValueContext differentiates from other interfaces.
	IsBooleanValueContext()
}

type BooleanValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBooleanValueContext() *BooleanValueContext {
	var p = new(BooleanValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ASN_3gppParserRULE_booleanValue
	return p
}

func (*BooleanValueContext) IsBooleanValueContext() {}

func NewBooleanValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BooleanValueContext {
	var p = new(BooleanValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ASN_3gppParserRULE_booleanValue

	return p
}

func (s *BooleanValueContext) GetParser() antlr.Parser { return s.parser }

func (s *BooleanValueContext) TRUE_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserTRUE_LITERAL, 0)
}

func (s *BooleanValueContext) FALSE_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserFALSE_LITERAL, 0)
}

func (s *BooleanValueContext) TRUE_SMALL_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserTRUE_SMALL_LITERAL, 0)
}

func (s *BooleanValueContext) FALSE_SMALL_LITERAL() antlr.TerminalNode {
	return s.GetToken(ASN_3gppParserFALSE_SMALL_LITERAL, 0)
}

func (s *BooleanValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BooleanValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.EnterBooleanValue(s)
	}
}

func (s *BooleanValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ASN_3gppListener); ok {
		listenerT.ExitBooleanValue(s)
	}
}

func (p *ASN_3gppParser) BooleanValue() (localctx IBooleanValueContext) {
	localctx = NewBooleanValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 298, ASN_3gppParserRULE_booleanValue)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1291)
		_la = p.GetTokenStream().LA(1)

		if !(((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ASN_3gppParserTRUE_LITERAL)|(1<<ASN_3gppParserFALSE_LITERAL)|(1<<ASN_3gppParserTRUE_SMALL_LITERAL)|(1<<ASN_3gppParserFALSE_SMALL_LITERAL))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}
